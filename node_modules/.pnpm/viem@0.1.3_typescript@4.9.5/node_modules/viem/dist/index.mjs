import {
  getEnsAddress,
  getEnsName,
  labelhash,
  namehash
} from "./chunk-PLPHFY5A.mjs";
import {
  AbiConstructorNotFoundError,
  AbiConstructorParamsNotFoundError,
  AbiDecodingDataSizeInvalidError,
  AbiDecodingZeroDataError,
  AbiEncodingArrayLengthMismatchError,
  AbiEncodingLengthMismatchError,
  AbiErrorInputsNotFoundError,
  AbiErrorNotFoundError,
  AbiErrorSignatureNotFoundError,
  AbiEventNotFoundError,
  AbiEventSignatureNotFoundError,
  AbiFunctionNotFoundError,
  AbiFunctionOutputsNotFoundError,
  AbiFunctionSignatureNotFoundError,
  BaseError,
  BlockNotFoundError,
  CallExecutionError,
  ChainDoesNotSupportContract,
  ContractFunctionExecutionError,
  ContractFunctionRevertedError,
  ContractFunctionZeroDataError,
  DataLengthTooLongError,
  DataLengthTooShortError,
  EstimateGasExecutionError,
  ExecutionRevertedError,
  FeeCapTooHighError,
  FeeCapTooLowError,
  FilterTypeNotSupportedError,
  HttpRequestError,
  InsufficientFundsError,
  InternalRpcError,
  IntrinsicGasTooHighError,
  IntrinsicGasTooLowError,
  InvalidAbiDecodingTypeError,
  InvalidAbiEncodingTypeError,
  InvalidAddressError,
  InvalidArrayError,
  InvalidBytesBooleanError,
  InvalidDefinitionTypeError,
  InvalidHexBooleanError,
  InvalidHexValueError,
  InvalidInputRpcError,
  InvalidParamsRpcError,
  InvalidRequestRpcError,
  JsonRpcVersionUnsupportedError,
  LimitExceededRpcError,
  MethodNotFoundRpcError,
  MethodNotSupportedRpcError,
  NonceMaxValueError,
  NonceTooHighError,
  NonceTooLowError,
  OffsetOutOfBoundsError,
  ParseRpcError,
  RawContractError,
  RequestError,
  ResourceNotFoundRpcError,
  ResourceUnavailableRpcError,
  RpcError,
  RpcRequestError,
  SizeExceedsPaddingSizeError,
  SwitchChainError,
  TimeoutError,
  TipAboveFeeCapError,
  TransactionExecutionError,
  TransactionNotFoundError,
  TransactionReceiptNotFoundError,
  TransactionRejectedRpcError,
  TransactionTypeNotSupportedError,
  UnknownNodeError,
  UnknownRpcError,
  UrlRequiredError,
  UserRejectedRequestError,
  WaitForTransactionReceiptTimeoutError,
  WebSocketRequestError,
  addChain,
  boolToBytes,
  boolToHex,
  buildRequest,
  bytesToBigint,
  bytesToBool,
  bytesToHex,
  bytesToNumber,
  bytesToString,
  call,
  createBlockFilter,
  createContractEventFilter,
  createEventFilter,
  createPendingTransactionFilter,
  decodeAbiParameters,
  decodeErrorResult,
  decodeEventLog,
  decodeFunctionData,
  decodeFunctionResult,
  defineBlock,
  defineChain,
  defineTransaction,
  defineTransactionReceipt,
  defineTransactionRequest,
  deployContract,
  dropTransaction,
  encodeAbiParameters,
  encodeDeployData,
  encodeErrorResult,
  encodeEventTopics,
  encodeFunctionData,
  encodeFunctionResult,
  encodePacked,
  estimateContractGas,
  estimateGas,
  etherUnits,
  formatBlock,
  formatEther,
  formatGwei,
  formatTransaction,
  formatTransactionRequest,
  formatUnits,
  fromBytes,
  fromHex,
  fromRlp,
  getAbiItem,
  getAccount,
  getAddress,
  getAddresses,
  getAutomine,
  getBalance,
  getBlock,
  getBlockNumber,
  getBlockTransactionCount,
  getBytecode,
  getChainId,
  getContractAddress,
  getContractError,
  getCreate2Address,
  getCreateAddress,
  getEventSelector,
  getFeeHistory,
  getFilterChanges,
  getFilterLogs,
  getFunctionSelector,
  getGasPrice,
  getLogs,
  getPermissions,
  getSocket,
  getStorageAt,
  getTransaction,
  getTransactionConfirmations,
  getTransactionReceipt,
  getTxpoolContent,
  getTxpoolStatus,
  gweiUnits,
  hexToBigInt,
  hexToBool,
  hexToBytes,
  hexToNumber,
  hexToString,
  impersonateAccount,
  increaseTime,
  inspectTxpool,
  isAddress,
  isAddressEqual,
  isBytes,
  isDeterministicError,
  isHex,
  keccak256,
  mine,
  multicall,
  multicall3Abi,
  numberToBytes,
  numberToHex,
  pad,
  padBytes,
  padHex,
  parseAbi,
  parseAbiItem,
  parseAbiParameter,
  parseAbiParameters,
  parseEther,
  parseGwei,
  parseUnits,
  readContract,
  removeBlockTimestampInterval,
  requestAddresses,
  requestPermissions,
  reset,
  revert,
  rpc,
  sendTransaction,
  sendUnsignedTransaction,
  setAutomine,
  setBalance,
  setBlockGasLimit,
  setBlockTimestampInterval,
  setCode,
  setCoinbase,
  setIntervalMining,
  setLoggingEnabled,
  setMinGasPrice,
  setNextBlockBaseFeePerGas,
  setNextBlockTimestamp,
  setNonce,
  setRpcUrl,
  setStorageAt,
  signMessage,
  simulateContract,
  size,
  slice,
  sliceBytes,
  sliceHex,
  snapshot,
  stopImpersonatingAccount,
  stringToBytes,
  stringToHex,
  stringify,
  switchChain,
  toBytes,
  toHex,
  toRlp,
  transactionType,
  trim,
  uninstallFilter,
  waitForTransactionReceipt,
  watchAsset,
  watchBlockNumber,
  watchBlocks,
  watchContractEvent,
  watchEvent,
  watchPendingTransactions,
  weiUnits,
  writeContract
} from "./chunk-UJYIRVKR.mjs";

// src/clients/transports/createTransport.ts
function createTransport({
  key,
  name,
  request,
  retryCount = 3,
  retryDelay = 150,
  timeout,
  type
}, value) {
  return {
    config: { key, name, request, retryCount, retryDelay, timeout, type },
    request: buildRequest(request, { retryCount, retryDelay }),
    value
  };
}

// src/clients/transports/custom.ts
function custom(provider, config = {}) {
  const { key = "custom", name = "Custom Provider", retryDelay } = config;
  return ({ retryCount: defaultRetryCount }) => createTransport({
    key,
    name,
    request: provider.request.bind(provider),
    retryCount: config.retryCount ?? defaultRetryCount,
    retryDelay,
    type: "custom"
  });
}

// src/clients/transports/fallback.ts
function fallback(transports, config = {}) {
  const { key = "fallback", name = "Fallback", retryCount, retryDelay } = config;
  return ({ chain }) => createTransport(
    {
      key,
      name,
      async request({ method, params }) {
        const fetch = async (i = 0) => {
          const transport = transports[i]({ chain, retryCount: 0 });
          try {
            return await transport.request({
              method,
              params
            });
          } catch (err) {
            if (isDeterministicError(err))
              throw err;
            if (i === transports.length - 1)
              throw err;
            return fetch(i + 1);
          }
        };
        return fetch();
      },
      retryCount,
      retryDelay,
      type: "fallback"
    },
    {
      transports: transports.map(
        (fn) => fn({ chain, retryCount: 0 })
      )
    }
  );
}

// src/clients/transports/http.ts
function http(url, config = {}) {
  const {
    fetchOptions,
    key = "http",
    name = "HTTP JSON-RPC",
    retryDelay,
    timeout = 1e4
  } = config;
  return ({ chain, retryCount: defaultRetryCount }) => {
    const retryCount = config.retryCount ?? defaultRetryCount;
    const url_ = url || chain?.rpcUrls.default.http[0];
    if (!url_)
      throw new UrlRequiredError();
    return createTransport(
      {
        key,
        name,
        async request({ method, params }) {
          const { result } = await rpc.http(url_, {
            body: {
              method,
              params
            },
            fetchOptions,
            timeout
          });
          return result;
        },
        retryCount,
        retryDelay,
        timeout,
        type: "http"
      },
      {
        url
      }
    );
  };
}

// src/clients/transports/webSocket.ts
function webSocket(url, config = {}) {
  const {
    key = "webSocket",
    name = "WebSocket JSON-RPC",
    retryDelay,
    timeout = 1e4
  } = config;
  return ({ chain, retryCount: defaultRetryCount }) => {
    const retryCount = config.retryCount ?? defaultRetryCount;
    const url_ = url || chain?.rpcUrls.default.webSocket?.[0];
    if (!url_)
      throw new UrlRequiredError();
    return createTransport(
      {
        key,
        name,
        async request({ method, params }) {
          const socket = await getSocket(url_);
          const { result } = await rpc.webSocketAsync(socket, {
            body: { method, params },
            timeout
          });
          return result;
        },
        retryCount,
        retryDelay,
        timeout,
        type: "webSocket"
      },
      {
        getSocket() {
          return getSocket(url_);
        },
        async subscribe({ params, onData, onError }) {
          const socket = await getSocket(url_);
          const { result: subscriptionId } = await new Promise(
            (resolve, reject) => rpc.webSocket(socket, {
              body: {
                method: "eth_subscribe",
                params
              },
              onData: (data) => {
                if (typeof data.id === "number") {
                  resolve(data);
                  return;
                }
                onData(data);
              },
              onError: (error) => {
                reject(error);
                onError?.(error);
              }
            })
          );
          return {
            subscriptionId,
            async unsubscribe() {
              return new Promise(
                (resolve, reject) => rpc.webSocket(socket, {
                  body: {
                    method: "eth_unsubscribe",
                    params: [subscriptionId]
                  },
                  onData: resolve,
                  onError: reject
                })
              );
            }
          };
        }
      }
    );
  };
}

// src/utils/uid.ts
var size2 = 256;
var index = size2;
var buffer;
function uid(length = 11) {
  if (!buffer || index + length > size2 * 2) {
    buffer = "";
    index = 0;
    for (let i = 0; i < size2; i++) {
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer.substring(index, index++ + length);
}

// src/clients/createClient.ts
function createClient({
  chain,
  key = "base",
  name = "Base Client",
  pollingInterval = 4e3,
  transport,
  type = "base"
}) {
  const { config, request, value } = transport({ chain });
  return {
    chain,
    key,
    name,
    pollingInterval,
    request,
    transport: { ...config, ...value },
    type,
    uid: uid()
  };
}

// src/clients/decorators/public.ts
var publicActions = (client) => ({
  call: (args) => call(client, args),
  createBlockFilter: () => createBlockFilter(client),
  createContractEventFilter: (args) => createContractEventFilter(client, args),
  createEventFilter: (args) => createEventFilter(client, args),
  createPendingTransactionFilter: () => createPendingTransactionFilter(client),
  estimateContractGas: (args) => estimateContractGas(client, args),
  estimateGas: (args) => estimateGas(client, args),
  getBalance: (args) => getBalance(client, args),
  getBlock: (args) => getBlock(client, args),
  getBlockNumber: (args) => getBlockNumber(client, args),
  getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),
  getBytecode: (args) => getBytecode(client, args),
  getChainId: () => getChainId(client),
  getEnsAddress: (args) => getEnsAddress(client, args),
  getEnsName: (args) => getEnsName(client, args),
  getFeeHistory: (args) => getFeeHistory(client, args),
  getFilterChanges: (args) => getFilterChanges(client, args),
  getFilterLogs: (args) => getFilterLogs(client, args),
  getGasPrice: () => getGasPrice(client),
  getLogs: (args) => getLogs(client, args),
  getStorageAt: (args) => getStorageAt(client, args),
  getTransaction: (args) => getTransaction(client, args),
  getTransactionConfirmations: (args) => getTransactionConfirmations(client, args),
  getTransactionReceipt: (args) => getTransactionReceipt(client, args),
  multicall: (args) => multicall(client, args),
  readContract: (args) => readContract(client, args),
  simulateContract: (args) => simulateContract(client, args),
  uninstallFilter: (args) => uninstallFilter(client, args),
  waitForTransactionReceipt: (args) => waitForTransactionReceipt(client, args),
  watchBlocks: (args) => watchBlocks(client, args),
  watchBlockNumber: (args) => watchBlockNumber(client, args),
  watchContractEvent: (args) => watchContractEvent(client, args),
  watchEvent: (args) => watchEvent(client, args),
  watchPendingTransactions: (args) => watchPendingTransactions(client, args)
});

// src/clients/decorators/test.ts
var testActions = (client) => ({
  dropTransaction: (args) => dropTransaction(client, args),
  getAutomine: () => getAutomine(client),
  getTxpoolContent: () => getTxpoolContent(client),
  getTxpoolStatus: () => getTxpoolStatus(client),
  impersonateAccount: (args) => impersonateAccount(client, args),
  increaseTime: (args) => increaseTime(client, args),
  inspectTxpool: () => inspectTxpool(client),
  mine: (args) => mine(client, args),
  removeBlockTimestampInterval: () => removeBlockTimestampInterval(client),
  reset: (args) => reset(client, args),
  revert: (args) => revert(client, args),
  sendUnsignedTransaction: (args) => sendUnsignedTransaction(client, args),
  setAutomine: (args) => setAutomine(client, args),
  setBalance: (args) => setBalance(client, args),
  setBlockGasLimit: (args) => setBlockGasLimit(client, args),
  setBlockTimestampInterval: (args) => setBlockTimestampInterval(client, args),
  setCode: (args) => setCode(client, args),
  setCoinbase: (args) => setCoinbase(client, args),
  setIntervalMining: (args) => setIntervalMining(client, args),
  setLoggingEnabled: (args) => setLoggingEnabled(client, args),
  setMinGasPrice: (args) => setMinGasPrice(client, args),
  setNextBlockBaseFeePerGas: (args) => setNextBlockBaseFeePerGas(client, args),
  setNextBlockTimestamp: (args) => setNextBlockTimestamp(client, args),
  setNonce: (args) => setNonce(client, args),
  setRpcUrl: (args) => setRpcUrl(client, args),
  setStorageAt: (args) => setStorageAt(client, args),
  snapshot: () => snapshot(client),
  stopImpersonatingAccount: (args) => stopImpersonatingAccount(client, args)
});

// src/clients/decorators/wallet.ts
var walletActions = (client) => ({
  addChain: (args) => addChain(client, args),
  deployContract: (args) => deployContract(client, args),
  getAddresses: () => getAddresses(client),
  getChainId: () => getChainId(client),
  getPermissions: () => getPermissions(client),
  requestAddresses: () => requestAddresses(client),
  requestPermissions: (args) => requestPermissions(client, args),
  sendTransaction: (args) => sendTransaction(client, args),
  signMessage: (args) => signMessage(client, args),
  switchChain: (args) => switchChain(client, args),
  watchAsset: (args) => watchAsset(client, args),
  writeContract: (args) => writeContract(client, args)
});

// src/clients/createPublicClient.ts
function createPublicClient({
  chain,
  key = "public",
  name = "Public Client",
  transport,
  pollingInterval
}) {
  const client = createClient({
    chain,
    key,
    name,
    pollingInterval,
    transport,
    type: "publicClient"
  });
  return {
    ...client,
    ...publicActions(client)
  };
}

// src/clients/createTestClient.ts
function createTestClient({
  chain,
  key = "test",
  name = "Test Client",
  mode,
  pollingInterval,
  transport
}) {
  const client = {
    ...createClient({
      chain,
      key,
      name,
      pollingInterval,
      transport,
      type: "testClient"
    }),
    mode
  };
  return {
    ...client,
    ...testActions(client)
  };
}

// src/clients/createWalletClient.ts
function createWalletClient({
  transport,
  key = "wallet",
  name = "Wallet Client",
  pollingInterval
}) {
  const client = createClient({
    key,
    name,
    pollingInterval,
    transport: () => transport({ retryCount: 0 }),
    type: "walletClient"
  });
  return {
    ...client,
    ...walletActions(client)
  };
}
export {
  AbiConstructorNotFoundError,
  AbiConstructorParamsNotFoundError,
  AbiDecodingDataSizeInvalidError,
  AbiDecodingZeroDataError,
  AbiEncodingArrayLengthMismatchError,
  AbiEncodingLengthMismatchError,
  AbiErrorInputsNotFoundError,
  AbiErrorNotFoundError,
  AbiErrorSignatureNotFoundError,
  AbiEventNotFoundError,
  AbiEventSignatureNotFoundError,
  AbiFunctionNotFoundError,
  AbiFunctionOutputsNotFoundError,
  AbiFunctionSignatureNotFoundError,
  BaseError,
  BlockNotFoundError,
  CallExecutionError,
  ChainDoesNotSupportContract,
  ContractFunctionExecutionError,
  ContractFunctionRevertedError,
  ContractFunctionZeroDataError,
  DataLengthTooLongError,
  DataLengthTooShortError,
  EstimateGasExecutionError,
  ExecutionRevertedError,
  FeeCapTooHighError,
  FeeCapTooLowError,
  FilterTypeNotSupportedError,
  HttpRequestError,
  InsufficientFundsError,
  InternalRpcError,
  IntrinsicGasTooHighError,
  IntrinsicGasTooLowError,
  InvalidAbiDecodingTypeError,
  InvalidAbiEncodingTypeError,
  InvalidAddressError,
  InvalidArrayError,
  InvalidBytesBooleanError,
  InvalidDefinitionTypeError,
  InvalidHexBooleanError,
  InvalidHexValueError,
  InvalidInputRpcError,
  InvalidParamsRpcError,
  InvalidRequestRpcError,
  JsonRpcVersionUnsupportedError,
  LimitExceededRpcError,
  MethodNotFoundRpcError,
  MethodNotSupportedRpcError,
  NonceMaxValueError,
  NonceTooHighError,
  NonceTooLowError,
  OffsetOutOfBoundsError,
  ParseRpcError,
  RawContractError,
  RequestError,
  ResourceNotFoundRpcError,
  ResourceUnavailableRpcError,
  RpcError,
  RpcRequestError,
  SizeExceedsPaddingSizeError,
  SwitchChainError,
  TimeoutError,
  TipAboveFeeCapError,
  TransactionExecutionError,
  TransactionNotFoundError,
  TransactionReceiptNotFoundError,
  TransactionRejectedRpcError,
  TransactionTypeNotSupportedError,
  UnknownNodeError,
  UnknownRpcError,
  UrlRequiredError,
  UserRejectedRequestError,
  WaitForTransactionReceiptTimeoutError,
  WebSocketRequestError,
  boolToBytes,
  boolToHex,
  bytesToBigint,
  bytesToBool,
  bytesToHex,
  bytesToNumber,
  bytesToString,
  createClient,
  createPublicClient,
  createTestClient,
  createTransport,
  createWalletClient,
  custom,
  decodeAbiParameters,
  decodeErrorResult,
  decodeEventLog,
  decodeFunctionData,
  decodeFunctionResult,
  defineBlock,
  defineChain,
  defineTransaction,
  defineTransactionReceipt,
  defineTransactionRequest,
  encodeAbiParameters,
  encodeDeployData,
  encodeErrorResult,
  encodeEventTopics,
  encodeFunctionData,
  encodeFunctionResult,
  encodePacked,
  etherUnits,
  fallback,
  formatBlock,
  formatEther,
  formatGwei,
  formatTransaction,
  formatTransactionRequest,
  formatUnits,
  fromBytes,
  fromHex,
  fromRlp,
  getAbiItem,
  getAccount,
  getAddress,
  getContractAddress,
  getContractError,
  getCreate2Address,
  getCreateAddress,
  getEventSelector,
  getFunctionSelector,
  gweiUnits,
  hexToBigInt,
  hexToBool,
  hexToBytes,
  hexToNumber,
  hexToString,
  http,
  isAddress,
  isAddressEqual,
  isBytes,
  isHex,
  keccak256,
  labelhash,
  multicall3Abi,
  namehash,
  numberToBytes,
  numberToHex,
  pad,
  padBytes,
  padHex,
  parseAbi,
  parseAbiItem,
  parseAbiParameter,
  parseAbiParameters,
  parseEther,
  parseGwei,
  parseUnits,
  size,
  slice,
  sliceBytes,
  sliceHex,
  stringToBytes,
  stringToHex,
  stringify,
  toBytes,
  toHex,
  toRlp,
  transactionType,
  trim,
  webSocket,
  weiUnits
};
//# sourceMappingURL=index.mjs.map