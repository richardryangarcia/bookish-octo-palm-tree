"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }












var _chunkQJNPIGP5js = require('./chunk-QJNPIGP5.js');

// src/utils/ens/labelhash.ts
function labelhash(label) {
  let result = new Uint8Array(32).fill(0);
  if (!label)
    return _chunkQJNPIGP5js.bytesToHex.call(void 0, result);
  return _chunkQJNPIGP5js.keccak256.call(void 0, _chunkQJNPIGP5js.stringToBytes.call(void 0, label));
}

// src/utils/ens/namehash.ts
function namehash(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return _chunkQJNPIGP5js.bytesToHex.call(void 0, result);
  const labels = name.split(".");
  for (let i = labels.length - 1; i >= 0; i -= 1) {
    const hashed = _chunkQJNPIGP5js.keccak256.call(void 0, _chunkQJNPIGP5js.stringToBytes.call(void 0, labels[i]), "bytes");
    result = _chunkQJNPIGP5js.keccak256.call(void 0, _chunkQJNPIGP5js.concat.call(void 0, [result, hashed]), "bytes");
  }
  return _chunkQJNPIGP5js.bytesToHex.call(void 0, result);
}

// src/utils/ens/packetToBytes.ts
function packetToBytes(packet) {
  function length(value2) {
    if (value2 === "." || value2 === "..")
      return 1;
    return _chunkQJNPIGP5js.toBytes.call(void 0, value2.replace(/^\.|\.$/gm, "")).length + 2;
  }
  const bytes = new Uint8Array(length(packet));
  const value = packet.replace(/^\.|\.$/gm, "");
  if (!value.length)
    return bytes;
  let offset = 0;
  const list = value.split(".");
  for (let i = 0; i < list.length; i++) {
    const encoded = _chunkQJNPIGP5js.toBytes.call(void 0, list[i]);
    bytes[offset] = encoded.length;
    bytes.set(encoded, offset + 1);
    offset += encoded.length + 1;
  }
  return bytes;
}

// src/actions/ens/getEnsAddress.ts
async function getEnsAddress(client, {
  blockNumber,
  blockTag,
  name,
  universalResolverAddress: universalResolverAddress_
}) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error(
        "client chain not configured. universalResolverAddress is required."
      );
    const contract = _optionalChain([client, 'access', _ => _.chain, 'optionalAccess', _2 => _2.contracts, 'optionalAccess', _3 => _3.ensUniversalResolver]);
    if (!contract)
      throw new (0, _chunkQJNPIGP5js.ChainDoesNotSupportContract)({
        chain: client.chain,
        contract: { name: "ensUniversalResolver" }
      });
    if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
      throw new (0, _chunkQJNPIGP5js.ChainDoesNotSupportContract)({
        blockNumber,
        chain: client.chain,
        contract: {
          name: "ensUniversalResolver",
          blockCreated: contract.blockCreated
        }
      });
    universalResolverAddress = contract.address;
  }
  const res = await _chunkQJNPIGP5js.readContract.call(void 0, client, {
    address: universalResolverAddress,
    abi: [
      {
        name: "resolve",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "name", type: "bytes" },
          { name: "data", type: "bytes" }
        ],
        outputs: [
          { name: "", type: "bytes" },
          { name: "address", type: "address" }
        ]
      }
    ],
    functionName: "resolve",
    args: [
      _chunkQJNPIGP5js.toHex.call(void 0, packetToBytes(name)),
      _chunkQJNPIGP5js.encodeFunctionData.call(void 0, {
        abi: [
          {
            name: "addr",
            type: "function",
            stateMutability: "view",
            inputs: [{ name: "name", type: "bytes32" }],
            outputs: []
          }
        ],
        functionName: "addr",
        args: [namehash(name)]
      })
    ],
    blockNumber,
    blockTag
  });
  return _chunkQJNPIGP5js.decodeFunctionResult.call(void 0, {
    abi: [
      {
        name: "addr",
        type: "function",
        stateMutability: "view",
        inputs: [],
        outputs: [{ name: "name", type: "address" }]
      }
    ],
    functionName: "addr",
    data: res[0]
  });
}

// src/actions/ens/getEnsName.ts
async function getEnsName(client, {
  address,
  blockNumber,
  blockTag,
  universalResolverAddress: universalResolverAddress_
}) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error(
        "client chain not configured. universalResolverAddress is required."
      );
    const contract = _optionalChain([client, 'access', _4 => _4.chain, 'optionalAccess', _5 => _5.contracts, 'optionalAccess', _6 => _6.ensUniversalResolver]);
    if (!contract)
      throw new (0, _chunkQJNPIGP5js.ChainDoesNotSupportContract)({
        chain: client.chain,
        contract: { name: "ensUniversalResolver" }
      });
    if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
      throw new (0, _chunkQJNPIGP5js.ChainDoesNotSupportContract)({
        blockNumber,
        chain: client.chain,
        contract: {
          name: "ensUniversalResolver",
          blockCreated: contract.blockCreated
        }
      });
    universalResolverAddress = contract.address;
  }
  const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const res = await _chunkQJNPIGP5js.readContract.call(void 0, client, {
      address: universalResolverAddress,
      abi: [
        {
          name: "reverse",
          type: "function",
          stateMutability: "view",
          inputs: [{ type: "bytes", name: "reverseName" }],
          outputs: [
            { type: "string", name: "resolvedName" },
            { type: "address", name: "resolvedAddress" },
            { type: "address", name: "reverseResolver" },
            { type: "address", name: "resolver" }
          ]
        }
      ],
      functionName: "reverse",
      args: [_chunkQJNPIGP5js.toHex.call(void 0, packetToBytes(reverseNode))],
      blockNumber,
      blockTag
    });
    return res[0];
  } catch (error) {
    if (error instanceof _chunkQJNPIGP5js.ContractFunctionExecutionError && error.cause.reason === _chunkQJNPIGP5js.panicReasons[50])
      return null;
    throw error;
  }
}






exports.labelhash = labelhash; exports.namehash = namehash; exports.getEnsAddress = getEnsAddress; exports.getEnsName = getEnsName;
//# sourceMappingURL=chunk-HCZO3OIX.js.map