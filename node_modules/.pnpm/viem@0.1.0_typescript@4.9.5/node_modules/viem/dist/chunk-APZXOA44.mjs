import {
  ChainDoesNotSupportContract,
  ContractFunctionExecutionError,
  bytesToHex,
  concat,
  decodeFunctionResult,
  encodeFunctionData,
  keccak256,
  panicReasons,
  readContract,
  stringToBytes,
  toBytes,
  toHex
} from "./chunk-I7AINPMM.mjs";

// src/utils/ens/labelhash.ts
function labelhash(label) {
  let result = new Uint8Array(32).fill(0);
  if (!label)
    return bytesToHex(result);
  return keccak256(stringToBytes(label));
}

// src/utils/ens/namehash.ts
function namehash(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return bytesToHex(result);
  const labels = name.split(".");
  for (let i = labels.length - 1; i >= 0; i -= 1) {
    const hashed = keccak256(stringToBytes(labels[i]), "bytes");
    result = keccak256(concat([result, hashed]), "bytes");
  }
  return bytesToHex(result);
}

// src/utils/ens/packetToBytes.ts
function packetToBytes(packet) {
  function length(value2) {
    if (value2 === "." || value2 === "..")
      return 1;
    return toBytes(value2.replace(/^\.|\.$/gm, "")).length + 2;
  }
  const bytes = new Uint8Array(length(packet));
  const value = packet.replace(/^\.|\.$/gm, "");
  if (!value.length)
    return bytes;
  let offset = 0;
  const list = value.split(".");
  for (let i = 0; i < list.length; i++) {
    const encoded = toBytes(list[i]);
    bytes[offset] = encoded.length;
    bytes.set(encoded, offset + 1);
    offset += encoded.length + 1;
  }
  return bytes;
}

// src/actions/ens/getEnsAddress.ts
async function getEnsAddress(client, {
  blockNumber,
  blockTag,
  name,
  universalResolverAddress: universalResolverAddress_
}) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error(
        "client chain not configured. universalResolverAddress is required."
      );
    const contract = client.chain?.contracts?.ensUniversalResolver;
    if (!contract)
      throw new ChainDoesNotSupportContract({
        chain: client.chain,
        contract: { name: "ensUniversalResolver" }
      });
    if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
      throw new ChainDoesNotSupportContract({
        blockNumber,
        chain: client.chain,
        contract: {
          name: "ensUniversalResolver",
          blockCreated: contract.blockCreated
        }
      });
    universalResolverAddress = contract.address;
  }
  const res = await readContract(client, {
    address: universalResolverAddress,
    abi: [
      {
        name: "resolve",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "name", type: "bytes" },
          { name: "data", type: "bytes" }
        ],
        outputs: [
          { name: "", type: "bytes" },
          { name: "address", type: "address" }
        ]
      }
    ],
    functionName: "resolve",
    args: [
      toHex(packetToBytes(name)),
      encodeFunctionData({
        abi: [
          {
            name: "addr",
            type: "function",
            stateMutability: "view",
            inputs: [{ name: "name", type: "bytes32" }],
            outputs: []
          }
        ],
        functionName: "addr",
        args: [namehash(name)]
      })
    ],
    blockNumber,
    blockTag
  });
  return decodeFunctionResult({
    abi: [
      {
        name: "addr",
        type: "function",
        stateMutability: "view",
        inputs: [],
        outputs: [{ name: "name", type: "address" }]
      }
    ],
    functionName: "addr",
    data: res[0]
  });
}

// src/actions/ens/getEnsName.ts
async function getEnsName(client, {
  address,
  blockNumber,
  blockTag,
  universalResolverAddress: universalResolverAddress_
}) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error(
        "client chain not configured. universalResolverAddress is required."
      );
    const contract = client.chain?.contracts?.ensUniversalResolver;
    if (!contract)
      throw new ChainDoesNotSupportContract({
        chain: client.chain,
        contract: { name: "ensUniversalResolver" }
      });
    if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
      throw new ChainDoesNotSupportContract({
        blockNumber,
        chain: client.chain,
        contract: {
          name: "ensUniversalResolver",
          blockCreated: contract.blockCreated
        }
      });
    universalResolverAddress = contract.address;
  }
  const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const res = await readContract(client, {
      address: universalResolverAddress,
      abi: [
        {
          name: "reverse",
          type: "function",
          stateMutability: "view",
          inputs: [{ type: "bytes", name: "reverseName" }],
          outputs: [
            { type: "string", name: "resolvedName" },
            { type: "address", name: "resolvedAddress" },
            { type: "address", name: "reverseResolver" },
            { type: "address", name: "resolver" }
          ]
        }
      ],
      functionName: "reverse",
      args: [toHex(packetToBytes(reverseNode))],
      blockNumber,
      blockTag
    });
    return res[0];
  } catch (error) {
    if (error instanceof ContractFunctionExecutionError && error.cause.reason === panicReasons[50])
      return null;
    throw error;
  }
}

export {
  labelhash,
  namehash,
  getEnsAddress,
  getEnsName
};
//# sourceMappingURL=chunk-APZXOA44.mjs.map