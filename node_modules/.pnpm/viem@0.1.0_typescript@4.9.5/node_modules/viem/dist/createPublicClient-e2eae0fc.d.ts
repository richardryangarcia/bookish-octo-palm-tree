import { W as WalletPermission, a as WatchAssetParams, P as PublicRequests } from './eip1193-a882d1b8.js';
import { a as Transport, b as ClientConfig, C as Client } from './createClient-a47ae6f5.js';
import { C as Chain, I as ExtractFormatter, Q as Formatters, S as Formatter, J as Formatted, c as Block, R as RpcBlock, y as Transaction, T as TransactionReceipt, q as RpcTransactionReceipt, V as TransactionType, r as RpcTransactionRequest, t as TransactionRequest, f as BlockTag, H as Hex, W as MergeIntersectionProperties, X as ExtractConstructorArgsFromAbi, a as Hash, Y as GetValue, g as ContractConfig, Z as ExtractResultFromAbi, _ as MaybeAbiEventName, $ as MaybeExtractEventArgsFromAbi, e as BlockNumber, a0 as ExtractEventNameFromAbi, F as FeeHistory, L as Log, K as FormattedTransaction, M as TransactionFormatter, a1 as ExtractEventArgsFromAbi, a2 as Prettify } from './chain-819c7ff7.js';
import { Abi, Narrow, Address, AbiEvent, ExtractAbiEvent } from 'abitype';

type BlockFormatter<TChain extends Chain = Chain> = ExtractFormatter<TChain, 'block', NonNullable<Formatters['block']>>;
type FormattedBlock<TFormatter extends Formatter | undefined = Formatter> = Formatted<TFormatter, Block>;
declare function formatBlock(block: Partial<RpcBlock>): Block<bigint, Transaction<bigint, number>>;
declare const defineBlock: <TFormat extends Formatter<Partial<RpcBlock>, Partial<Block<bigint, Transaction<bigint, number>>> & {
    [key: string]: unknown;
}>, TExclude extends (keyof RpcBlock)[] = []>({ exclude, format: formatOverride, }: {
    exclude?: TExclude | undefined;
    format?: TFormat | undefined;
}) => (data: Partial<RpcBlock> & {
    [key: string]: unknown;
}) => Block<bigint, Transaction<bigint, number>> & ReturnType<TFormat> & { [K in TExclude[number]]: never; };

type TransactionReceiptFormatter<TChain extends Chain = Chain> = ExtractFormatter<TChain, 'transactionReceipt', NonNullable<Formatters['transactionReceipt']>>;
type FormattedTransactionReceipt<TFormatter extends Formatter | undefined = Formatter> = Formatted<TFormatter, TransactionReceipt>;
declare const defineTransactionReceipt: <TFormat extends Formatter<Partial<RpcTransactionReceipt>, Partial<TransactionReceipt<bigint, number, "success" | "reverted", TransactionType>> & {
    [key: string]: unknown;
}>, TExclude extends (keyof RpcTransactionReceipt)[] = []>({ exclude, format: formatOverride, }: {
    exclude?: TExclude | undefined;
    format?: TFormat | undefined;
}) => (data: Partial<RpcTransactionReceipt> & {
    [key: string]: unknown;
}) => TransactionReceipt<bigint, number, "success" | "reverted", TransactionType> & ReturnType<TFormat> & { [K in TExclude[number]]: never; };

type TransactionRequestFormatter<TChain extends Chain = Chain> = ExtractFormatter<TChain, 'transactionRequest', NonNullable<Formatters['transactionRequest']>>;
type FormattedTransactionRequest$1<TFormatter extends Formatter | undefined = Formatter> = Formatted<TFormatter, RpcTransactionRequest>;
declare function formatTransactionRequest(transactionRequest: Partial<TransactionRequest>): RpcTransactionRequest;
declare const defineTransactionRequest: <TFormat extends Formatter<Partial<TransactionRequest<bigint, number>>, Partial<RpcTransactionRequest> & {
    [key: string]: unknown;
}>, TExclude extends ("value" | "from" | "gasPrice" | "maxFeePerGas" | "maxPriorityFeePerGas" | "data" | "gas" | "nonce" | "to" | "accessList")[] = []>({ exclude, format: formatOverride, }: {
    exclude?: TExclude | undefined;
    format?: TFormat | undefined;
}) => (data: Partial<TransactionRequest<bigint, number>> & {
    [key: string]: unknown;
}) => RpcTransactionRequest & ReturnType<TFormat> & { [K in TExclude[number]]: never; };

type FormattedCall<TFormatter extends Formatter | undefined = Formatter> = MergeIntersectionProperties<Omit<Formatted<TFormatter, TransactionRequest, true>, 'from'>, TransactionRequest>;
type CallParameters<TChain extends Chain = Chain> = FormattedCall<TransactionRequestFormatter<TChain>> & {
    account?: Account;
} & ({
    /** The balance of the account at a block number. */
    blockNumber?: bigint;
    blockTag?: never;
} | {
    blockNumber?: never;
    /** The balance of the account at a block tag. */
    blockTag?: BlockTag;
});
type CallReturnType = {
    data: Hex | undefined;
};
declare function call<TChain extends Chain>(client: PublicClient<any, TChain>, args: CallParameters<TChain>): Promise<CallReturnType>;

type AddChainParameters = {
    chain: Chain;
};
declare function addChain(client: WalletClient, { chain }: AddChainParameters): Promise<void>;

type DeployContractParameters<TChain extends Chain = Chain, TAbi extends Abi | readonly unknown[] = Abi> = Omit<SendTransactionParameters<TChain>, 'accessList' | 'to' | 'data' | 'value'> & {
    abi: Narrow<TAbi>;
    bytecode: Hex;
} & ExtractConstructorArgsFromAbi<TAbi>;
type DeployContractReturnType = SendTransactionReturnType;
declare function deployContract<TChain extends Chain, TAbi extends Abi | readonly unknown[]>(walletClient: WalletClient, { abi, args, bytecode, ...request }: DeployContractParameters<TChain, TAbi>): Promise<DeployContractReturnType>;

type GetAddressesReturnType = Address[];
declare function getAddresses(client: WalletClient): Promise<GetAddressesReturnType>;

type GetChainIdReturnType = number;
declare function getChainId(client: PublicClient | WalletClient): Promise<GetChainIdReturnType>;

type GetPermissionsReturnType = WalletPermission[];
declare function getPermissions(client: WalletClient): Promise<WalletPermission[]>;

type RequestAddressesReturnType = Address[];
declare function requestAddresses(client: WalletClient): Promise<RequestAddressesReturnType>;

type RequestPermissionsParameters = {
    eth_accounts: Record<string, any>;
} & {
    [key: string]: Record<string, any>;
};
type RequestPermissionsReturnType = WalletPermission[];
declare function requestPermissions(client: WalletClient, permissions: RequestPermissionsParameters): Promise<WalletPermission[]>;

type FormattedTransactionRequest<TFormatter extends Formatter | undefined = Formatter> = MergeIntersectionProperties<Omit<Formatted<TFormatter, TransactionRequest, true>, 'from'>, TransactionRequest>;
type SendTransactionParameters<TChain extends Chain = Chain> = FormattedTransactionRequest<TransactionRequestFormatter<TChain>> & {
    account: Account;
} & ({
    assertChain?: false;
    chain?: TChain;
} | {
    assertChain: true;
    chain: TChain;
});
type SendTransactionReturnType = Hash;
declare function sendTransaction<TChain extends Chain>(client: WalletClient, args: SendTransactionParameters<TChain>): Promise<SendTransactionReturnType>;

type SignMessageParameters = {
    account: Account;
    data: string;
};
type SignMessageReturnType = Hex;
declare function signMessage(client: WalletClient, { account, data }: SignMessageParameters): Promise<SignMessageReturnType>;

type SwitchChainParameters = {
    id: Chain['id'];
};
declare function switchChain(client: WalletClient, { id }: SwitchChainParameters): Promise<void>;

type WatchAssetParameters = WatchAssetParams;
type WatchAssetReturnType = boolean;
declare function watchAsset(client: WalletClient, params: WatchAssetParameters): Promise<WatchAssetReturnType>;

type WriteContractParameters<TChain extends Chain = Chain, TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string> = Omit<SendTransactionParameters<TChain>, 'to' | 'data' | 'value'> & {
    value?: GetValue<TAbi, TFunctionName, SendTransactionParameters<TChain>['value']>;
} & ContractConfig<TAbi, TFunctionName, 'payable' | 'nonpayable'>;
type WriteContractReturnType = SendTransactionReturnType;
declare function writeContract<TChain extends Chain, TAbi extends Abi | readonly unknown[], TFunctionName extends string>(client: WalletClient, { abi, address, args, functionName, ...request }: WriteContractParameters<TChain, TAbi, TFunctionName>): Promise<WriteContractReturnType>;

type SimulateContractParameters<TChain extends Chain = Chain, TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = any, TChainOverride extends Chain | undefined = undefined> = Omit<CallParameters<TChainOverride extends Chain ? TChainOverride : TChain>, 'to' | 'data' | 'value'> & {
    chain?: TChainOverride;
} & ContractConfig<TAbi, TFunctionName, 'payable' | 'nonpayable'> & {
    value?: GetValue<TAbi, TFunctionName, CallParameters<TChain>['value']>;
};
type SimulateContractReturnType<TChain extends Chain = Chain, TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string> = {
    result: ExtractResultFromAbi<TAbi, TFunctionName>;
    request: WriteContractParameters<TChain, TAbi, TFunctionName> & ContractConfig<TAbi, TFunctionName, 'payable' | 'nonpayable'>;
};
declare function simulateContract<TChain extends Chain, TAbi extends Abi | readonly unknown[], TFunctionName extends string, TChainOverride extends Chain | undefined>(client: PublicClient<any, TChain>, { abi, address, args, functionName, ...callRequest }: SimulateContractParameters<TChain, TAbi, TFunctionName, TChainOverride>): Promise<SimulateContractReturnType<TChainOverride extends Chain ? TChainOverride : TChain, TAbi, TFunctionName>>;

type CreatePendingTransactionFilterReturnType = Filter<'transaction'>;
declare function createPendingTransactionFilter(client: PublicClient): Promise<CreatePendingTransactionFilterReturnType>;

type CreateBlockFilterReturnType = Filter<'block'>;
declare function createBlockFilter(client: PublicClient): Promise<CreateBlockFilterReturnType>;

type CreateEventFilterParameters<TAbiEvent extends AbiEvent | undefined = undefined, TAbi extends Abi | readonly unknown[] = [TAbiEvent], TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined = undefined> = {
    address?: Address | Address[];
    fromBlock?: BlockNumber | BlockTag;
    toBlock?: BlockNumber | BlockTag;
} & (MaybeExtractEventArgsFromAbi<TAbi, TEventName> extends infer TEventFilterArgs ? {
    args: TEventFilterArgs | (TArgs extends TEventFilterArgs ? TArgs : never);
    event: TAbiEvent;
} | {
    args?: never;
    event?: TAbiEvent;
} | {
    args?: never;
    event?: never;
} : {
    args?: never;
    event?: never;
});
type CreateEventFilterReturnType<TAbiEvent extends AbiEvent | undefined = undefined, TAbi extends Abi | readonly unknown[] = [TAbiEvent], TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined = undefined> = Filter<'event', TAbi, TEventName, TArgs>;
declare function createEventFilter<TAbiEvent extends AbiEvent | undefined, TAbi extends Abi | readonly unknown[] = [TAbiEvent], TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined = undefined>(client: PublicClient, { address, args, event, fromBlock, toBlock, }?: CreateEventFilterParameters<TAbiEvent, TAbi, TEventName, TArgs>): Promise<CreateEventFilterReturnType<TAbiEvent, TAbi, TEventName, TArgs>>;

type CreateContractEventFilterParameters<TAbi extends Abi | readonly unknown[] = Abi, TEventName extends string | undefined = undefined, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined = undefined> = {
    address?: Address | Address[];
    abi: Narrow<TAbi>;
    eventName?: ExtractEventNameFromAbi<TAbi, TEventName>;
    fromBlock?: BlockNumber | BlockTag;
    toBlock?: BlockNumber | BlockTag;
} & (undefined extends TEventName ? {
    args?: never;
} : MaybeExtractEventArgsFromAbi<TAbi, TEventName> extends infer TEventFilterArgs ? {
    args?: TEventFilterArgs | (TArgs extends TEventFilterArgs ? TArgs : never);
} : {
    args?: never;
});
type CreateContractEventFilterReturnType<TAbi extends Abi | readonly unknown[] = Abi, TEventName extends string | undefined = undefined, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined = undefined> = Filter<'event', TAbi, TEventName, TArgs>;
declare function createContractEventFilter<TAbi extends Abi | readonly unknown[], TEventName extends string | undefined, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined>(client: PublicClient, { address, abi, args, eventName, fromBlock, toBlock, }: CreateContractEventFilterParameters<TAbi, TEventName, TArgs>): Promise<CreateContractEventFilterReturnType<TAbi, TEventName, TArgs>>;

type FormattedEstimateGas<TFormatter extends Formatter | undefined = Formatter> = MergeIntersectionProperties<Omit<Formatted<TFormatter, TransactionRequest, true>, 'from'>, TransactionRequest>;
type EstimateGasParameters<TChain extends Chain = Chain> = FormattedEstimateGas<TransactionRequestFormatter<TChain>> & {
    account: Account;
} & ({
    /** The balance of the account at a block number. */
    blockNumber?: bigint;
    blockTag?: never;
} | {
    blockNumber?: never;
    /** The balance of the account at a block tag. */
    blockTag?: BlockTag;
});
type EstimateGasReturnType = bigint;
/**
 * @description Estimates the gas necessary to complete a transaction without submitting it to the network.
 */
declare function estimateGas<TChain extends Chain>(client: PublicClient<any, TChain> | WalletClient, args: EstimateGasParameters<TChain>): Promise<EstimateGasReturnType>;

type EstimateContractGasParameters<TChain extends Chain = Chain, TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = any> = Omit<EstimateGasParameters<TChain>, 'data' | 'to' | 'value'> & ContractConfig<TAbi, TFunctionName, 'payable' | 'nonpayable'> & {
    value?: GetValue<TAbi, TFunctionName, EstimateGasParameters<TChain>['value']>;
};
type EstimateContractGasReturnType = bigint;
declare function estimateContractGas<TChain extends Chain, TAbi extends Abi | readonly unknown[], TFunctionName extends string>(client: PublicClient<any, TChain>, { abi, address, args, functionName, ...request }: EstimateContractGasParameters<TChain, TAbi, TFunctionName>): Promise<EstimateContractGasReturnType>;

type GetBalanceParameters = {
    /** The address of the account. */
    address: Address;
} & ({
    /** The balance of the account at a block number. */
    blockNumber?: bigint;
    blockTag?: never;
} | {
    blockNumber?: never;
    /** The balance of the account at a block tag. */
    blockTag?: BlockTag;
});
type GetBalanceReturnType = bigint;
/**
 * @description Returns the balance of an address in wei.
 */
declare function getBalance(client: PublicClient, { address, blockNumber, blockTag }: GetBalanceParameters): Promise<GetBalanceReturnType>;

type GetBlockParameters = {
    /** Whether or not to include transaction data in the response. */
    includeTransactions?: boolean;
} & ({
    /** Hash of the block. */
    blockHash?: Hash;
    blockNumber?: never;
    blockTag?: never;
} | {
    blockHash?: never;
    /** The block number. */
    blockNumber?: bigint;
    blockTag?: never;
} | {
    blockHash?: never;
    blockNumber?: never;
    /** The block tag. Defaults to 'latest'. */
    blockTag?: BlockTag;
});
type GetBlockReturnType<TChain extends Chain = Chain> = FormattedBlock<BlockFormatter<TChain>>;
declare function getBlock<TChain extends Chain>(client: PublicClient<any, TChain> | WalletClient, { blockHash, blockNumber, blockTag, includeTransactions, }?: GetBlockParameters): Promise<GetBlockReturnType<TChain>>;

type GetBlockNumberParameters = {
    /** The maximum age (in ms) of the cached value. */
    maxAge?: number;
};
type GetBlockNumberReturnType = bigint;
declare function getBlockNumberCache(id: string): {
    clear: () => void;
    promise: {
        clear: () => boolean;
        get: () => Promise<unknown> | undefined;
        set: (data: Promise<unknown>) => Map<string, Promise<unknown>>;
    };
    response: {
        clear: () => boolean;
        get: () => {
            created: Date;
            data: unknown;
        } | undefined;
        set: (data: {
            created: Date;
            data: unknown;
        }) => Map<string, {
            created: Date;
            data: unknown;
        }>;
    };
};
/**
 * @description Returns the number of the most recent block seen.
 */
declare function getBlockNumber(client: PublicClient<any, any, any>, { maxAge }?: GetBlockNumberParameters): Promise<GetBlockNumberReturnType>;

type GetBlockTransactionCountParameters = {
    /** Hash of the block. */
    blockHash?: Hash;
    blockNumber?: never;
    blockTag?: never;
} | {
    blockHash?: never;
    /** The block number. */
    blockNumber?: bigint;
    blockTag?: never;
} | {
    blockHash?: never;
    blockNumber?: never;
    /** The block tag. Defaults to 'latest'. */
    blockTag?: BlockTag;
};
type GetBlockTransactionCountReturnType = number;
declare function getBlockTransactionCount<TChain extends Chain>(client: PublicClient<any, TChain>, { blockHash, blockNumber, blockTag, }?: GetBlockTransactionCountParameters): Promise<GetBlockTransactionCountReturnType>;

type GetBytecodeParameters = {
    address: Address;
} & ({
    blockNumber?: never;
    blockTag?: BlockTag;
} | {
    blockNumber?: bigint;
    blockTag?: never;
});
type GetBytecodeReturnType = Hex | undefined;
declare function getBytecode(client: PublicClient, { address, blockNumber, blockTag }: GetBytecodeParameters): Promise<GetBytecodeReturnType>;

type GetFeeHistoryParameters = {
    blockCount: number;
    rewardPercentiles: number[];
} & ({
    blockNumber?: never;
    blockTag?: BlockTag;
} | {
    blockNumber?: bigint;
    blockTag?: never;
});
type GetFeeHistoryReturnType = FeeHistory;
/**
 * @description Returns a collection of historical gas information.
 */
declare function getFeeHistory(client: PublicClient, { blockCount, blockNumber, blockTag, rewardPercentiles, }: GetFeeHistoryParameters): Promise<GetFeeHistoryReturnType>;

type GetFilterChangesParameters<TFilterType extends FilterType = FilterType, TAbiEvent extends AbiEvent | undefined = undefined, TAbi extends Abi | readonly unknown[] = [TAbiEvent], TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = {
    filter: Filter<TFilterType, TAbi, TEventName, any>;
};
type GetFilterChangesReturnType<TFilterType extends FilterType = FilterType, TAbiEvent extends AbiEvent | undefined = undefined, TAbi extends Abi | readonly unknown[] = [TAbiEvent], TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = TFilterType extends 'event' ? Log<bigint, number, TAbiEvent, TAbi, TEventName>[] : Hash[];
declare function getFilterChanges<TFilterType extends FilterType, TAbiEvent extends AbiEvent | undefined, TAbi extends Abi | readonly unknown[], TEventName extends string | undefined>(client: PublicClient, { filter, }: GetFilterChangesParameters<TFilterType, TAbiEvent, TAbi, TEventName>): Promise<GetFilterChangesReturnType<TFilterType, TAbiEvent, TAbi, TEventName>>;

type GetFilterLogsParameters<TAbiEvent extends AbiEvent | undefined = undefined, TAbi extends Abi | readonly unknown[] = [TAbiEvent], TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = {
    filter: Filter<'event', TAbi, TEventName, any>;
};
type GetFilterLogsReturnType<TAbiEvent extends AbiEvent | undefined = undefined, TAbi extends Abi | readonly unknown[] = [TAbiEvent], TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = Log<bigint, number, TAbiEvent, TAbi, TEventName>[];
declare function getFilterLogs<TAbiEvent extends AbiEvent | undefined, TAbi extends Abi | readonly unknown[], TEventName extends string | undefined>(client: PublicClient, { filter }: GetFilterLogsParameters<TAbiEvent, TAbi, TEventName>): Promise<GetFilterLogsReturnType<TAbiEvent, TAbi, TEventName>>;

type GetGasPriceReturnType = bigint;
/**
 * @description Returns the current price of gas (in wei).
 */
declare function getGasPrice(client: PublicClient | WalletClient): Promise<GetGasPriceReturnType>;

type GetLogsParameters<TAbiEvent extends AbiEvent | undefined = undefined, TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = {
    /** Address or list of addresses from which logs originated */
    address?: Address | Address[];
} & ({
    event: TAbiEvent;
    args?: MaybeExtractEventArgsFromAbi<[TAbiEvent], TEventName>;
} | {
    event?: never;
    args?: never;
}) & ({
    /** Block number or tag after which to include logs */
    fromBlock?: BlockNumber<bigint> | BlockTag;
    /** Block number or tag before which to include logs */
    toBlock?: BlockNumber<bigint> | BlockTag;
    blockHash?: never;
} | {
    fromBlock?: never;
    toBlock?: never;
    /** Hash of block to include logs from */
    blockHash?: Hash;
});
type GetLogsReturnType<TAbiEvent extends AbiEvent | undefined = undefined, TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = Log<bigint, number, TAbiEvent, [TAbiEvent], TEventName>[];
/**
 * @description Returns a collection of event logs.
 */
declare function getLogs<TAbiEvent extends AbiEvent | undefined>(client: PublicClient, { address, blockHash, fromBlock, toBlock, event, args, }?: GetLogsParameters<TAbiEvent>): Promise<GetLogsReturnType<TAbiEvent>>;

type GetStorageAtParameters = {
    address: Address;
    slot: Hex;
} & ({
    blockNumber?: never;
    blockTag?: BlockTag;
} | {
    blockNumber?: bigint;
    blockTag?: never;
});
type GetStorageAtReturnType = Hex | undefined;
declare function getStorageAt(client: PublicClient, { address, blockNumber, blockTag, slot }: GetStorageAtParameters): Promise<GetStorageAtReturnType>;

type GetTransactionParameters = {
    /** The block hash */
    blockHash: Hash;
    blockNumber?: never;
    blockTag?: never;
    hash?: never;
    /** The index of the transaction on the block. */
    index: number;
} | {
    blockHash?: never;
    /** The block number */
    blockNumber: bigint;
    blockTag?: never;
    hash?: never;
    /** The index of the transaction on the block. */
    index: number;
} | {
    blockHash?: never;
    blockNumber?: never;
    /** The block tag. */
    blockTag: BlockTag;
    hash?: never;
    /** The index of the transaction on the block. */
    index: number;
} | {
    blockHash?: never;
    blockNumber?: never;
    blockTag?: never;
    /** The hash of the transaction. */
    hash: Hash;
    index?: number;
};
type GetTransactionReturnType<TChain extends Chain = Chain> = FormattedTransaction<TransactionFormatter<TChain>>;
/** @description Returns information about a transaction given a hash or block identifier. */
declare function getTransaction<TChain extends Chain>(client: PublicClient<any, TChain>, { blockHash, blockNumber, blockTag, hash, index, }: GetTransactionParameters): Promise<GetTransactionReturnType<TChain>>;

type GetTransactionConfirmationsParameters<TChain extends Chain = Chain> = {
    /** The transaction hash. */
    hash: Hash;
    transactionReceipt?: never;
} | {
    hash?: never;
    /** The transaction receipt. */
    transactionReceipt: FormattedTransactionReceipt<TransactionReceiptFormatter<TChain>>;
};
type GetTransactionConfirmationsReturnType = bigint;
declare function getTransactionConfirmations<TChain extends Chain>(client: PublicClient<any, TChain>, { hash, transactionReceipt }: GetTransactionConfirmationsParameters<TChain>): Promise<GetTransactionConfirmationsReturnType>;

type GetTransactionReceiptParameters = {
    /** The hash of the transaction. */
    hash: Hash;
};
type GetTransactionReceiptReturnType<TChain extends Chain = Chain> = FormattedTransactionReceipt<TransactionReceiptFormatter<TChain>>;
declare function getTransactionReceipt<TChain extends Chain>(client: PublicClient<any, TChain>, { hash }: GetTransactionReceiptParameters): Promise<Formatted<ExtractFormatter<TChain, "transactionReceipt", Formatter<RpcTransactionReceipt, TransactionReceipt<bigint, number, "success" | "reverted", TransactionType>>>, TransactionReceipt<bigint, number, "success" | "reverted", TransactionType>, false, false>>;

type MAXIMUM_DEPTH = 20;
type Contract<TAbi extends Abi | readonly unknown[] = Abi | readonly unknown[], TFunctionName extends string = string> = {
    abi: TAbi;
    functionName: TFunctionName;
};
type MulticallContracts<TContracts extends Contract[], TProperties extends Record<string, any> = object, Result extends any[] = [], Depth extends ReadonlyArray<number> = []> = Depth['length'] extends MAXIMUM_DEPTH ? (ContractConfig & TProperties)[] : TContracts extends [] ? [] : TContracts extends [infer Head extends Contract] ? [
    ...Result,
    ContractConfig<Head['abi'], Head['functionName']> & TProperties
] : TContracts extends [
    infer Head extends Contract,
    ...infer Tail extends Contract[]
] ? MulticallContracts<[
    ...Tail
], TProperties, [
    ...Result,
    ContractConfig<Head['abi'], Head['functionName']> & TProperties
], [
    ...Depth,
    1
]> : unknown[] extends TContracts ? TContracts : TContracts extends ContractConfig<infer TAbi, infer TFunctionName>[] ? (ContractConfig<TAbi, TFunctionName> & TProperties)[] : (ContractConfig & TProperties)[];
type MulticallResult<Result, TAllowFailure extends boolean = true> = TAllowFailure extends true ? ({
    error?: undefined;
    result: Result;
    status: 'success';
} | {
    error: Error;
    result?: undefined;
    status: 'error';
}) : Result;
type MulticallResults<TContracts extends Contract[], TAllowFailure extends boolean = true, Result extends any[] = [], Depth extends ReadonlyArray<number> = []> = Depth['length'] extends MAXIMUM_DEPTH ? MulticallResult<ExtractResultFromAbi, TAllowFailure>[] : TContracts extends [] ? [] : TContracts extends [infer Head extends Contract] ? [...Result, MulticallResult<ExtractResultFromAbi<Head['abi'], Head['functionName']>, TAllowFailure>] : TContracts extends [
    infer Head extends Contract,
    ...infer Tail extends Contract[]
] ? MulticallResults<[
    ...Tail
], TAllowFailure, [
    ...Result,
    MulticallResult<ExtractResultFromAbi<Head['abi'], Head['functionName']>, TAllowFailure>
], [
    ...Depth,
    1
]> : TContracts extends ContractConfig<infer TAbi, infer TFunctionName>[] ? MulticallResult<ExtractResultFromAbi<TAbi, TFunctionName>, TAllowFailure>[] : MulticallResult<ExtractResultFromAbi, TAllowFailure>[];

type MulticallParameters<TContracts extends ContractConfig[] = ContractConfig[], TAllowFailure extends boolean = true> = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {
    allowFailure?: TAllowFailure;
    contracts: readonly [...MulticallContracts<TContracts>];
    multicallAddress: Address;
};
type MulticallReturnType<TContracts extends ContractConfig[] = ContractConfig[], TAllowFailure extends boolean = true> = MulticallResults<TContracts, TAllowFailure>;
declare function multicall<TContracts extends ContractConfig[], TAllowFailure extends boolean = true>(client: PublicClient, args: MulticallParameters<TContracts, TAllowFailure>): Promise<MulticallReturnType<TContracts, TAllowFailure>>;

type ReadContractParameters<TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string> = Pick<CallParameters, 'blockNumber' | 'blockTag'> & ContractConfig<TAbi, TFunctionName, 'view' | 'pure'>;
type ReadContractReturnType<TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string> = ExtractResultFromAbi<TAbi, TFunctionName>;
declare function readContract<TAbi extends Abi | readonly unknown[], TFunctionName extends string>(client: PublicClient, { abi, address, args, functionName, ...callRequest }: ReadContractParameters<TAbi, TFunctionName>): Promise<ReadContractReturnType<TAbi, TFunctionName>>;

type UninstallFilterParameters = {
    filter: Filter<any>;
};
type UninstallFilterReturnType = boolean;
declare function uninstallFilter(client: PublicClient, { filter }: UninstallFilterParameters): Promise<UninstallFilterReturnType>;

type ReplacementReason = 'cancelled' | 'replaced' | 'repriced';
type ReplacementReturnType<TChain extends Chain = Chain> = {
    reason: ReplacementReason;
    replacedTransaction: Transaction;
    transaction: Transaction;
    transactionReceipt: GetTransactionReceiptReturnType<TChain>;
};
type WaitForTransactionReceiptReturnType<TChain extends Chain = Chain> = GetTransactionReceiptReturnType<TChain>;
type WaitForTransactionReceiptParameters<TChain extends Chain = Chain> = {
    /** The number of confirmations (blocks that have passed) to wait before resolving. */
    confirmations?: number;
    /** The hash of the transaction. */
    hash: Hash;
    onReplaced?: (response: ReplacementReturnType<TChain>) => void;
    /** Polling frequency (in ms). Defaults to the client's pollingInterval config. */
    pollingInterval?: number;
    /** Optional timeout (in milliseconds) to wait before stopping polling. */
    timeout?: number;
};
declare function waitForTransactionReceipt<TChain extends Chain>(client: PublicClient<any, TChain>, { confirmations, hash, onReplaced, pollingInterval, timeout, }: WaitForTransactionReceiptParameters<TChain>): Promise<WaitForTransactionReceiptReturnType<TChain>>;

type OnBlockNumberParameter = GetBlockNumberReturnType;
type OnBlockNumberFn = (blockNumber: OnBlockNumberParameter, prevBlockNumber: OnBlockNumberParameter | undefined) => void;
type WatchBlockNumberParameters = {
    /** Whether or not to emit the missed block numbers to the callback. */
    emitMissed?: boolean;
    /** Whether or not to emit the latest block number to the callback when the subscription opens. */
    emitOnBegin?: boolean;
    /** The callback to call when a new block number is received. */
    onBlockNumber: OnBlockNumberFn;
    /** The callback to call when an error occurred when trying to get for a new block. */
    onError?: (error: Error) => void;
    /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */
    pollingInterval?: number;
};
/** @description Watches and returns incoming block numbers. */
declare function watchBlockNumber(client: PublicClient<any, any, any>, { emitOnBegin, emitMissed, onBlockNumber, onError, pollingInterval, }: WatchBlockNumberParameters): () => void;

type OnBlockParameter<TChain extends Chain = Chain, TIncludeTransactions = false> = Omit<GetBlockReturnType<TChain>, TIncludeTransactions extends false ? 'transactions' : ''>;
type OnBlock<TChain extends Chain = Chain, TIncludeTransactions = false> = (block: OnBlockParameter<TChain, TIncludeTransactions>, prevBlock: OnBlockParameter<TChain, TIncludeTransactions> | undefined) => void;
type WatchBlocksParameters<TChain extends Chain = Chain> = {
    /** The block tag. Defaults to "latest". */
    blockTag?: BlockTag;
    /** Whether or not to emit the missed blocks to the callback. */
    emitMissed?: boolean;
    /** Whether or not to emit the block to the callback when the subscription opens. */
    emitOnBegin?: boolean;
    /** The callback to call when an error occurred when trying to get for a new block. */
    onError?: (error: Error) => void;
    /** Polling frequency (in ms). Defaults to the client's pollingInterval config. */
    pollingInterval?: number;
} & ({
    /** Whether or not to include transaction data in the response. */
    includeTransactions: true;
    /** The callback to call when a new block is received. */
    onBlock: OnBlock<TChain, true>;
} | {
    /** Whether or not to include transaction data in the response. */
    includeTransactions?: false;
    /** The callback to call when a new block is received. */
    onBlock: OnBlock<TChain>;
});
/** @description Watches and returns information for incoming blocks. */
declare function watchBlocks<TChain extends Chain, TWatchBlocksParameters extends WatchBlocksParameters<TChain>>(client: PublicClient<any, TChain>, { blockTag, emitMissed, emitOnBegin, onBlock, onError, includeTransactions, pollingInterval, }: TWatchBlocksParameters): () => void;

type OnLogsParameter$1<TAbi extends Abi | readonly unknown[] = readonly unknown[], TEventName extends string = string> = TAbi extends Abi ? Log<bigint, number, ExtractAbiEvent<TAbi, TEventName>>[] : Log[];
type OnLogsFn$1<TAbi extends Abi | readonly unknown[] = readonly unknown[], TEventName extends string = string> = (logs: OnLogsParameter$1<TAbi, TEventName>) => void;
type WatchContractEventParameters<TAbi extends Abi | readonly unknown[] = readonly unknown[], TEventName extends string = string> = {
    /** The address of the contract. */
    address?: Address | Address[];
    /** Contract ABI. */
    abi: Narrow<TAbi>;
    args?: ExtractEventArgsFromAbi<TAbi, TEventName>;
    /** Whether or not the event logs should be batched on each invocation. */
    batch?: boolean;
    /** Contract event. */
    eventName?: ExtractEventNameFromAbi<TAbi, TEventName>;
    /** The callback to call when an error occurred when trying to get for a new block. */
    onError?: (error: Error) => void;
    /** The callback to call when new event logs are received. */
    onLogs: OnLogsFn$1<TAbi, TEventName>;
    /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */
    pollingInterval?: number;
};
declare function watchContractEvent<TAbi extends Abi | readonly unknown[], TEventName extends string>(client: PublicClient, { abi, address, args, batch, eventName, onError, onLogs, pollingInterval, }: WatchContractEventParameters<TAbi, TEventName>): () => void;

type OnLogsParameter<TAbiEvent extends AbiEvent | undefined = undefined, TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = Log<bigint, number, TAbiEvent, [TAbiEvent], TEventName>[];
type OnLogsFn<TAbiEvent extends AbiEvent | undefined = undefined, TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = (logs: OnLogsParameter<TAbiEvent, TEventName>) => void;
type WatchEventParameters<TAbiEvent extends AbiEvent | undefined = undefined, TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = {
    /** The address of the contract. */
    address?: Address | Address[];
    /** Whether or not the event logs should be batched on each invocation. */
    batch?: boolean;
    /** The callback to call when an error occurred when trying to get for a new block. */
    onError?: (error: Error) => void;
    /** The callback to call when new event logs are received. */
    onLogs: OnLogsFn<TAbiEvent, TEventName>;
    /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */
    pollingInterval?: number;
} & ({
    event: TAbiEvent;
    args?: MaybeExtractEventArgsFromAbi<[TAbiEvent], TEventName>;
} | {
    event?: never;
    args?: never;
});
declare function watchEvent<TAbiEvent extends AbiEvent | undefined, TEventName extends string | undefined>(client: PublicClient, { address, args, batch, event, onError, onLogs, pollingInterval, }: WatchEventParameters<TAbiEvent>): () => void;

type OnTransactionsParameter = Hash[];
type OnTransactionsFn = (transactions: OnTransactionsParameter) => void;
type WatchPendingTransactionsParameters = {
    /** Whether or not the transaction hashes should be batched on each invocation. */
    batch?: boolean;
    /** The callback to call when an error occurred when trying to get for a new block. */
    onError?: (error: Error) => void;
    /** The callback to call when new transactions are received. */
    onTransactions: OnTransactionsFn;
    /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */
    pollingInterval?: number;
};
declare function watchPendingTransactions(client: PublicClient, { batch, onError, onTransactions, pollingInterval, }: WatchPendingTransactionsParameters): () => void;

type Account = JsonRpcAccount | LocalAccount;
type JsonRpcAccount = {
    address: Address;
    type: 'json-rpc';
};
type LocalAccount = {
    address: Address;
    signMessage: (message: string) => Promise<Hash>;
    signTransaction: (transaction: Omit<TransactionRequest, 'from'> & {
        chainId: number;
        from: Address;
    }) => Promise<Hash>;
    type: 'local';
};

type FilterType = 'transaction' | 'block' | 'event';
type Filter<TFilterType extends FilterType = 'event', TAbi extends Abi | readonly unknown[] = Abi, TEventName extends string | undefined = undefined, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined = MaybeExtractEventArgsFromAbi<TAbi, TEventName>> = {
    id: Hex;
    type: TFilterType;
} & (TFilterType extends 'event' ? TAbi extends Abi ? undefined extends TEventName ? {
    abi: TAbi;
    args?: never;
    eventName?: never;
} : TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> ? {
    abi: TAbi;
    args: TArgs;
    eventName: TEventName;
} : {
    abi: TAbi;
    args?: never;
    eventName: TEventName;
} : {
    abi?: never;
    args?: never;
    eventName?: never;
} : {});

type GetEnsAddressParameters = Prettify<Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {
    /** ENS name to get address. */
    name: string;
    /** Address of ENS Universal Resolver Contract */
    universalResolverAddress?: Address;
}>;
type GetEnsAddressReturnType = Address;
/**
 * @description Gets address for ENS name.
 *
 * - Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.
 * - Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.
 *
 * @example
 * import { normalize } from 'viem/ens'
 *
 * const ensAddress = await getEnsAddress(publicClient, {
 *   name: normalize('wagmi-dev.eth'),
 * })
 * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'
 */
declare function getEnsAddress(client: PublicClient, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_, }: GetEnsAddressParameters): Promise<GetEnsAddressReturnType>;

type GetEnsNameParameters = Prettify<Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {
    /** Address to get ENS name for. */
    address: Address;
    /** Address of ENS Universal Resolver Contract. */
    universalResolverAddress?: Address;
}>;
type GetEnsNameReturnType = string | null;
/**
 * @description Gets primary name for specified address.
 *
 * - Calls `reverse(bytes)` on ENS Universal Resolver Contract.
 *
 * @example
 * const ensName = await getEnsName(publicClient, {
 *   address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
 * })
 * // 'wagmi-dev.eth'
 */
declare function getEnsName(client: PublicClient, { address, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_, }: GetEnsNameParameters): Promise<GetEnsNameReturnType>;

type PublicActions<TChain extends Chain = Chain> = {
    call: (args: CallParameters<TChain>) => Promise<CallReturnType>;
    createBlockFilter: () => Promise<CreateBlockFilterReturnType>;
    createContractEventFilter: <TAbi extends Abi | readonly unknown[], TEventName extends string | undefined, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined>(args: CreateContractEventFilterParameters<TAbi, TEventName, TArgs>) => Promise<CreateContractEventFilterReturnType<TAbi, TEventName, TArgs>>;
    createEventFilter: <TAbiEvent extends AbiEvent | undefined, TAbi extends Abi | readonly unknown[], TEventName extends string | undefined, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined>(args?: CreateEventFilterParameters<TAbiEvent, TAbi, TEventName, TArgs>) => Promise<CreateEventFilterReturnType<TAbiEvent, TAbi, TEventName, TArgs>>;
    createPendingTransactionFilter: () => Promise<CreatePendingTransactionFilterReturnType>;
    estimateContractGas: <TChain extends Chain, TAbi extends Abi | readonly unknown[], TFunctionName extends string>(args: EstimateContractGasParameters<TChain, TAbi, TFunctionName>) => Promise<EstimateContractGasReturnType>;
    estimateGas: (args: EstimateGasParameters<TChain>) => Promise<EstimateGasReturnType>;
    getBalance: (args: GetBalanceParameters) => Promise<GetBalanceReturnType>;
    getBlock: (args?: GetBlockParameters) => Promise<GetBlockReturnType<TChain>>;
    getBlockNumber: (args?: GetBlockNumberParameters) => Promise<GetBlockNumberReturnType>;
    getBlockTransactionCount: (args?: GetBlockTransactionCountParameters) => Promise<GetBlockTransactionCountReturnType>;
    getBytecode: (args: GetBytecodeParameters) => Promise<GetBytecodeReturnType>;
    getChainId: () => Promise<GetChainIdReturnType>;
    getEnsAddress: (args: GetEnsAddressParameters) => Promise<GetEnsAddressReturnType>;
    getEnsName: (args: GetEnsNameParameters) => Promise<GetEnsNameReturnType>;
    getFeeHistory: (args: GetFeeHistoryParameters) => Promise<GetFeeHistoryReturnType>;
    getFilterChanges: <TFilterType extends FilterType, TAbiEvent extends AbiEvent | undefined, TAbi extends Abi | readonly unknown[], TEventName extends string | undefined>(args: GetFilterChangesParameters<TFilterType, TAbiEvent, TAbi, TEventName>) => Promise<GetFilterChangesReturnType<TFilterType, TAbiEvent, TAbi, TEventName>>;
    getFilterLogs: <TAbiEvent extends AbiEvent | undefined, TAbi extends Abi | readonly unknown[], TEventName extends string | undefined>(args: GetFilterLogsParameters<TAbiEvent, TAbi, TEventName>) => Promise<GetFilterLogsReturnType<TAbiEvent, TAbi, TEventName>>;
    getGasPrice: () => Promise<GetGasPriceReturnType>;
    getLogs: <TAbiEvent extends AbiEvent | undefined>(args?: GetLogsParameters<TAbiEvent>) => Promise<GetLogsReturnType<TAbiEvent>>;
    getStorageAt: (args: GetStorageAtParameters) => Promise<GetStorageAtReturnType>;
    getTransaction: (args: GetTransactionParameters) => Promise<GetTransactionReturnType<TChain>>;
    getTransactionConfirmations: (args: GetTransactionConfirmationsParameters<TChain>) => Promise<GetTransactionConfirmationsReturnType>;
    getTransactionReceipt: (args: GetTransactionReceiptParameters) => Promise<GetTransactionReceiptReturnType<TChain>>;
    multicall: <TContracts extends ContractConfig[], TAllowFailure extends boolean = true>(args: MulticallParameters<TContracts, TAllowFailure>) => Promise<MulticallReturnType<TContracts, TAllowFailure>>;
    readContract: <TAbi extends Abi | readonly unknown[], TFunctionName extends string>(args: ReadContractParameters<TAbi, TFunctionName>) => Promise<ReadContractReturnType<TAbi, TFunctionName>>;
    simulateContract: <TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = any, TChainOverride extends Chain | undefined = undefined>(args: SimulateContractParameters<TChain, TAbi, TFunctionName, TChainOverride>) => Promise<SimulateContractReturnType<TChainOverride extends Chain ? TChainOverride : TChain, TAbi, TFunctionName>>;
    uninstallFilter: (args: UninstallFilterParameters) => Promise<UninstallFilterReturnType>;
    waitForTransactionReceipt: (args: WaitForTransactionReceiptParameters<TChain>) => Promise<WaitForTransactionReceiptReturnType<TChain>>;
    watchBlockNumber: (args: WatchBlockNumberParameters) => ReturnType<typeof watchBlockNumber>;
    watchBlocks: (args: WatchBlocksParameters<TChain>) => ReturnType<typeof watchBlocks>;
    watchContractEvent: <TAbi extends Abi | readonly unknown[], TEventName extends string>(args: WatchContractEventParameters<TAbi, TEventName>) => ReturnType<typeof watchContractEvent>;
    watchEvent: <TAbiEvent extends AbiEvent | undefined, TEventName extends string | undefined>(args: WatchEventParameters<TAbiEvent>) => ReturnType<typeof watchEvent>;
    watchPendingTransactions: (args: WatchPendingTransactionsParameters) => ReturnType<typeof watchPendingTransactions>;
};

type WalletClientConfig<TTransport extends Transport = Transport, TChain extends Chain = Chain> = {
    chain?: ClientConfig<TTransport, TChain>['chain'];
    /** The key of the Wallet Client. */
    key?: ClientConfig['key'];
    /** The name of the Wallet Client. */
    name?: ClientConfig['name'];
    /** Frequency (in ms) for polling enabled actions & events. Defaults to 4_000 milliseconds. */
    pollingInterval?: ClientConfig['pollingInterval'];
    transport: ClientConfig<TTransport, TChain>['transport'];
};
type WalletClient<TTransport extends Transport = Transport, TChain extends Chain = Chain, TIncludeActions extends boolean = true> = Client<TTransport, TChain> & (TIncludeActions extends true ? WalletActions<TChain> : {});
/**
 * @description Creates a wallet client with a given transport.
 */
declare function createWalletClient<TTransport extends Transport, TChain extends Chain>({ transport, key, name, pollingInterval, }: WalletClientConfig<TTransport, TChain>): WalletClient<TTransport, TChain, true>;

type WalletActions<TChain extends Chain = Chain> = {
    addChain: (args: AddChainParameters) => Promise<void>;
    deployContract: <TAbi extends Abi | readonly unknown[]>(args: DeployContractParameters<TChain, TAbi>) => Promise<DeployContractReturnType>;
    getAddresses: () => Promise<GetAddressesReturnType>;
    getChainId: () => Promise<GetChainIdReturnType>;
    getPermissions: () => Promise<GetPermissionsReturnType>;
    requestAddresses: () => Promise<RequestAddressesReturnType>;
    requestPermissions: (args: RequestPermissionsParameters) => Promise<RequestPermissionsReturnType>;
    sendTransaction: <TChainOverride extends Chain>(args: SendTransactionParameters<TChainOverride>) => Promise<SendTransactionReturnType>;
    signMessage: (args: SignMessageParameters) => Promise<SignMessageReturnType>;
    switchChain: (args: SwitchChainParameters) => Promise<void>;
    watchAsset: (args: WatchAssetParameters) => Promise<WatchAssetReturnType>;
    writeContract: <TAbi extends Abi | readonly unknown[], TFunctionName extends string, TChainOverride extends Chain>(args: WriteContractParameters<TChainOverride, TAbi, TFunctionName>) => Promise<WriteContractReturnType>;
};

type PublicClientConfig<TTransport extends Transport = Transport, TChain extends Chain = Chain> = Pick<ClientConfig<TTransport, TChain>, 'chain' | 'key' | 'name' | 'pollingInterval' | 'transport'>;
type PublicClient<TTransport extends Transport = Transport, TChain extends Chain = Chain, TIncludeActions extends boolean = true> = Client<TTransport, TChain, PublicRequests> & (TIncludeActions extends true ? PublicActions<TChain> : {});
/**
 * @description Creates a public client with a given transport.
 */
declare function createPublicClient<TTransport extends Transport, TChain extends Chain>({ chain, key, name, transport, pollingInterval, }: PublicClientConfig<TTransport, TChain>): PublicClient<TTransport, TChain, true>;

export { writeContract as $, Account as A, BlockFormatter as B, CallParameters as C, estimateContractGas as D, EstimateGasParameters as E, FormattedBlock as F, GetBytecodeParameters as G, getBytecode as H, getStorageAt as I, JsonRpcAccount as J, multicall as K, LocalAccount as L, MulticallParameters as M, readContract as N, OnLogsFn as O, PublicClient as P, simulateContract as Q, ReadContractParameters as R, SendTransactionParameters as S, TransactionReceiptFormatter as T, watchContractEvent as U, DeployContractParameters as V, WalletClient as W, DeployContractReturnType as X, WriteContractParameters as Y, WriteContractReturnType as Z, deployContract as _, PublicClientConfig as a, ReplacementReturnType as a$, GetEnsAddressParameters as a0, GetEnsNameParameters as a1, getEnsAddress as a2, getEnsName as a3, call as a4, createBlockFilter as a5, createEventFilter as a6, createPendingTransactionFilter as a7, estimateGas as a8, getBalance as a9, GetBalanceReturnType as aA, GetBlockParameters as aB, GetBlockNumberParameters as aC, GetBlockNumberReturnType as aD, GetBlockReturnType as aE, GetBlockTransactionCountParameters as aF, GetBlockTransactionCountReturnType as aG, GetFeeHistoryParameters as aH, GetFeeHistoryReturnType as aI, GetFilterChangesParameters as aJ, GetFilterChangesReturnType as aK, GetFilterLogsParameters as aL, GetFilterLogsReturnType as aM, GetGasPriceReturnType as aN, GetTransactionParameters as aO, GetTransactionConfirmationsParameters as aP, GetTransactionConfirmationsReturnType as aQ, GetTransactionReceiptParameters as aR, GetTransactionReceiptReturnType as aS, GetTransactionReturnType as aT, OnBlock as aU, OnBlockNumberFn as aV, OnBlockNumberParameter as aW, OnBlockParameter as aX, OnTransactionsFn as aY, OnTransactionsParameter as aZ, ReplacementReason as a_, getBlock as aa, getBlockNumber as ab, getBlockNumberCache as ac, getBlockTransactionCount as ad, getChainId as ae, getFeeHistory as af, getFilterChanges as ag, getFilterLogs as ah, getLogs as ai, getGasPrice as aj, getTransaction as ak, getTransactionConfirmations as al, getTransactionReceipt as am, uninstallFilter as an, waitForTransactionReceipt as ao, watchBlockNumber as ap, watchBlocks as aq, watchEvent as ar, watchPendingTransactions as as, CallReturnType as at, CreateBlockFilterReturnType as au, CreateEventFilterParameters as av, CreateEventFilterReturnType as aw, CreatePendingTransactionFilterReturnType as ax, EstimateGasReturnType as ay, GetBalanceParameters as az, WalletClientConfig as b, UninstallFilterParameters as b0, UninstallFilterReturnType as b1, WaitForTransactionReceiptParameters as b2, WaitForTransactionReceiptReturnType as b3, WatchBlockNumberParameters as b4, WatchBlocksParameters as b5, WatchPendingTransactionsParameters as b6, addChain as b7, getAddresses as b8, getPermissions as b9, requestAddresses as ba, requestPermissions as bb, sendTransaction as bc, signMessage as bd, switchChain as be, watchAsset as bf, AddChainParameters as bg, FormattedTransactionRequest as bh, GetPermissionsReturnType as bi, GetAddressesReturnType as bj, RequestAddressesReturnType as bk, RequestPermissionsReturnType as bl, SendTransactionReturnType as bm, SignMessageParameters as bn, SignMessageReturnType as bo, SwitchChainParameters as bp, WatchAssetParameters as bq, WatchAssetReturnType as br, createPublicClient as c, createWalletClient as d, FormattedTransactionReceipt as e, FormattedTransactionRequest$1 as f, TransactionRequestFormatter as g, defineBlock as h, defineTransactionReceipt as i, defineTransactionRequest as j, formatBlock as k, formatTransactionRequest as l, CreateContractEventFilterParameters as m, CreateContractEventFilterReturnType as n, EstimateContractGasParameters as o, EstimateContractGasReturnType as p, GetBytecodeReturnType as q, GetStorageAtParameters as r, GetStorageAtReturnType as s, MulticallReturnType as t, OnLogsParameter as u, ReadContractReturnType as v, SimulateContractParameters as w, SimulateContractReturnType as x, WatchContractEventParameters as y, createContractEventFilter as z };
