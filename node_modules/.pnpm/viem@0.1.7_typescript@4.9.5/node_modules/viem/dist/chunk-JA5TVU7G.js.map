{"version":3,"sources":["../src/utils/ens/labelhash.ts","../src/utils/ens/namehash.ts","../src/utils/ens/packetToBytes.ts","../src/actions/ens/getEnsAddress.ts","../src/actions/ens/getEnsName.ts"],"names":["value"],"mappings":"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","sourcesContent":["import { bytesToHex, stringToBytes } from '../encoding'\nimport { keccak256 } from '../hash'\n\n/**\n * @description Hashes ENS label\n *\n * - Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n *\n * @example\n * labelhash('eth')\n * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'\n */\nexport function labelhash(label: string) {\n  let result = new Uint8Array(32).fill(0)\n  if (!label) return bytesToHex(result)\n  return keccak256(stringToBytes(label))\n}\n","import { concat } from '../data'\nimport { bytesToHex, stringToBytes } from '../encoding'\nimport { keccak256 } from '../hash'\n\n/**\n * @description Hashes ENS name\n *\n * - Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n *\n * @example\n * namehash('wagmi-dev.eth')\n * '0xf246651c1b9a6b141d19c2604e9a58f567973833990f830d882534a747801359'\n *\n * @link https://eips.ethereum.org/EIPS/eip-137\n */\nexport function namehash(name: string) {\n  let result = new Uint8Array(32).fill(0)\n  if (!name) return bytesToHex(result)\n\n  const labels = name.split('.')\n  // Iterate in reverse order building up hash\n  for (let i = labels.length - 1; i >= 0; i -= 1) {\n    const hashed = keccak256(stringToBytes(labels[i]), 'bytes')\n    result = keccak256(concat([result, hashed]), 'bytes')\n  }\n\n  return bytesToHex(result)\n}\n","// Adapted from https://github.com/mafintosh/dns-packet\nimport { ByteArray } from '../../types'\nimport { toBytes } from '../encoding'\n\n/*\n * @description Encodes a DNS packet into a ByteArray containing a UDP payload.\n */\nexport function packetToBytes(packet: string): ByteArray {\n  function length(value: string) {\n    if (value === '.' || value === '..') return 1\n    return toBytes(value.replace(/^\\.|\\.$/gm, '')).length + 2\n  }\n\n  const bytes = new Uint8Array(length(packet))\n  // strip leading and trailing `.`\n  const value = packet.replace(/^\\.|\\.$/gm, '')\n  if (!value.length) return bytes\n\n  let offset = 0\n  const list = value.split('.')\n  for (let i = 0; i < list.length; i++) {\n    const encoded = toBytes(list[i])\n    bytes[offset] = encoded.length\n    bytes.set(encoded, offset + 1)\n    offset += encoded.length + 1\n  }\n\n  return bytes\n}\n","import { PublicClient } from '../../clients'\nimport { ChainDoesNotSupportContract } from '../../errors'\nimport type { Address, Prettify } from '../../types'\nimport { decodeFunctionResult, encodeFunctionData, toHex } from '../../utils'\nimport { namehash, packetToBytes } from '../../utils/ens'\nimport { readContract, ReadContractParameters } from '../public'\n\nexport type GetEnsAddressParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** ENS name to get address. */\n    name: string\n    /** Address of ENS Universal Resolver Contract */\n    universalResolverAddress?: Address\n  }\n>\n\nexport type GetEnsAddressReturnType = Address\n\n/**\n * @description Gets address for ENS name.\n *\n * - Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n * - Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n *\n * @example\n * import { normalize } from 'viem/ens'\n *\n * const ensAddress = await getEnsAddress(publicClient, {\n *   name: normalize('wagmi-dev.eth'),\n * })\n * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'\n */\nexport async function getEnsAddress(\n  client: PublicClient,\n  {\n    blockNumber,\n    blockTag,\n    name,\n    universalResolverAddress: universalResolverAddress_,\n  }: GetEnsAddressParameters,\n): Promise<GetEnsAddressReturnType> {\n  let universalResolverAddress = universalResolverAddress_\n  if (!universalResolverAddress) {\n    if (!client.chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n\n    const contract = client.chain?.contracts?.ensUniversalResolver\n    if (!contract)\n      throw new ChainDoesNotSupportContract({\n        chain: client.chain,\n        contract: { name: 'ensUniversalResolver' },\n      })\n\n    if (\n      blockNumber &&\n      contract.blockCreated &&\n      contract.blockCreated > blockNumber\n    )\n      throw new ChainDoesNotSupportContract({\n        blockNumber,\n        chain: client.chain,\n        contract: {\n          name: 'ensUniversalResolver',\n          blockCreated: contract.blockCreated,\n        },\n      })\n\n    universalResolverAddress = contract.address\n  }\n\n  const res = await readContract(client, {\n    address: universalResolverAddress,\n    abi: [\n      {\n        name: 'resolve',\n        type: 'function',\n        stateMutability: 'view',\n        inputs: [\n          { name: 'name', type: 'bytes' },\n          { name: 'data', type: 'bytes' },\n        ],\n        outputs: [\n          { name: '', type: 'bytes' },\n          { name: 'address', type: 'address' },\n        ],\n      },\n    ],\n    functionName: 'resolve',\n    args: [\n      toHex(packetToBytes(name)),\n      encodeFunctionData({\n        abi: [\n          {\n            name: 'addr',\n            type: 'function',\n            stateMutability: 'view',\n            inputs: [{ name: 'name', type: 'bytes32' }],\n            outputs: [],\n          },\n        ],\n        functionName: 'addr',\n        args: [namehash(name)],\n      }),\n    ],\n    blockNumber,\n    blockTag,\n  })\n  return decodeFunctionResult({\n    abi: [\n      {\n        name: 'addr',\n        type: 'function',\n        stateMutability: 'view',\n        inputs: [],\n        outputs: [{ name: 'name', type: 'address' }],\n      },\n    ],\n    functionName: 'addr',\n    data: res[0],\n  })\n}\n","import { PublicClient } from '../../clients'\nimport { panicReasons } from '../../constants'\nimport {\n  ChainDoesNotSupportContract,\n  ContractFunctionExecutionError,\n  ContractFunctionRevertedError,\n} from '../../errors'\nimport type { Address, Prettify } from '../../types'\nimport { toHex } from '../../utils'\nimport { packetToBytes } from '../../utils/ens'\nimport { readContract, ReadContractParameters } from '../public'\n\nexport type GetEnsNameParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** Address to get ENS name for. */\n    address: Address\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address\n  }\n>\n\nexport type GetEnsNameReturnType = string | null\n\n/**\n * @description Gets primary name for specified address.\n *\n * - Calls `reverse(bytes)` on ENS Universal Resolver Contract.\n *\n * @example\n * const ensName = await getEnsName(publicClient, {\n *   address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',\n * })\n * // 'wagmi-dev.eth'\n */\nexport async function getEnsName(\n  client: PublicClient,\n  {\n    address,\n    blockNumber,\n    blockTag,\n    universalResolverAddress: universalResolverAddress_,\n  }: GetEnsNameParameters,\n): Promise<GetEnsNameReturnType> {\n  let universalResolverAddress = universalResolverAddress_\n  if (!universalResolverAddress) {\n    if (!client.chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n\n    const contract = client.chain?.contracts?.ensUniversalResolver\n    if (!contract)\n      throw new ChainDoesNotSupportContract({\n        chain: client.chain,\n        contract: { name: 'ensUniversalResolver' },\n      })\n\n    if (\n      blockNumber &&\n      contract.blockCreated &&\n      contract.blockCreated > blockNumber\n    )\n      throw new ChainDoesNotSupportContract({\n        blockNumber,\n        chain: client.chain,\n        contract: {\n          name: 'ensUniversalResolver',\n          blockCreated: contract.blockCreated,\n        },\n      })\n\n    universalResolverAddress = contract.address\n  }\n\n  const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`\n  try {\n    const res = await readContract(client, {\n      address: universalResolverAddress,\n      abi: [\n        {\n          name: 'reverse',\n          type: 'function',\n          stateMutability: 'view',\n          inputs: [{ type: 'bytes', name: 'reverseName' }],\n          outputs: [\n            { type: 'string', name: 'resolvedName' },\n            { type: 'address', name: 'resolvedAddress' },\n            { type: 'address', name: 'reverseResolver' },\n            { type: 'address', name: 'resolver' },\n          ],\n        },\n      ],\n      functionName: 'reverse',\n      args: [toHex(packetToBytes(reverseNode))],\n      blockNumber,\n      blockTag,\n    })\n    return res[0]\n  } catch (error) {\n    if (\n      error instanceof ContractFunctionExecutionError &&\n      (error.cause as ContractFunctionRevertedError).reason === panicReasons[50]\n    )\n      // No primary name set for address.\n      return null\n    throw error\n  }\n}\n"]}