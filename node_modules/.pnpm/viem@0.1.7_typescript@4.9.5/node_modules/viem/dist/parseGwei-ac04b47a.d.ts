import { B as ByteArray, H as Hex, C as Chain, a as Hash, f as BlockTag, a4 as EventDefinition } from './chain-d64be356.js';
import { L as LocalAccount, A as Account, C as CallParameters, E as EstimateGasParameters, S as SendTransactionParameters } from './createPublicClient-b12dc2b7.js';
import { Address, Abi } from 'abitype';
import { a as DecodeErrorResultReturnType } from './encodeFunctionResult-12963e93.js';
import WebSocket from 'isomorphic-ws';

declare function getAccount(account: Address | Omit<LocalAccount, 'type'>): Account;

declare function getAddress(address: string): Address;

type GetCreateAddressOptions = {
    from: Address;
    nonce: bigint;
};
type GetCreate2AddressOptions = {
    bytecode: ByteArray | Hex;
    from: Address;
    salt: ByteArray | Hex;
};
type GetContractAddressOptions = ({
    opcode?: 'CREATE';
} & GetCreateAddressOptions) | ({
    opcode: 'CREATE2';
} & GetCreate2AddressOptions);
declare function getContractAddress(opts: GetContractAddressOptions): `0x${string}`;
declare function getCreateAddress(opts: GetCreateAddressOptions): `0x${string}`;
declare function getCreate2Address(opts: GetCreate2AddressOptions): `0x${string}`;

declare function isAddress(address: string): address is Address;

declare function isAddressEqual(a: Address, b: Address): boolean;

declare function isBytes(value: unknown): value is ByteArray;

declare function isHex(value: unknown): value is Hex;

type PadOptions = {
    dir?: 'left' | 'right';
    size?: number | null;
};
type PadReturnType<TValue extends ByteArray | Hex> = TValue extends Hex ? Hex : ByteArray;
declare function pad<TValue extends ByteArray | Hex>(hexOrBytes: TValue, { dir, size }?: PadOptions): PadReturnType<TValue>;
declare function padHex(hex_: Hex, { dir, size }?: PadOptions): `0x${string}`;
declare function padBytes(bytes: ByteArray, { dir, size }?: PadOptions): Uint8Array;

type TrimOptions = {
    dir?: 'left' | 'right';
};
type TrimReturnType<TValue extends ByteArray | Hex> = TValue extends Hex ? Hex : ByteArray;
declare function trim<TValue extends ByteArray | Hex>(hexOrBytes: TValue, { dir }?: TrimOptions): TrimReturnType<TValue>;

/**
 * @description Retrieves the size of the value (in bytes).
 *
 * @param value The value (hex or byte array) to retrieve the size of.
 * @returns The size of the value (in bytes).
 */
declare function size(value: Hex | ByteArray): number;

type SliceReturnType<TValue extends ByteArray | Hex> = TValue extends Hex ? Hex : ByteArray;
/**
 * @description Returns a section of the hex or byte array given a start/end bytes offset.
 *
 * @param value The hex or byte array to slice.
 * @param start The start offset (in bytes).
 * @param end The end offset (in bytes).
 */
declare function slice<TValue extends ByteArray | Hex>(value: TValue, start?: number, end?: number): SliceReturnType<TValue>;
/**
 * @description Returns a section of the byte array given a start/end bytes offset.
 *
 * @param value The byte array to slice.
 * @param start The start offset (in bytes).
 * @param end The end offset (in bytes).
 */
declare function sliceBytes(value: ByteArray, start?: number, end?: number): Uint8Array;
/**
 * @description Returns a section of the hex value given a start/end bytes offset.
 *
 * @param value The hex value to slice.
 * @param start The start offset (in bytes).
 * @param end The end offset (in bytes).
 */
declare function sliceHex(value_: Hex, start?: number, end?: number): string;

/**
 * @description Encodes a boolean into a hex string
 */
declare function boolToHex(value: boolean): Hex;
/**
 * @description Encodes a bytes array into a hex string
 */
declare function bytesToHex(value: ByteArray): Hex;
/**
 * @description Encodes a string, number, bigint, or ByteArray into a hex string
 */
declare function toHex(value: string | number | bigint | boolean | ByteArray): Hex;
type NumberToHexOpts$1 = {
    signed?: boolean;
    size: number;
} | {
    signed?: never;
    size?: never;
};
/**
 * @description Encodes a number or bigint into a hex string
 */
declare function numberToHex(value_: number | bigint, opts?: NumberToHexOpts$1): Hex;
/**
 * @description Encodes a UTF-8 string into a hex string
 */
declare function stringToHex(value_: string): Hex;

/** @description Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array. */
declare function toBytes(value: string | bigint | number | boolean | Hex): ByteArray;
/**
 * @description Encodes a boolean into a byte array.
 */
declare function boolToBytes(value: boolean): Uint8Array;
/**
 * @description Encodes a hex string into a byte array.
 */
declare function hexToBytes(hex_: Hex): ByteArray;
/**
 * @description Encodes a number into a byte array.
 */
declare function numberToBytes(value: bigint | number, opts?: NumberToHexOpts$1): Uint8Array;
/**
 * @description Encodes a UTF-8 string into a byte array.
 */
declare function stringToBytes(value: string): ByteArray;

type RecursiveArray<T> = T | RecursiveArray<T>[];
type To$1 = 'hex' | 'bytes';
type ToRlpReturnType<TTo extends To$1> = TTo extends 'bytes' ? ByteArray : TTo extends 'hex' ? Hex : never;
declare function toRlp<TTo extends To$1 = 'hex'>(hexOrBytes: RecursiveArray<Hex> | RecursiveArray<ByteArray>, to_?: TTo): ToRlpReturnType<TTo>;

type FromBytesReturnType<TTo> = TTo extends 'string' ? string : TTo extends 'hex' ? Hex : TTo extends 'bigint' ? bigint : TTo extends 'number' ? number : TTo extends 'boolean' ? boolean : never;
/**
 * @description Decodes a byte array into a UTF-8 string, hex value, number, bigint or boolean.
 */
declare function fromBytes<TTo extends 'string' | 'hex' | 'bigint' | 'number' | 'boolean'>(bytes: ByteArray, to: TTo): FromBytesReturnType<TTo>;
/**
 * @description Decodes a byte array into a bigint.
 */
declare function bytesToBigint(bytes: ByteArray): bigint;
/**
 * @description Decodes a byte array into a boolean.
 */
declare function bytesToBool(bytes: ByteArray): boolean;

/**
 * @description Decodes a byte array into a number.
 */
declare function bytesToNumber(bytes: ByteArray): number;
/**
 * @description Decodes a byte array into a UTF-8 string.
 */
declare function bytesToString(bytes: ByteArray): string;

type FromHexReturnType<TTo> = TTo extends 'string' ? string : TTo extends 'bigint' ? bigint : TTo extends 'number' ? number : TTo extends 'bytes' ? ByteArray : TTo extends 'boolean' ? boolean : never;
/**
 * @description Decodes a hex string into a string, number, bigint, boolean, or bytes32 array.
 */
declare function fromHex<TTo extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean'>(hex: Hex, to: TTo): FromHexReturnType<TTo>;
type HexToBigIntOpts = {
    signed?: boolean;
};
/**
 * @description Decodes a hex string into a bigint.
 */
declare function hexToBigInt(hex: Hex, opts?: HexToBigIntOpts): bigint;
/**
 * @description Decodes a hex string into a boolean.
 */
declare function hexToBool(hex: Hex): boolean;
type NumberToHexOpts = HexToBigIntOpts;
/**
 * @description Decodes a hex string into a number.
 */
declare function hexToNumber(hex: Hex, opts?: NumberToHexOpts): number;
/**
 * @description Decodes a hex string into a UTF-8 string.
 */
declare function hexToString(hex: Hex): string;

type FromRlpReturnType<TTo> = TTo extends 'bytes' ? ByteArray : TTo extends 'hex' ? Hex : never;
declare function fromRlp<TTo extends 'bytes' | 'hex'>(value: ByteArray | Hex, to: TTo): RecursiveArray<FromRlpReturnType<TTo>>;

type BaseErrorParameters = {
    docsPath?: string;
    metaMessages?: string[];
} & ({
    cause?: never;
    details?: string;
} | {
    cause: BaseError | Error;
    details?: never;
});
declare class BaseError extends Error {
    details: string;
    docsPath?: string;
    metaMessages?: string[];
    shortMessage: string;
    name: string;
    constructor(shortMessage: string, args?: BaseErrorParameters);
}

declare class CallExecutionError extends BaseError {
    cause: BaseError;
    name: string;
    constructor(cause: BaseError, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }: CallParameters & {
        chain?: Chain;
        docsPath?: string;
    });
}
declare class ContractFunctionExecutionError extends BaseError {
    abi: Abi;
    args?: unknown[];
    cause: BaseError;
    contractAddress?: Address;
    formattedArgs?: string;
    functionName: string;
    sender?: Address;
    name: string;
    constructor(cause: BaseError, { abi, args, contractAddress, docsPath, functionName, sender, }: {
        abi: Abi;
        args?: any;
        contractAddress?: Address;
        docsPath?: string;
        functionName: string;
        sender?: Address;
    });
}
declare class ContractFunctionRevertedError extends BaseError {
    name: string;
    data?: DecodeErrorResultReturnType;
    reason?: string;
    constructor({ abi, data, functionName, message, }: {
        abi: Abi;
        data?: Hex;
        functionName: string;
        message?: string;
    });
}
declare class ContractFunctionZeroDataError extends BaseError {
    name: string;
    constructor({ functionName }: {
        functionName: string;
    });
}
declare class RawContractError extends BaseError {
    code: number;
    name: string;
    data?: Hex;
    constructor({ data, message }: {
        data?: Hex;
        message?: string;
    });
}

declare class EstimateGasExecutionError extends BaseError {
    cause: BaseError;
    name: string;
    constructor(cause: BaseError, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }: EstimateGasParameters & {
        chain?: Chain;
        docsPath?: string;
    });
}

/**
 * geth:    https://github.com/ethereum/go-ethereum/blob/master/core/error.go
 *          https://github.com/ethereum/go-ethereum/blob/master/core/types/transaction.go#L34-L41
 *
 * erigon:  https://github.com/ledgerwatch/erigon/blob/master/core/error.go
 *          https://github.com/ledgerwatch/erigon/blob/master/core/types/transaction.go#L41-L46
 *
 * anvil:   https://github.com/foundry-rs/foundry/blob/master/anvil/src/eth/error.rs#L108
 */
declare class ExecutionRevertedError extends BaseError {
    static code: number;
    static nodeMessage: RegExp;
    name: string;
    constructor({ cause, message, }?: {
        cause?: BaseError;
        message?: string;
    });
}
declare class FeeCapTooHighError extends BaseError {
    static nodeMessage: RegExp;
    name: string;
    constructor({ cause, maxFeePerGas, }?: {
        cause?: BaseError;
        maxFeePerGas?: bigint;
    });
}
declare class FeeCapTooLowError extends BaseError {
    static nodeMessage: RegExp;
    name: string;
    constructor({ cause, maxFeePerGas, }?: {
        cause?: BaseError;
        maxFeePerGas?: bigint;
    });
}
declare class NonceTooHighError extends BaseError {
    static nodeMessage: RegExp;
    name: string;
    constructor({ cause, nonce }?: {
        cause?: BaseError;
        nonce?: number;
    });
}
declare class NonceTooLowError extends BaseError {
    static nodeMessage: RegExp;
    name: string;
    constructor({ cause, nonce }?: {
        cause?: BaseError;
        nonce?: number;
    });
}
declare class NonceMaxValueError extends BaseError {
    static nodeMessage: RegExp;
    name: string;
    constructor({ cause, nonce }?: {
        cause?: BaseError;
        nonce?: number;
    });
}
declare class InsufficientFundsError extends BaseError {
    static nodeMessage: RegExp;
    name: string;
    constructor({ cause }?: {
        cause?: BaseError;
    });
}
declare class IntrinsicGasTooHighError extends BaseError {
    static nodeMessage: RegExp;
    name: string;
    constructor({ cause, gas }?: {
        cause?: BaseError;
        gas?: bigint;
    });
}
declare class IntrinsicGasTooLowError extends BaseError {
    static nodeMessage: RegExp;
    name: string;
    constructor({ cause, gas }?: {
        cause?: BaseError;
        gas?: bigint;
    });
}
declare class TransactionTypeNotSupportedError extends BaseError {
    static nodeMessage: RegExp;
    name: string;
    constructor({ cause }: {
        cause?: BaseError;
    });
}
declare class TipAboveFeeCapError extends BaseError {
    static nodeMessage: RegExp;
    name: string;
    constructor({ cause, maxPriorityFeePerGas, maxFeePerGas, }?: {
        cause?: BaseError;
        maxPriorityFeePerGas?: bigint;
        maxFeePerGas?: bigint;
    });
}
declare class UnknownNodeError extends BaseError {
    name: string;
    constructor({ cause }: {
        cause?: BaseError;
    });
}

declare class TransactionExecutionError extends BaseError {
    cause: BaseError;
    name: string;
    constructor(cause: BaseError, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }: SendTransactionParameters & {
        docsPath?: string;
    });
}
declare class TransactionNotFoundError extends BaseError {
    name: string;
    constructor({ blockHash, blockNumber, blockTag, hash, index, }: {
        blockHash?: Hash;
        blockNumber?: bigint;
        blockTag?: BlockTag;
        hash?: Hash;
        index?: number;
    });
}
declare class TransactionReceiptNotFoundError extends BaseError {
    name: string;
    constructor({ hash }: {
        hash: Hash;
    });
}
declare class WaitForTransactionReceiptTimeoutError extends BaseError {
    name: string;
    constructor({ hash }: {
        hash: Hash;
    });
}

declare function getContractError(err: BaseError, { abi, address, args, docsPath, functionName, sender, }: {
    abi: Abi;
    args: any;
    address?: Address;
    docsPath?: string;
    functionName: string;
    sender?: Address;
}): ContractFunctionExecutionError;

declare const getEventSelector: (event: EventDefinition) => `0x${string}`;

declare const getFunctionSelector: (fn: string) => `0x${string}`;

type To = 'hex' | 'bytes';
type Keccak256Hash<TTo extends To> = (TTo extends 'bytes' ? ByteArray : never) | (TTo extends 'hex' ? Hex : never);
declare function keccak256<TTo extends To = 'hex'>(value: Hex | ByteArray, to_?: TTo): Keccak256Hash<TTo>;

type SuccessResult<T> = {
    method?: never;
    result: T;
    error?: never;
};
type ErrorResult<T> = {
    method?: never;
    result?: never;
    error: T;
};
type Subscription<TResult, TError> = {
    method: 'eth_subscription';
    error?: never;
    result?: never;
    params: {
        subscription: string;
    } & ({
        result: TResult;
        error?: never;
    } | {
        result?: never;
        error: TError;
    });
};
type RpcRequest = {
    method: string;
    params?: any[];
};
type RpcResponse<TResult = any, TError = any> = {
    jsonrpc: `${number}`;
    id: number;
} & (SuccessResult<TResult> | ErrorResult<TError> | Subscription<TResult, TError>);
type HttpOptions = {
    body: RpcRequest;
    fetchOptions?: Omit<RequestInit, 'body'>;
    timeout?: number;
};
declare function http(url: string, { body, fetchOptions, timeout }: HttpOptions): Promise<RpcResponse<any, any>>;
type Id = string | number;
type CallbackFn = (message: any) => void;
type CallbackMap = Map<Id, CallbackFn>;
type Socket = WebSocket & {
    requests: CallbackMap;
    subscriptions: CallbackMap;
};
declare function getSocket(url_: string): Promise<Socket>;
declare function webSocket(socket: Socket, { body, onData, onError, }: {
    body: RpcRequest;
    onData?: (message: RpcResponse) => void;
    onError?: (message: RpcResponse['error']) => void;
}): Socket;
declare function webSocketAsync(socket: Socket, { body, timeout, }: {
    body: RpcRequest;
    timeout?: number;
}): Promise<RpcResponse<any, any>>;
declare const rpc: {
    http: typeof http;
    webSocket: typeof webSocket;
    webSocketAsync: typeof webSocketAsync;
};

declare const stringify: typeof JSON.stringify;

declare function formatEther(wei: bigint, unit?: 'wei' | 'gwei'): string;

declare function formatGwei(wei: bigint, unit?: 'wei'): string;

declare function formatUnits(value: bigint, decimals: number): string;

declare function parseUnits(value: `${number}`, decimals: number): bigint;

declare function parseEther(ether: `${number}`, unit?: 'wei' | 'gwei'): bigint;

declare function parseGwei(ether: `${number}`, unit?: 'wei'): bigint;

export { hexToNumber as $, formatUnits as A, BaseError as B, CallExecutionError as C, fromBytes as D, EstimateGasExecutionError as E, FeeCapTooHighError as F, GetContractAddressOptions as G, HttpOptions as H, InsufficientFundsError as I, fromHex as J, fromRlp as K, getAccount as L, getAddress as M, NonceMaxValueError as N, getContractAddress as O, getContractError as P, getCreate2Address as Q, RpcResponse as R, getCreateAddress as S, TipAboveFeeCapError as T, UnknownNodeError as U, getEventSelector as V, WaitForTransactionReceiptTimeoutError as W, getFunctionSelector as X, hexToBigInt as Y, hexToBool as Z, hexToBytes as _, ContractFunctionExecutionError as a, hexToString as a0, isAddress as a1, isAddressEqual as a2, isBytes as a3, isHex as a4, keccak256 as a5, numberToBytes as a6, numberToHex as a7, pad as a8, padBytes as a9, padHex as aa, parseEther as ab, parseGwei as ac, parseUnits as ad, size as ae, slice as af, sliceBytes as ag, sliceHex as ah, stringToBytes as ai, stringToHex as aj, stringify as ak, toBytes as al, toHex as am, toRlp as an, trim as ao, Socket as ap, getSocket as aq, rpc as ar, ContractFunctionRevertedError as b, ContractFunctionZeroDataError as c, ExecutionRevertedError as d, FeeCapTooLowError as e, IntrinsicGasTooHighError as f, IntrinsicGasTooLowError as g, NonceTooHighError as h, NonceTooLowError as i, RawContractError as j, TransactionExecutionError as k, TransactionTypeNotSupportedError as l, TransactionNotFoundError as m, TransactionReceiptNotFoundError as n, GetCreate2AddressOptions as o, GetCreateAddressOptions as p, ToRlpReturnType as q, boolToBytes as r, boolToHex as s, bytesToBigint as t, bytesToBool as u, bytesToHex as v, bytesToNumber as w, bytesToString as x, formatEther as y, formatGwei as z };
