import { W as WalletPermission, a as WatchAssetParams, P as PublicRequests } from './eip1193-029d52f0.js';
import { a as Transport, b as ClientConfig, C as Client } from './createClient-8575dcd6.js';
import { C as Chain, I as ExtractFormatter, Q as Formatters, S as Formatter, J as Formatted, c as Block, R as RpcBlock, y as Transaction, T as TransactionReceipt, q as RpcTransactionReceipt, V as TransactionType, r as RpcTransactionRequest, t as TransactionRequest, f as BlockTag, H as Hex, W as MergeIntersectionProperties, X as ExtractConstructorArgsFromAbi, a as Hash, Y as GetValue, g as ContractConfig, Z as ExtractResultFromAbi, _ as MaybeAbiEventName, $ as MaybeExtractEventArgsFromAbi, e as BlockNumber, a0 as ExtractEventNameFromAbi, F as FeeHistory, L as Log, K as FormattedTransaction, M as TransactionFormatter, a1 as ExtractEventArgsFromAbi, a2 as Prettify } from './chain-d64be356.js';
import { Abi, Narrow, Address, AbiEvent, ExtractAbiEvent } from 'abitype';

type BlockFormatter<TChain extends Chain = Chain> = ExtractFormatter<TChain, 'block', NonNullable<Formatters['block']>>;
type FormattedBlock<TFormatter extends Formatter | undefined = Formatter> = Formatted<TFormatter, Block>;
declare function formatBlock(block: Partial<RpcBlock>): Block<bigint, Transaction<bigint, number>>;
declare const defineBlock: <TFormat extends Formatter<Partial<RpcBlock>, Partial<Block<bigint, Transaction<bigint, number>>> & {
    [key: string]: unknown;
}>, TExclude extends (keyof RpcBlock)[] = []>({ exclude, format: formatOverride, }: {
    exclude?: TExclude | undefined;
    format?: TFormat | undefined;
}) => (data: Partial<RpcBlock> & {
    [key: string]: unknown;
}) => Block<bigint, Transaction<bigint, number>> & ReturnType<TFormat> & { [K in TExclude[number]]: never; };

type TransactionReceiptFormatter<TChain extends Chain = Chain> = ExtractFormatter<TChain, 'transactionReceipt', NonNullable<Formatters['transactionReceipt']>>;
type FormattedTransactionReceipt<TFormatter extends Formatter | undefined = Formatter> = Formatted<TFormatter, TransactionReceipt>;
declare const defineTransactionReceipt: <TFormat extends Formatter<Partial<RpcTransactionReceipt>, Partial<TransactionReceipt<bigint, number, "success" | "reverted", TransactionType>> & {
    [key: string]: unknown;
}>, TExclude extends (keyof RpcTransactionReceipt)[] = []>({ exclude, format: formatOverride, }: {
    exclude?: TExclude | undefined;
    format?: TFormat | undefined;
}) => (data: Partial<RpcTransactionReceipt> & {
    [key: string]: unknown;
}) => TransactionReceipt<bigint, number, "success" | "reverted", TransactionType> & ReturnType<TFormat> & { [K in TExclude[number]]: never; };

type TransactionRequestFormatter<TChain extends Chain = Chain> = ExtractFormatter<TChain, 'transactionRequest', NonNullable<Formatters['transactionRequest']>>;
type FormattedTransactionRequest$1<TFormatter extends Formatter | undefined = Formatter> = Formatted<TFormatter, RpcTransactionRequest>;
declare function formatTransactionRequest(transactionRequest: Partial<TransactionRequest>): RpcTransactionRequest;
declare const defineTransactionRequest: <TFormat extends Formatter<Partial<TransactionRequest<bigint, number>>, Partial<RpcTransactionRequest> & {
    [key: string]: unknown;
}>, TExclude extends ("value" | "from" | "gasPrice" | "maxFeePerGas" | "maxPriorityFeePerGas" | "data" | "gas" | "nonce" | "to" | "accessList")[] = []>({ exclude, format: formatOverride, }: {
    exclude?: TExclude | undefined;
    format?: TFormat | undefined;
}) => (data: Partial<TransactionRequest<bigint, number>> & {
    [key: string]: unknown;
}) => RpcTransactionRequest & ReturnType<TFormat> & { [K in TExclude[number]]: never; };

type FormattedCall<TFormatter extends Formatter | undefined = Formatter> = MergeIntersectionProperties<Omit<Formatted<TFormatter, TransactionRequest, true>, 'from'>, TransactionRequest>;
type CallParameters<TChain extends Chain = Chain> = FormattedCall<TransactionRequestFormatter<TChain>> & {
    account?: Account;
} & ({
    /** The balance of the account at a block number. */
    blockNumber?: bigint;
    blockTag?: never;
} | {
    blockNumber?: never;
    /** The balance of the account at a block tag. */
    blockTag?: BlockTag;
});
type CallReturnType = {
    data: Hex | undefined;
};
declare function call<TChain extends Chain>(client: PublicClient<any, TChain>, args: CallParameters<TChain>): Promise<CallReturnType>;

type AddChainParameters = {
    chain: Chain;
};
declare function addChain(client: WalletClient, { chain }: AddChainParameters): Promise<void>;

type DeployContractParameters<TChain extends Chain = Chain, TAbi extends Abi | readonly unknown[] = Abi> = Omit<SendTransactionParameters<TChain>, 'accessList' | 'to' | 'data' | 'value'> & {
    abi: Narrow<TAbi>;
    bytecode: Hex;
} & ExtractConstructorArgsFromAbi<TAbi>;
type DeployContractReturnType = SendTransactionReturnType;
declare function deployContract<TChain extends Chain, TAbi extends Abi | readonly unknown[]>(walletClient: WalletClient, { abi, args, bytecode, ...request }: DeployContractParameters<TChain, TAbi>): Promise<DeployContractReturnType>;

type GetAddressesReturnType = Address[];
declare function getAddresses(client: WalletClient): Promise<GetAddressesReturnType>;

type GetChainIdReturnType = number;
declare function getChainId(client: PublicClient | WalletClient): Promise<GetChainIdReturnType>;

type GetPermissionsReturnType = WalletPermission[];
declare function getPermissions(client: WalletClient): Promise<WalletPermission[]>;

type RequestAddressesReturnType = Address[];
declare function requestAddresses(client: WalletClient): Promise<RequestAddressesReturnType>;

type RequestPermissionsParameters = {
    eth_accounts: Record<string, any>;
} & {
    [key: string]: Record<string, any>;
};
type RequestPermissionsReturnType = WalletPermission[];
declare function requestPermissions(client: WalletClient, permissions: RequestPermissionsParameters): Promise<WalletPermission[]>;

type FormattedTransactionRequest<TFormatter extends Formatter | undefined = Formatter> = MergeIntersectionProperties<Omit<Formatted<TFormatter, TransactionRequest, true>, 'from'>, TransactionRequest>;
type SendTransactionParameters<TChain extends Chain = Chain> = FormattedTransactionRequest<TransactionRequestFormatter<TChain>> & {
    account: Account;
} & ({
    assertChain?: false;
    chain?: TChain;
} | {
    assertChain: true;
    chain: TChain;
});
type SendTransactionReturnType = Hash;
declare function sendTransaction<TChain extends Chain>(client: WalletClient, args: SendTransactionParameters<TChain>): Promise<SendTransactionReturnType>;

type SignMessageParameters = {
    account: Account;
    data: string;
};
type SignMessageReturnType = Hex;
declare function signMessage(client: WalletClient, { account, data }: SignMessageParameters): Promise<SignMessageReturnType>;

type SwitchChainParameters = {
    id: Chain['id'];
};
declare function switchChain(client: WalletClient, { id }: SwitchChainParameters): Promise<void>;

type WatchAssetParameters = WatchAssetParams;
type WatchAssetReturnType = boolean;
declare function watchAsset(client: WalletClient, params: WatchAssetParameters): Promise<WatchAssetReturnType>;

type WriteContractParameters<TChain extends Chain = Chain, TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string> = Omit<SendTransactionParameters<TChain>, 'to' | 'data' | 'value'> & {
    value?: GetValue<TAbi, TFunctionName, SendTransactionParameters<TChain>['value']>;
} & ContractConfig<TAbi, TFunctionName, 'payable' | 'nonpayable'>;
type WriteContractReturnType = SendTransactionReturnType;
declare function writeContract<TChain extends Chain, TAbi extends Abi | readonly unknown[], TFunctionName extends string>(client: WalletClient, { abi, address, args, functionName, ...request }: WriteContractParameters<TChain, TAbi, TFunctionName>): Promise<WriteContractReturnType>;

type SimulateContractParameters<TChain extends Chain = Chain, TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = any, TChainOverride extends Chain | undefined = undefined> = Omit<CallParameters<TChainOverride extends Chain ? TChainOverride : TChain>, 'to' | 'data' | 'value'> & {
    chain?: TChainOverride;
} & ContractConfig<TAbi, TFunctionName, 'payable' | 'nonpayable'> & {
    value?: GetValue<TAbi, TFunctionName, CallParameters<TChain>['value']>;
};
type SimulateContractReturnType<TChain extends Chain = Chain, TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string> = {
    result: ExtractResultFromAbi<TAbi, TFunctionName>;
    request: WriteContractParameters<TChain, TAbi, TFunctionName> & ContractConfig<TAbi, TFunctionName, 'payable' | 'nonpayable'>;
};
declare function simulateContract<TChain extends Chain, TAbi extends Abi | readonly unknown[], TFunctionName extends string, TChainOverride extends Chain | undefined>(client: PublicClient<any, TChain>, { abi, address, args, functionName, ...callRequest }: SimulateContractParameters<TChain, TAbi, TFunctionName, TChainOverride>): Promise<SimulateContractReturnType<TChainOverride extends Chain ? TChainOverride : TChain, TAbi, TFunctionName>>;

type CreatePendingTransactionFilterReturnType = Filter<'transaction'>;
declare function createPendingTransactionFilter(client: PublicClient): Promise<CreatePendingTransactionFilterReturnType>;

type CreateBlockFilterReturnType = Filter<'block'>;
declare function createBlockFilter(client: PublicClient): Promise<CreateBlockFilterReturnType>;

type CreateEventFilterParameters<TAbiEvent extends AbiEvent | undefined = undefined, TAbi extends Abi | readonly unknown[] = [TAbiEvent], TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined = undefined> = {
    address?: Address | Address[];
    fromBlock?: BlockNumber | BlockTag;
    toBlock?: BlockNumber | BlockTag;
} & (MaybeExtractEventArgsFromAbi<TAbi, TEventName> extends infer TEventFilterArgs ? {
    args: TEventFilterArgs | (TArgs extends TEventFilterArgs ? TArgs : never);
    event: TAbiEvent;
} | {
    args?: never;
    event?: TAbiEvent;
} | {
    args?: never;
    event?: never;
} : {
    args?: never;
    event?: never;
});
type CreateEventFilterReturnType<TAbiEvent extends AbiEvent | undefined = undefined, TAbi extends Abi | readonly unknown[] = [TAbiEvent], TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined = undefined> = Filter<'event', TAbi, TEventName, TArgs>;
declare function createEventFilter<TAbiEvent extends AbiEvent | undefined, TAbi extends Abi | readonly unknown[] = [TAbiEvent], TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined = undefined>(client: PublicClient, { address, args, event, fromBlock, toBlock, }?: CreateEventFilterParameters<TAbiEvent, TAbi, TEventName, TArgs>): Promise<CreateEventFilterReturnType<TAbiEvent, TAbi, TEventName, TArgs>>;

type CreateContractEventFilterParameters<TAbi extends Abi | readonly unknown[] = Abi, TEventName extends string | undefined = undefined, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined = undefined> = {
    address?: Address | Address[];
    abi: Narrow<TAbi>;
    eventName?: ExtractEventNameFromAbi<TAbi, TEventName>;
    fromBlock?: BlockNumber | BlockTag;
    toBlock?: BlockNumber | BlockTag;
} & (undefined extends TEventName ? {
    args?: never;
} : MaybeExtractEventArgsFromAbi<TAbi, TEventName> extends infer TEventFilterArgs ? {
    args?: TEventFilterArgs | (TArgs extends TEventFilterArgs ? TArgs : never);
} : {
    args?: never;
});
type CreateContractEventFilterReturnType<TAbi extends Abi | readonly unknown[] = Abi, TEventName extends string | undefined = undefined, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined = undefined> = Filter<'event', TAbi, TEventName, TArgs>;
declare function createContractEventFilter<TAbi extends Abi | readonly unknown[], TEventName extends string | undefined, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined>(client: PublicClient, { address, abi, args, eventName, fromBlock, toBlock, }: CreateContractEventFilterParameters<TAbi, TEventName, TArgs>): Promise<CreateContractEventFilterReturnType<TAbi, TEventName, TArgs>>;

type FormattedEstimateGas<TFormatter extends Formatter | undefined = Formatter> = MergeIntersectionProperties<Omit<Formatted<TFormatter, TransactionRequest, true>, 'from'>, TransactionRequest>;
type EstimateGasParameters<TChain extends Chain = Chain> = FormattedEstimateGas<TransactionRequestFormatter<TChain>> & {
    account: Account;
} & ({
    /** The balance of the account at a block number. */
    blockNumber?: bigint;
    blockTag?: never;
} | {
    blockNumber?: never;
    /** The balance of the account at a block tag. */
    blockTag?: BlockTag;
});
type EstimateGasReturnType = bigint;
/**
 * @description Estimates the gas necessary to complete a transaction without submitting it to the network.
 */
declare function estimateGas<TChain extends Chain>(client: PublicClient<any, TChain> | WalletClient, args: EstimateGasParameters<TChain>): Promise<EstimateGasReturnType>;

type EstimateContractGasParameters<TChain extends Chain = Chain, TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = any> = Omit<EstimateGasParameters<TChain>, 'data' | 'to' | 'value'> & ContractConfig<TAbi, TFunctionName, 'payable' | 'nonpayable'> & {
    value?: GetValue<TAbi, TFunctionName, EstimateGasParameters<TChain>['value']>;
};
type EstimateContractGasReturnType = bigint;
declare function estimateContractGas<TChain extends Chain, TAbi extends Abi | readonly unknown[], TFunctionName extends string>(client: PublicClient<any, TChain>, { abi, address, args, functionName, ...request }: EstimateContractGasParameters<TChain, TAbi, TFunctionName>): Promise<EstimateContractGasReturnType>;

type GetBalanceParameters = {
    /** The address of the account. */
    address: Address;
} & ({
    /** The balance of the account at a block number. */
    blockNumber?: bigint;
    blockTag?: never;
} | {
    blockNumber?: never;
    /** The balance of the account at a block tag. */
    blockTag?: BlockTag;
});
type GetBalanceReturnType = bigint;
/**
 * @description Returns the balance of an address in wei.
 */
declare function getBalance(client: PublicClient, { address, blockNumber, blockTag }: GetBalanceParameters): Promise<GetBalanceReturnType>;

type GetBlockParameters = {
    /** Whether or not to include transaction data in the response. */
    includeTransactions?: boolean;
} & ({
    /** Hash of the block. */
    blockHash?: Hash;
    blockNumber?: never;
    blockTag?: never;
} | {
    blockHash?: never;
    /** The block number. */
    blockNumber?: bigint;
    blockTag?: never;
} | {
    blockHash?: never;
    blockNumber?: never;
    /** The block tag. Defaults to 'latest'. */
    blockTag?: BlockTag;
});
type GetBlockReturnType<TChain extends Chain = Chain> = FormattedBlock<BlockFormatter<TChain>>;
declare function getBlock<TChain extends Chain>(client: PublicClient<any, TChain> | WalletClient, { blockHash, blockNumber, blockTag, includeTransactions, }?: GetBlockParameters): Promise<GetBlockReturnType<TChain>>;

type GetBlockNumberParameters = {
    /** The maximum age (in ms) of the cached value. */
    maxAge?: number;
};
type GetBlockNumberReturnType = bigint;
declare function getBlockNumberCache(id: string): {
    clear: () => void;
    promise: {
        clear: () => boolean;
        get: () => Promise<unknown> | undefined;
        set: (data: Promise<unknown>) => Map<string, Promise<unknown>>;
    };
    response: {
        clear: () => boolean;
        get: () => {
            created: Date;
            data: unknown;
        } | undefined;
        set: (data: {
            created: Date;
            data: unknown;
        }) => Map<string, {
            created: Date;
            data: unknown;
        }>;
    };
};
/**
 * @description Returns the number of the most recent block seen.
 */
declare function getBlockNumber(client: PublicClient<any, any, any>, { maxAge }?: GetBlockNumberParameters): Promise<GetBlockNumberReturnType>;

type GetBlockTransactionCountParameters = {
    /** Hash of the block. */
    blockHash?: Hash;
    blockNumber?: never;
    blockTag?: never;
} | {
    blockHash?: never;
    /** The block number. */
    blockNumber?: bigint;
    blockTag?: never;
} | {
    blockHash?: never;
    blockNumber?: never;
    /** The block tag. Defaults to 'latest'. */
    blockTag?: BlockTag;
};
type GetBlockTransactionCountReturnType = number;
declare function getBlockTransactionCount<TChain extends Chain>(client: PublicClient<any, TChain>, { blockHash, blockNumber, blockTag, }?: GetBlockTransactionCountParameters): Promise<GetBlockTransactionCountReturnType>;

type GetBytecodeParameters = {
    address: Address;
} & ({
    blockNumber?: never;
    blockTag?: BlockTag;
} | {
    blockNumber?: bigint;
    blockTag?: never;
});
type GetBytecodeReturnType = Hex | undefined;
declare function getBytecode(client: PublicClient, { address, blockNumber, blockTag }: GetBytecodeParameters): Promise<GetBytecodeReturnType>;

type GetFeeHistoryParameters = {
    blockCount: number;
    rewardPercentiles: number[];
} & ({
    blockNumber?: never;
    blockTag?: BlockTag;
} | {
    blockNumber?: bigint;
    blockTag?: never;
});
type GetFeeHistoryReturnType = FeeHistory;
/**
 * @description Returns a collection of historical gas information.
 */
declare function getFeeHistory(client: PublicClient, { blockCount, blockNumber, blockTag, rewardPercentiles, }: GetFeeHistoryParameters): Promise<GetFeeHistoryReturnType>;

type GetFilterChangesParameters<TFilterType extends FilterType = FilterType, TAbiEvent extends AbiEvent | undefined = undefined, TAbi extends Abi | readonly unknown[] = [TAbiEvent], TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = {
    filter: Filter<TFilterType, TAbi, TEventName, any>;
};
type GetFilterChangesReturnType<TFilterType extends FilterType = FilterType, TAbiEvent extends AbiEvent | undefined = undefined, TAbi extends Abi | readonly unknown[] = [TAbiEvent], TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = TFilterType extends 'event' ? Log<bigint, number, TAbiEvent, TAbi, TEventName>[] : Hash[];
declare function getFilterChanges<TFilterType extends FilterType, TAbiEvent extends AbiEvent | undefined, TAbi extends Abi | readonly unknown[], TEventName extends string | undefined>(client: PublicClient, { filter, }: GetFilterChangesParameters<TFilterType, TAbiEvent, TAbi, TEventName>): Promise<GetFilterChangesReturnType<TFilterType, TAbiEvent, TAbi, TEventName>>;

type GetFilterLogsParameters<TAbiEvent extends AbiEvent | undefined = undefined, TAbi extends Abi | readonly unknown[] = [TAbiEvent], TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = {
    filter: Filter<'event', TAbi, TEventName, any>;
};
type GetFilterLogsReturnType<TAbiEvent extends AbiEvent | undefined = undefined, TAbi extends Abi | readonly unknown[] = [TAbiEvent], TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = Log<bigint, number, TAbiEvent, TAbi, TEventName>[];
declare function getFilterLogs<TAbiEvent extends AbiEvent | undefined, TAbi extends Abi | readonly unknown[], TEventName extends string | undefined>(client: PublicClient, { filter }: GetFilterLogsParameters<TAbiEvent, TAbi, TEventName>): Promise<GetFilterLogsReturnType<TAbiEvent, TAbi, TEventName>>;

type GetGasPriceReturnType = bigint;
/**
 * @description Returns the current price of gas (in wei).
 */
declare function getGasPrice(client: PublicClient | WalletClient): Promise<GetGasPriceReturnType>;

type GetLogsParameters<TAbiEvent extends AbiEvent | undefined = undefined, TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = {
    /** Address or list of addresses from which logs originated */
    address?: Address | Address[];
} & ({
    event: TAbiEvent;
    args?: MaybeExtractEventArgsFromAbi<[TAbiEvent], TEventName>;
} | {
    event?: never;
    args?: never;
}) & ({
    /** Block number or tag after which to include logs */
    fromBlock?: BlockNumber<bigint> | BlockTag;
    /** Block number or tag before which to include logs */
    toBlock?: BlockNumber<bigint> | BlockTag;
    blockHash?: never;
} | {
    fromBlock?: never;
    toBlock?: never;
    /** Hash of block to include logs from */
    blockHash?: Hash;
});
type GetLogsReturnType<TAbiEvent extends AbiEvent | undefined = undefined, TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = Log<bigint, number, TAbiEvent, [TAbiEvent], TEventName>[];
/**
 * @description Returns a collection of event logs.
 */
declare function getLogs<TAbiEvent extends AbiEvent | undefined>(client: PublicClient, { address, blockHash, fromBlock, toBlock, event, args, }?: GetLogsParameters<TAbiEvent>): Promise<GetLogsReturnType<TAbiEvent>>;

type GetStorageAtParameters = {
    address: Address;
    slot: Hex;
} & ({
    blockNumber?: never;
    blockTag?: BlockTag;
} | {
    blockNumber?: bigint;
    blockTag?: never;
});
type GetStorageAtReturnType = Hex | undefined;
declare function getStorageAt(client: PublicClient, { address, blockNumber, blockTag, slot }: GetStorageAtParameters): Promise<GetStorageAtReturnType>;

type GetTransactionParameters = {
    /** The block hash */
    blockHash: Hash;
    blockNumber?: never;
    blockTag?: never;
    hash?: never;
    /** The index of the transaction on the block. */
    index: number;
} | {
    blockHash?: never;
    /** The block number */
    blockNumber: bigint;
    blockTag?: never;
    hash?: never;
    /** The index of the transaction on the block. */
    index: number;
} | {
    blockHash?: never;
    blockNumber?: never;
    /** The block tag. */
    blockTag: BlockTag;
    hash?: never;
    /** The index of the transaction on the block. */
    index: number;
} | {
    blockHash?: never;
    blockNumber?: never;
    blockTag?: never;
    /** The hash of the transaction. */
    hash: Hash;
    index?: number;
};
type GetTransactionReturnType<TChain extends Chain = Chain> = FormattedTransaction<TransactionFormatter<TChain>>;
/** @description Returns information about a transaction given a hash or block identifier. */
declare function getTransaction<TChain extends Chain>(client: PublicClient<any, TChain>, { blockHash, blockNumber, blockTag, hash, index, }: GetTransactionParameters): Promise<GetTransactionReturnType<TChain>>;

type GetTransactionConfirmationsParameters<TChain extends Chain = Chain> = {
    /** The transaction hash. */
    hash: Hash;
    transactionReceipt?: never;
} | {
    hash?: never;
    /** The transaction receipt. */
    transactionReceipt: FormattedTransactionReceipt<TransactionReceiptFormatter<TChain>>;
};
type GetTransactionConfirmationsReturnType = bigint;
declare function getTransactionConfirmations<TChain extends Chain>(client: PublicClient<any, TChain>, { hash, transactionReceipt }: GetTransactionConfirmationsParameters<TChain>): Promise<GetTransactionConfirmationsReturnType>;

type GetTransactionCountParameters = {
    /** The account address. */
    address: Address;
} & ({
    /** The block number. */
    blockNumber?: bigint;
    blockTag?: never;
} | {
    blockNumber?: never;
    /** The block tag. Defaults to 'latest'. */
    blockTag?: BlockTag;
});
type GetTransactionCountReturnType = number;
/**
 * @description Returns the number of transactions an account has broadcast / sent.
 */
declare function getTransactionCount(client: PublicClient | WalletClient, { address, blockTag, blockNumber }: GetTransactionCountParameters): Promise<GetTransactionCountReturnType>;

type GetTransactionReceiptParameters = {
    /** The hash of the transaction. */
    hash: Hash;
};
type GetTransactionReceiptReturnType<TChain extends Chain = Chain> = FormattedTransactionReceipt<TransactionReceiptFormatter<TChain>>;
declare function getTransactionReceipt<TChain extends Chain>(client: PublicClient<any, TChain>, { hash }: GetTransactionReceiptParameters): Promise<Formatted<ExtractFormatter<TChain, "transactionReceipt", Formatter<RpcTransactionReceipt, TransactionReceipt<bigint, number, "success" | "reverted", TransactionType>>>, TransactionReceipt<bigint, number, "success" | "reverted", TransactionType>, false, false>>;

type MAXIMUM_DEPTH = 20;
type Contract<TAbi extends Abi | readonly unknown[] = Abi | readonly unknown[], TFunctionName extends string = string> = {
    abi: TAbi;
    functionName: TFunctionName;
};
type MulticallContracts<TContracts extends Contract[], TProperties extends Record<string, any> = object, Result extends any[] = [], Depth extends ReadonlyArray<number> = []> = Depth['length'] extends MAXIMUM_DEPTH ? (ContractConfig & TProperties)[] : TContracts extends [] ? [] : TContracts extends [infer Head extends Contract] ? [
    ...Result,
    ContractConfig<Head['abi'], Head['functionName']> & TProperties
] : TContracts extends [
    infer Head extends Contract,
    ...infer Tail extends Contract[]
] ? MulticallContracts<[
    ...Tail
], TProperties, [
    ...Result,
    ContractConfig<Head['abi'], Head['functionName']> & TProperties
], [
    ...Depth,
    1
]> : unknown[] extends TContracts ? TContracts : TContracts extends ContractConfig<infer TAbi, infer TFunctionName>[] ? (ContractConfig<TAbi, TFunctionName> & TProperties)[] : (ContractConfig & TProperties)[];
type MulticallResult<Result, TAllowFailure extends boolean = true> = TAllowFailure extends true ? ({
    error?: undefined;
    result: Result;
    status: 'success';
} | {
    error: Error;
    result?: undefined;
    status: 'error';
}) : Result;
type MulticallResults<TContracts extends Contract[], TAllowFailure extends boolean = true, Result extends any[] = [], Depth extends ReadonlyArray<number> = []> = Depth['length'] extends MAXIMUM_DEPTH ? MulticallResult<ExtractResultFromAbi, TAllowFailure>[] : TContracts extends [] ? [] : TContracts extends [infer Head extends Contract] ? [...Result, MulticallResult<ExtractResultFromAbi<Head['abi'], Head['functionName']>, TAllowFailure>] : TContracts extends [
    infer Head extends Contract,
    ...infer Tail extends Contract[]
] ? MulticallResults<[
    ...Tail
], TAllowFailure, [
    ...Result,
    MulticallResult<ExtractResultFromAbi<Head['abi'], Head['functionName']>, TAllowFailure>
], [
    ...Depth,
    1
]> : TContracts extends ContractConfig<infer TAbi, infer TFunctionName>[] ? MulticallResult<ExtractResultFromAbi<TAbi, TFunctionName>, TAllowFailure>[] : MulticallResult<ExtractResultFromAbi, TAllowFailure>[];

type MulticallParameters<TContracts extends ContractConfig[] = ContractConfig[], TAllowFailure extends boolean = true> = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {
    allowFailure?: TAllowFailure;
    contracts: readonly [...MulticallContracts<TContracts>];
    multicallAddress: Address;
};
type MulticallReturnType<TContracts extends ContractConfig[] = ContractConfig[], TAllowFailure extends boolean = true> = MulticallResults<TContracts, TAllowFailure>;
declare function multicall<TContracts extends ContractConfig[], TAllowFailure extends boolean = true>(client: PublicClient, args: MulticallParameters<TContracts, TAllowFailure>): Promise<MulticallReturnType<TContracts, TAllowFailure>>;

type ReadContractParameters<TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string> = Pick<CallParameters, 'blockNumber' | 'blockTag'> & ContractConfig<TAbi, TFunctionName, 'view' | 'pure'>;
type ReadContractReturnType<TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string> = ExtractResultFromAbi<TAbi, TFunctionName>;
declare function readContract<TAbi extends Abi | readonly unknown[], TFunctionName extends string>(client: PublicClient, { abi, address, args, functionName, ...callRequest }: ReadContractParameters<TAbi, TFunctionName>): Promise<ReadContractReturnType<TAbi, TFunctionName>>;

type UninstallFilterParameters = {
    filter: Filter<any>;
};
type UninstallFilterReturnType = boolean;
declare function uninstallFilter(client: PublicClient, { filter }: UninstallFilterParameters): Promise<UninstallFilterReturnType>;

type ReplacementReason = 'cancelled' | 'replaced' | 'repriced';
type ReplacementReturnType<TChain extends Chain = Chain> = {
    reason: ReplacementReason;
    replacedTransaction: Transaction;
    transaction: Transaction;
    transactionReceipt: GetTransactionReceiptReturnType<TChain>;
};
type WaitForTransactionReceiptReturnType<TChain extends Chain = Chain> = GetTransactionReceiptReturnType<TChain>;
type WaitForTransactionReceiptParameters<TChain extends Chain = Chain> = {
    /** The number of confirmations (blocks that have passed) to wait before resolving. */
    confirmations?: number;
    /** The hash of the transaction. */
    hash: Hash;
    onReplaced?: (response: ReplacementReturnType<TChain>) => void;
    /** Polling frequency (in ms). Defaults to the client's pollingInterval config. */
    pollingInterval?: number;
    /** Optional timeout (in milliseconds) to wait before stopping polling. */
    timeout?: number;
};
declare function waitForTransactionReceipt<TChain extends Chain>(client: PublicClient<any, TChain>, { confirmations, hash, onReplaced, pollingInterval, timeout, }: WaitForTransactionReceiptParameters<TChain>): Promise<WaitForTransactionReceiptReturnType<TChain>>;

type OnBlockNumberParameter = GetBlockNumberReturnType;
type OnBlockNumberFn = (blockNumber: OnBlockNumberParameter, prevBlockNumber: OnBlockNumberParameter | undefined) => void;
type WatchBlockNumberParameters = {
    /** Whether or not to emit the missed block numbers to the callback. */
    emitMissed?: boolean;
    /** Whether or not to emit the latest block number to the callback when the subscription opens. */
    emitOnBegin?: boolean;
    /** The callback to call when a new block number is received. */
    onBlockNumber: OnBlockNumberFn;
    /** The callback to call when an error occurred when trying to get for a new block. */
    onError?: (error: Error) => void;
    /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */
    pollingInterval?: number;
};
/** @description Watches and returns incoming block numbers. */
declare function watchBlockNumber(client: PublicClient<any, any, any>, { emitOnBegin, emitMissed, onBlockNumber, onError, pollingInterval, }: WatchBlockNumberParameters): () => void;

type OnBlockParameter<TChain extends Chain = Chain, TIncludeTransactions = false> = Omit<GetBlockReturnType<TChain>, TIncludeTransactions extends false ? 'transactions' : ''>;
type OnBlock<TChain extends Chain = Chain, TIncludeTransactions = false> = (block: OnBlockParameter<TChain, TIncludeTransactions>, prevBlock: OnBlockParameter<TChain, TIncludeTransactions> | undefined) => void;
type WatchBlocksParameters<TChain extends Chain = Chain> = {
    /** The block tag. Defaults to "latest". */
    blockTag?: BlockTag;
    /** Whether or not to emit the missed blocks to the callback. */
    emitMissed?: boolean;
    /** Whether or not to emit the block to the callback when the subscription opens. */
    emitOnBegin?: boolean;
    /** The callback to call when an error occurred when trying to get for a new block. */
    onError?: (error: Error) => void;
    /** Polling frequency (in ms). Defaults to the client's pollingInterval config. */
    pollingInterval?: number;
} & ({
    /** Whether or not to include transaction data in the response. */
    includeTransactions: true;
    /** The callback to call when a new block is received. */
    onBlock: OnBlock<TChain, true>;
} | {
    /** Whether or not to include transaction data in the response. */
    includeTransactions?: false;
    /** The callback to call when a new block is received. */
    onBlock: OnBlock<TChain>;
});
/** @description Watches and returns information for incoming blocks. */
declare function watchBlocks<TChain extends Chain, TWatchBlocksParameters extends WatchBlocksParameters<TChain>>(client: PublicClient<any, TChain>, { blockTag, emitMissed, emitOnBegin, onBlock, onError, includeTransactions, pollingInterval, }: TWatchBlocksParameters): () => void;

type OnLogsParameter$1<TAbi extends Abi | readonly unknown[] = readonly unknown[], TEventName extends string = string> = TAbi extends Abi ? Log<bigint, number, ExtractAbiEvent<TAbi, TEventName>>[] : Log[];
type OnLogsFn$1<TAbi extends Abi | readonly unknown[] = readonly unknown[], TEventName extends string = string> = (logs: OnLogsParameter$1<TAbi, TEventName>) => void;
type WatchContractEventParameters<TAbi extends Abi | readonly unknown[] = readonly unknown[], TEventName extends string = string> = {
    /** The address of the contract. */
    address?: Address | Address[];
    /** Contract ABI. */
    abi: Narrow<TAbi>;
    args?: ExtractEventArgsFromAbi<TAbi, TEventName>;
    /** Whether or not the event logs should be batched on each invocation. */
    batch?: boolean;
    /** Contract event. */
    eventName?: ExtractEventNameFromAbi<TAbi, TEventName>;
    /** The callback to call when an error occurred when trying to get for a new block. */
    onError?: (error: Error) => void;
    /** The callback to call when new event logs are received. */
    onLogs: OnLogsFn$1<TAbi, TEventName>;
    /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */
    pollingInterval?: number;
};
declare function watchContractEvent<TAbi extends Abi | readonly unknown[], TEventName extends string>(client: PublicClient, { abi, address, args, batch, eventName, onError, onLogs, pollingInterval, }: WatchContractEventParameters<TAbi, TEventName>): () => void;

type OnLogsParameter<TAbiEvent extends AbiEvent | undefined = undefined, TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = Log<bigint, number, TAbiEvent, [TAbiEvent], TEventName>[];
type OnLogsFn<TAbiEvent extends AbiEvent | undefined = undefined, TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = (logs: OnLogsParameter<TAbiEvent, TEventName>) => void;
type WatchEventParameters<TAbiEvent extends AbiEvent | undefined = undefined, TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>> = {
    /** The address of the contract. */
    address?: Address | Address[];
    /** Whether or not the event logs should be batched on each invocation. */
    batch?: boolean;
    /** The callback to call when an error occurred when trying to get for a new block. */
    onError?: (error: Error) => void;
    /** The callback to call when new event logs are received. */
    onLogs: OnLogsFn<TAbiEvent, TEventName>;
    /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */
    pollingInterval?: number;
} & ({
    event: TAbiEvent;
    args?: MaybeExtractEventArgsFromAbi<[TAbiEvent], TEventName>;
} | {
    event?: never;
    args?: never;
});
declare function watchEvent<TAbiEvent extends AbiEvent | undefined, TEventName extends string | undefined>(client: PublicClient, { address, args, batch, event, onError, onLogs, pollingInterval, }: WatchEventParameters<TAbiEvent>): () => void;

type OnTransactionsParameter = Hash[];
type OnTransactionsFn = (transactions: OnTransactionsParameter) => void;
type WatchPendingTransactionsParameters = {
    /** Whether or not the transaction hashes should be batched on each invocation. */
    batch?: boolean;
    /** The callback to call when an error occurred when trying to get for a new block. */
    onError?: (error: Error) => void;
    /** The callback to call when new transactions are received. */
    onTransactions: OnTransactionsFn;
    /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */
    pollingInterval?: number;
};
declare function watchPendingTransactions(client: PublicClient, { batch, onError, onTransactions, pollingInterval, }: WatchPendingTransactionsParameters): () => void;

type Account = JsonRpcAccount | LocalAccount;
type JsonRpcAccount = {
    address: Address;
    type: 'json-rpc';
};
type LocalAccount = {
    address: Address;
    signMessage: (message: string) => Promise<Hash>;
    signTransaction: (transaction: Omit<TransactionRequest, 'from'> & {
        chainId: number;
        from: Address;
    }) => Promise<Hash>;
    type: 'local';
};

type FilterType = 'transaction' | 'block' | 'event';
type Filter<TFilterType extends FilterType = 'event', TAbi extends Abi | readonly unknown[] = Abi, TEventName extends string | undefined = undefined, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined = MaybeExtractEventArgsFromAbi<TAbi, TEventName>> = {
    id: Hex;
    type: TFilterType;
} & (TFilterType extends 'event' ? TAbi extends Abi ? undefined extends TEventName ? {
    abi: TAbi;
    args?: never;
    eventName?: never;
} : TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> ? {
    abi: TAbi;
    args: TArgs;
    eventName: TEventName;
} : {
    abi: TAbi;
    args?: never;
    eventName: TEventName;
} : {
    abi?: never;
    args?: never;
    eventName?: never;
} : {});

type GetEnsAddressParameters = Prettify<Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {
    /** ENS name to get address. */
    name: string;
    /** Address of ENS Universal Resolver Contract */
    universalResolverAddress?: Address;
}>;
type GetEnsAddressReturnType = Address;
/**
 * @description Gets address for ENS name.
 *
 * - Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.
 * - Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.
 *
 * @example
 * import { normalize } from 'viem/ens'
 *
 * const ensAddress = await getEnsAddress(publicClient, {
 *   name: normalize('wagmi-dev.eth'),
 * })
 * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'
 */
declare function getEnsAddress(client: PublicClient, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_, }: GetEnsAddressParameters): Promise<GetEnsAddressReturnType>;

type GetEnsNameParameters = Prettify<Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {
    /** Address to get ENS name for. */
    address: Address;
    /** Address of ENS Universal Resolver Contract. */
    universalResolverAddress?: Address;
}>;
type GetEnsNameReturnType = string | null;
/**
 * @description Gets primary name for specified address.
 *
 * - Calls `reverse(bytes)` on ENS Universal Resolver Contract.
 *
 * @example
 * const ensName = await getEnsName(publicClient, {
 *   address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
 * })
 * // 'wagmi-dev.eth'
 */
declare function getEnsName(client: PublicClient, { address, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_, }: GetEnsNameParameters): Promise<GetEnsNameReturnType>;

type PublicActions<TChain extends Chain = Chain> = {
    call: (args: CallParameters<TChain>) => Promise<CallReturnType>;
    createBlockFilter: () => Promise<CreateBlockFilterReturnType>;
    createContractEventFilter: <TAbi extends Abi | readonly unknown[], TEventName extends string | undefined, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined>(args: CreateContractEventFilterParameters<TAbi, TEventName, TArgs>) => Promise<CreateContractEventFilterReturnType<TAbi, TEventName, TArgs>>;
    createEventFilter: <TAbiEvent extends AbiEvent | undefined, TAbi extends Abi | readonly unknown[], TEventName extends string | undefined, TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined>(args?: CreateEventFilterParameters<TAbiEvent, TAbi, TEventName, TArgs>) => Promise<CreateEventFilterReturnType<TAbiEvent, TAbi, TEventName, TArgs>>;
    createPendingTransactionFilter: () => Promise<CreatePendingTransactionFilterReturnType>;
    estimateContractGas: <TChain extends Chain, TAbi extends Abi | readonly unknown[], TFunctionName extends string>(args: EstimateContractGasParameters<TChain, TAbi, TFunctionName>) => Promise<EstimateContractGasReturnType>;
    estimateGas: (args: EstimateGasParameters<TChain>) => Promise<EstimateGasReturnType>;
    getBalance: (args: GetBalanceParameters) => Promise<GetBalanceReturnType>;
    getBlock: (args?: GetBlockParameters) => Promise<GetBlockReturnType<TChain>>;
    getBlockNumber: (args?: GetBlockNumberParameters) => Promise<GetBlockNumberReturnType>;
    getBlockTransactionCount: (args?: GetBlockTransactionCountParameters) => Promise<GetBlockTransactionCountReturnType>;
    getBytecode: (args: GetBytecodeParameters) => Promise<GetBytecodeReturnType>;
    getChainId: () => Promise<GetChainIdReturnType>;
    getEnsAddress: (args: GetEnsAddressParameters) => Promise<GetEnsAddressReturnType>;
    getEnsName: (args: GetEnsNameParameters) => Promise<GetEnsNameReturnType>;
    getFeeHistory: (args: GetFeeHistoryParameters) => Promise<GetFeeHistoryReturnType>;
    getFilterChanges: <TFilterType extends FilterType, TAbiEvent extends AbiEvent | undefined, TAbi extends Abi | readonly unknown[], TEventName extends string | undefined>(args: GetFilterChangesParameters<TFilterType, TAbiEvent, TAbi, TEventName>) => Promise<GetFilterChangesReturnType<TFilterType, TAbiEvent, TAbi, TEventName>>;
    getFilterLogs: <TAbiEvent extends AbiEvent | undefined, TAbi extends Abi | readonly unknown[], TEventName extends string | undefined>(args: GetFilterLogsParameters<TAbiEvent, TAbi, TEventName>) => Promise<GetFilterLogsReturnType<TAbiEvent, TAbi, TEventName>>;
    getGasPrice: () => Promise<GetGasPriceReturnType>;
    getLogs: <TAbiEvent extends AbiEvent | undefined>(args?: GetLogsParameters<TAbiEvent>) => Promise<GetLogsReturnType<TAbiEvent>>;
    getStorageAt: (args: GetStorageAtParameters) => Promise<GetStorageAtReturnType>;
    getTransaction: (args: GetTransactionParameters) => Promise<GetTransactionReturnType<TChain>>;
    getTransactionConfirmations: (args: GetTransactionConfirmationsParameters<TChain>) => Promise<GetTransactionConfirmationsReturnType>;
    getTransactionCount: (args: GetTransactionCountParameters) => Promise<GetTransactionCountReturnType>;
    getTransactionReceipt: (args: GetTransactionReceiptParameters) => Promise<GetTransactionReceiptReturnType<TChain>>;
    multicall: <TContracts extends ContractConfig[], TAllowFailure extends boolean = true>(args: MulticallParameters<TContracts, TAllowFailure>) => Promise<MulticallReturnType<TContracts, TAllowFailure>>;
    readContract: <TAbi extends Abi | readonly unknown[], TFunctionName extends string>(args: ReadContractParameters<TAbi, TFunctionName>) => Promise<ReadContractReturnType<TAbi, TFunctionName>>;
    simulateContract: <TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = any, TChainOverride extends Chain | undefined = undefined>(args: SimulateContractParameters<TChain, TAbi, TFunctionName, TChainOverride>) => Promise<SimulateContractReturnType<TChainOverride extends Chain ? TChainOverride : TChain, TAbi, TFunctionName>>;
    uninstallFilter: (args: UninstallFilterParameters) => Promise<UninstallFilterReturnType>;
    waitForTransactionReceipt: (args: WaitForTransactionReceiptParameters<TChain>) => Promise<WaitForTransactionReceiptReturnType<TChain>>;
    watchBlockNumber: (args: WatchBlockNumberParameters) => ReturnType<typeof watchBlockNumber>;
    watchBlocks: (args: WatchBlocksParameters<TChain>) => ReturnType<typeof watchBlocks>;
    watchContractEvent: <TAbi extends Abi | readonly unknown[], TEventName extends string>(args: WatchContractEventParameters<TAbi, TEventName>) => ReturnType<typeof watchContractEvent>;
    watchEvent: <TAbiEvent extends AbiEvent | undefined, TEventName extends string | undefined>(args: WatchEventParameters<TAbiEvent>) => ReturnType<typeof watchEvent>;
    watchPendingTransactions: (args: WatchPendingTransactionsParameters) => ReturnType<typeof watchPendingTransactions>;
};

type WalletClientConfig<TTransport extends Transport = Transport, TChain extends Chain = Chain> = {
    chain?: ClientConfig<TTransport, TChain>['chain'];
    /** The key of the Wallet Client. */
    key?: ClientConfig['key'];
    /** The name of the Wallet Client. */
    name?: ClientConfig['name'];
    /** Frequency (in ms) for polling enabled actions & events. Defaults to 4_000 milliseconds. */
    pollingInterval?: ClientConfig['pollingInterval'];
    transport: ClientConfig<TTransport, TChain>['transport'];
};
type WalletClient<TTransport extends Transport = Transport, TChain extends Chain = Chain, TIncludeActions extends boolean = true> = Client<TTransport, TChain> & (TIncludeActions extends true ? WalletActions<TChain> : {});
/**
 * @description Creates a wallet client with a given transport.
 */
declare function createWalletClient<TTransport extends Transport, TChain extends Chain>({ transport, key, name, pollingInterval, }: WalletClientConfig<TTransport, TChain>): WalletClient<TTransport, TChain, true>;

type WalletActions<TChain extends Chain = Chain> = {
    addChain: (args: AddChainParameters) => Promise<void>;
    deployContract: <TAbi extends Abi | readonly unknown[]>(args: DeployContractParameters<TChain, TAbi>) => Promise<DeployContractReturnType>;
    getAddresses: () => Promise<GetAddressesReturnType>;
    getChainId: () => Promise<GetChainIdReturnType>;
    getPermissions: () => Promise<GetPermissionsReturnType>;
    requestAddresses: () => Promise<RequestAddressesReturnType>;
    requestPermissions: (args: RequestPermissionsParameters) => Promise<RequestPermissionsReturnType>;
    sendTransaction: <TChainOverride extends Chain>(args: SendTransactionParameters<TChainOverride>) => Promise<SendTransactionReturnType>;
    signMessage: (args: SignMessageParameters) => Promise<SignMessageReturnType>;
    switchChain: (args: SwitchChainParameters) => Promise<void>;
    watchAsset: (args: WatchAssetParameters) => Promise<WatchAssetReturnType>;
    writeContract: <TAbi extends Abi | readonly unknown[], TFunctionName extends string, TChainOverride extends Chain>(args: WriteContractParameters<TChainOverride, TAbi, TFunctionName>) => Promise<WriteContractReturnType>;
};

type PublicClientConfig<TTransport extends Transport = Transport, TChain extends Chain = Chain> = Pick<ClientConfig<TTransport, TChain>, 'chain' | 'key' | 'name' | 'pollingInterval' | 'transport'>;
type PublicClient<TTransport extends Transport = Transport, TChain extends Chain = Chain, TIncludeActions extends boolean = true> = Client<TTransport, TChain, PublicRequests> & (TIncludeActions extends true ? PublicActions<TChain> : {});
/**
 * @description Creates a public client with a given transport.
 */
declare function createPublicClient<TTransport extends Transport, TChain extends Chain>({ chain, key, name, transport, pollingInterval, }: PublicClientConfig<TTransport, TChain>): PublicClient<TTransport, TChain, true>;

export { writeContract as $, Account as A, BlockFormatter as B, CallParameters as C, estimateContractGas as D, EstimateGasParameters as E, FormattedBlock as F, GetBytecodeParameters as G, getBytecode as H, getStorageAt as I, JsonRpcAccount as J, multicall as K, LocalAccount as L, MulticallParameters as M, readContract as N, OnLogsFn as O, PublicClient as P, simulateContract as Q, ReadContractParameters as R, SendTransactionParameters as S, TransactionReceiptFormatter as T, watchContractEvent as U, DeployContractParameters as V, WalletClient as W, DeployContractReturnType as X, WriteContractParameters as Y, WriteContractReturnType as Z, deployContract as _, PublicClientConfig as a, OnTransactionsFn as a$, GetEnsAddressParameters as a0, GetEnsNameParameters as a1, getEnsAddress as a2, getEnsName as a3, call as a4, createBlockFilter as a5, createEventFilter as a6, createPendingTransactionFilter as a7, estimateGas as a8, getBalance as a9, GetBalanceParameters as aA, GetBalanceReturnType as aB, GetBlockParameters as aC, GetBlockNumberParameters as aD, GetBlockNumberReturnType as aE, GetBlockReturnType as aF, GetBlockTransactionCountParameters as aG, GetBlockTransactionCountReturnType as aH, GetFeeHistoryParameters as aI, GetFeeHistoryReturnType as aJ, GetFilterChangesParameters as aK, GetFilterChangesReturnType as aL, GetFilterLogsParameters as aM, GetFilterLogsReturnType as aN, GetGasPriceReturnType as aO, GetTransactionParameters as aP, GetTransactionConfirmationsParameters as aQ, GetTransactionConfirmationsReturnType as aR, GetTransactionCountParameters as aS, GetTransactionCountReturnType as aT, GetTransactionReceiptParameters as aU, GetTransactionReceiptReturnType as aV, GetTransactionReturnType as aW, OnBlock as aX, OnBlockNumberFn as aY, OnBlockNumberParameter as aZ, OnBlockParameter as a_, getBlock as aa, getBlockNumber as ab, getBlockNumberCache as ac, getBlockTransactionCount as ad, getChainId as ae, getFeeHistory as af, getFilterChanges as ag, getFilterLogs as ah, getLogs as ai, getGasPrice as aj, getTransaction as ak, getTransactionConfirmations as al, getTransactionCount as am, getTransactionReceipt as an, uninstallFilter as ao, waitForTransactionReceipt as ap, watchBlockNumber as aq, watchBlocks as ar, watchEvent as as, watchPendingTransactions as at, CallReturnType as au, CreateBlockFilterReturnType as av, CreateEventFilterParameters as aw, CreateEventFilterReturnType as ax, CreatePendingTransactionFilterReturnType as ay, EstimateGasReturnType as az, WalletClientConfig as b, OnTransactionsParameter as b0, ReplacementReason as b1, ReplacementReturnType as b2, UninstallFilterParameters as b3, UninstallFilterReturnType as b4, WaitForTransactionReceiptParameters as b5, WaitForTransactionReceiptReturnType as b6, WatchBlockNumberParameters as b7, WatchBlocksParameters as b8, WatchPendingTransactionsParameters as b9, addChain as ba, getAddresses as bb, getPermissions as bc, requestAddresses as bd, requestPermissions as be, sendTransaction as bf, signMessage as bg, switchChain as bh, watchAsset as bi, AddChainParameters as bj, FormattedTransactionRequest as bk, GetPermissionsReturnType as bl, GetAddressesReturnType as bm, RequestAddressesReturnType as bn, RequestPermissionsReturnType as bo, SendTransactionReturnType as bp, SignMessageParameters as bq, SignMessageReturnType as br, SwitchChainParameters as bs, WatchAssetParameters as bt, WatchAssetReturnType as bu, createPublicClient as c, createWalletClient as d, FormattedTransactionReceipt as e, FormattedTransactionRequest$1 as f, TransactionRequestFormatter as g, defineBlock as h, defineTransactionReceipt as i, defineTransactionRequest as j, formatBlock as k, formatTransactionRequest as l, CreateContractEventFilterParameters as m, CreateContractEventFilterReturnType as n, EstimateContractGasParameters as o, EstimateContractGasReturnType as p, GetBytecodeReturnType as q, GetStorageAtParameters as r, GetStorageAtReturnType as s, MulticallReturnType as t, OnLogsParameter as u, ReadContractReturnType as v, SimulateContractParameters as w, SimulateContractReturnType as x, WatchContractEventParameters as y, createContractEventFilter as z };
