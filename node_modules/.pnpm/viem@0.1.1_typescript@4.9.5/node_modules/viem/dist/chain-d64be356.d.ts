import { Chain as Chain$1 } from '@wagmi/chains';
import { Address, Abi, AbiFunction, ExtractAbiFunction, AbiParametersToPrimitiveTypes, AbiError, ExtractAbiError, AbiEvent, ExtractAbiEvent, ExtractAbiErrorNames, ExtractAbiEventNames, AbiStateMutability, ExtractAbiFunctionNames, Narrow, AbiParameter, AbiParameterToPrimitiveType } from 'abitype';

type ByteArray = Uint8Array;
type Hex = `0x${string}`;
type Hash = `0x${string}`;
type LogTopic = Hex | Hex[] | null;

declare module 'abitype' {
    interface Config {
        BytesType: {
            inputs: Hex;
            outputs: Hex;
        };
    }
}

type ExtractFormatter<TChain extends Chain, TKey extends keyof NonNullable<TChain['formatters']>, TFallbackFormatter extends Formatter = Formatter> = NonNullable<TChain['formatters']>[TKey] extends NonNullable<unknown> ? NonNullable<TChain['formatters']>[TKey] : TFallbackFormatter;
type FormatOptions<TSource, TTarget> = {
    formatter: Formatter<TSource, TTarget>;
};
/**
 * Creates a type that is the result of applying `TFormatter` to `TSource`.
 *
 * @example
 * Formatted<() => { a: undefined, b: bigint }, { a: bigint }>
 * => { a: undefined, b: bigint }
 *
 * @example
 * Formatted<() => {}, { a: bigint }>
 * => { a: bigint }
 *
 * @example
 * Formatted<() => { a: bigint | undefined, b: bigint }, { a: bigint, b: bigint }, true>
 * => { a?: bigint | undefined, b: bigint }
 */
type Formatted<TFormatter, TFallback, TAllowOptional = false, TUseParameters = false> = TFormatter extends Formatter ? ReturnType<TFormatter> extends Record<string, never> ? TFallback : TAllowOptional extends true ? OptionalNullable<TUseParameters extends true ? Parameters<TFormatter>[0] : ReturnType<TFormatter>> : TUseParameters extends true ? Parameters<TFormatter>[0] : ReturnType<TFormatter> : never;
/**
 * @description Formats a data object using the given replacer and an optional formatter.
 */
declare function format<TFormatter, TSource extends Record<string, any>, TTarget>(data: TSource, { formatter }: FormatOptions<TSource, TTarget>): Formatted<TFormatter, TTarget, false, false>;
declare function defineFormatter<TSource extends Record<string, unknown>, TFormatted>({ format, }: {
    format: (data: TSource) => TFormatted;
}): <TFormat extends Formatter<TSource, Partial<TFormatted> & {
    [key: string]: unknown;
}>, TExclude extends (keyof TSource)[] = []>({ exclude, format: formatOverride, }: {
    exclude?: TExclude | undefined;
    format?: TFormat | undefined;
}) => (data: TSource & {
    [key: string]: unknown;
}) => TFormatted & ReturnType<TFormat> & { [K in TExclude[number]]: never; };

type TransactionFormatter<TChain extends Chain = Chain> = ExtractFormatter<TChain, 'transaction', NonNullable<Formatters['transaction']>>;
type FormattedTransaction<TFormatter extends Formatter | undefined = Formatter> = Formatted<TFormatter, Transaction>;
declare const transactionType: {
    readonly '0x0': "legacy";
    readonly '0x1': "eip2930";
    readonly '0x2': "eip1559";
};
declare function formatTransaction(transaction: Partial<RpcTransaction>): Transaction<bigint, number>;
declare const defineTransaction: <TFormat extends Formatter<Partial<RpcTransaction>, Partial<Transaction<bigint, number>> & {
    [key: string]: unknown;
}>, TExclude extends ("type" | "value" | "blockHash" | "blockNumber" | "from" | "gasPrice" | "maxFeePerGas" | "maxPriorityFeePerGas" | "gas" | "nonce" | "to" | "accessList" | "chainId" | "hash" | "input" | "r" | "s" | "transactionIndex" | "v")[] = []>({ exclude, format: formatOverride, }: {
    exclude?: TExclude | undefined;
    format?: TFormat | undefined;
}) => (data: Partial<RpcTransaction> & {
    [key: string]: unknown;
}) => Transaction<bigint, number> & ReturnType<TFormat> & { [K in TExclude[number]]: never; };

type Block<TQuantity = bigint, TTransaction = Transaction> = {
    /** Base fee per gas */
    baseFeePerGas: TQuantity | null;
    /** Difficulty for this block */
    difficulty: TQuantity;
    /** "Extra data" field of this block */
    extraData: Hex;
    /** Maximum gas allowed in this block */
    gasLimit: TQuantity;
    /** Total used gas by all transactions in this block */
    gasUsed: TQuantity;
    /** Block hash or `null` if pending */
    hash: Hash | null;
    /** Logs bloom filter or `null` if pending */
    logsBloom: Hex | null;
    /** Address that received this block’s mining rewards */
    miner: Address;
    /** Unique identifier for the block. */
    mixHash: Hash;
    /** Proof-of-work hash or `null` if pending */
    nonce: Hex | null;
    /** Block number or `null` if pending */
    number: TQuantity | null;
    /** Parent block hash */
    parentHash: Hash;
    /** Root of the this block’s receipts trie */
    receiptsRoot: Hex;
    sealFields: Hex[];
    /** SHA3 of the uncles data in this block */
    sha3Uncles: Hash;
    /** Size of this block in bytes */
    size: TQuantity;
    /** Root of this block’s final state trie */
    stateRoot: Hash;
    /** Unix timestamp of when this block was collated */
    timestamp: TQuantity;
    /** Total difficulty of the chain until this block */
    totalDifficulty: TQuantity | null;
    /** List of transaction objects or hashes */
    transactions: Hash[] | TTransaction[];
    /** Root of this block’s transaction trie */
    transactionsRoot: Hash;
    /** List of uncle hashes */
    uncles: Hash[];
};
type BlockIdentifier<TQuantity = bigint> = {
    /** Whether or not to throw an error if the block is not in the canonical chain as described below. Only allowed in conjunction with the blockHash tag. Defaults to false. */
    requireCanonical?: boolean;
} & ({
    /** The block in the canonical chain with this number */
    blockNumber: BlockNumber<TQuantity>;
} | {
    /** The block uniquely identified by this hash. The `blockNumber` and `blockHash` properties are mutually exclusive; exactly one of them must be set. */
    blockHash: Hash;
});
type BlockNumber<TQuantity = bigint> = TQuantity;
type BlockTag = 'latest' | 'earliest' | 'pending' | 'safe' | 'finalized';
type Uncle<TQuantity = bigint, TTransaction = Transaction> = Block<TQuantity, TTransaction>;

type FeeHistory<TQuantity = bigint> = {
    /**
     * An array of block base fees per gas (in wei). This includes the next block after
     * the newest of the returned range, because this value can be derived from the newest block.
     * Zeroes are returned for pre-EIP-1559 blocks. */
    baseFeePerGas: TQuantity[];
    /** An array of block gas used ratios. These are calculated as the ratio of gasUsed and gasLimit. */
    gasUsedRatio: number[];
    /** Lowest number block of the returned range. */
    oldestBlock: TQuantity;
    /** An array of effective priority fees (in wei) per gas data points from a single block. All zeroes are returned if the block is empty. */
    reward?: TQuantity[][];
};
type FeeValuesLegacy<TQuantity = bigint> = {
    /** Base fee per gas. */
    gasPrice: TQuantity;
    maxFeePerGas?: never;
    maxPriorityFeePerGas?: never;
};
type FeeValuesEIP1559<TQuantity = bigint> = {
    gasPrice?: never;
    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */
    maxFeePerGas: TQuantity;
    /** Max priority fee per gas (in wei). */
    maxPriorityFeePerGas: TQuantity;
};
type FeeValues<TQuantity = bigint> = FeeValuesLegacy<TQuantity> | FeeValuesEIP1559<TQuantity>;

/**
 * @description Excludes empty attributes from T if TMaybeExclude is true.
 *
 * @example
 * MaybeExcludeEmpty<{ a: string, b: number, c: [] }, true>
 * => { a: string, b: number }
 *
 * MaybeExcludeEmpty<{ a: string, b: number, c: [] }, false>
 * => { a: string, b: number, c: [] }
 *
 * MaybeExcludeEmpty<{ a: string, b: number, c: undefined }, true>
 * => { a: string, b: number }
 */
type MaybeExcludeEmpty<T, TMaybeExclude extends boolean> = TMaybeExclude extends true ? Exclude<T, [] | null | undefined> : T;
/**
 * @description Makes attributes on the type T required if TRequired is true.
 *
 * @example
 * MaybeRequired<{ a: string, b?: number }, true>
 * => { a: string, b: number }
 *
 * MaybeRequired<{ a: string, b?: number }, false>
 * => { a: string, b?: number }
 */
type MaybeRequired<T, TRequired extends boolean> = TRequired extends true ? Required<T> : T;
/**
 * @description Merges the intersection properties of T and U.
 *
 * @example
 * MergeIntersectionProperties<{ a: string, b: number }, { a: number, c: boolean }>
 * => { a: number, b: number }
 */
type MergeIntersectionProperties<T, U> = {
    [K in keyof T as K extends keyof U ? U[K] extends void ? never : K : K]: K extends keyof U ? U[K] : T[K];
};
/**
 * @description Makes nullable properties from T optional.
 *
 * @example
 * OptionalNullable<{ a: string | undefined, c: number }>
 * => { a?: string | undefined, c: number }
 */
type OptionalNullable<T> = {
    [K in keyof T as T[K] extends NonNullable<unknown> ? K : never]: T[K];
} & {
    [K in keyof T as T[K] extends NonNullable<unknown> ? never : K]?: T[K];
};
/**
 * @description Constructs a type by excluding `undefined` from `T`.
 *
 * @example
 * NoUndefined<string | undefined>
 * => string
 */
type NoUndefined<T> = T extends undefined ? never : T;
/**
 * @description Combines members of an intersection into a readable type.
 *
 * @link https://twitter.com/mattpocockuk/status/1622730173446557697?s=20&t=NdpAcmEFXY01xkqU3KO0Mg
 * @example
 * Prettify<{ a: string } | { b: string } | { c: number, d: bigint }>
 * => { a: string, b: string, c: number, d: bigint }
 */
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
/**
 * @description Creates a type that extracts the values of T.
 *
 * @example
 * ValueOf<{ a: string, b: number }>
 * => string | number
 */
type ValueOf<T> = T[keyof T];

type EventParametersConfig = {
    enableUnion: boolean;
    indexedOnly: boolean;
    required: boolean;
};
type EventParametersDefaultConfig = {
    enableUnion: true;
    indexedOnly: true;
    required: false;
};
type AbiItem = Abi[number];
type EventDefinition = `${string}(${string})`;
type HashedEventTypes = 'string' | 'bytes' | 'tuple' | `${string}[${string}]`;
type EventTopicParam<TPrimitiveType = Hex, TTopic extends LogTopic = LogTopic> = NoUndefined<(TTopic extends Hex ? TPrimitiveType : undefined) | (TTopic extends Hex[] ? TPrimitiveType[] : undefined) | (TTopic extends null ? null : undefined)>;
type AbiEventParameterToPrimitiveType<TParam extends AbiParameter, TConfig extends EventParametersConfig = EventParametersDefaultConfig> = TConfig extends {
    enableUnion: true;
} ? EventTopicParam<AbiParameterToPrimitiveType<TParam>> : AbiParameterToPrimitiveType<TParam>;
type AbiEventParametersToPrimitiveTypes<TAbiParameters extends readonly AbiParameter[], TConfig extends EventParametersConfig = EventParametersDefaultConfig, TBase = TAbiParameters[0] extends {
    name: string;
} ? {} : []> = Prettify<TAbiParameters extends readonly [infer Head, ...infer Tail] ? Head extends {
    indexed: true;
} ? Head extends AbiParameter ? Head extends {
    name: infer Name;
} ? Name extends string ? MaybeRequired<{
    [name in Name]?: AbiEventParameterToPrimitiveType<Head, TConfig>;
}, TConfig['required']> & (Tail extends readonly [] ? {} : Tail extends readonly AbiParameter[] ? AbiEventParametersToPrimitiveTypes<Tail, TConfig> : {}) : never : MaybeExcludeEmpty<(TConfig extends {
    enableUnion: true;
} ? [AbiEventParameterToPrimitiveType<Head, TConfig>] : []) | [
    AbiEventParameterToPrimitiveType<Head, TConfig>,
    ...(Tail extends readonly [] ? [] : Tail extends readonly AbiParameter[] ? AbiEventParametersToPrimitiveTypes<Tail, TConfig> : [])
], TConfig['required']> : TBase : TConfig extends {
    indexedOnly: false;
} ? Head extends AbiParameter ? Head extends {
    name: infer Name;
} ? Name extends string ? {
    [name in Name]: AbiParameterToPrimitiveType<Head>;
} & (Tail extends readonly [] ? {} : Tail extends readonly AbiParameter[] ? AbiEventParametersToPrimitiveTypes<Tail, TConfig> : {}) : never : [
    AbiParameterToPrimitiveType<Head>,
    ...(Tail extends readonly [] ? [] : Tail extends readonly AbiParameter[] ? AbiEventParametersToPrimitiveTypes<Tail, TConfig> : [])
] : TBase : Tail extends readonly [] ? TBase : Tail extends readonly AbiParameter[] ? AbiEventParametersToPrimitiveTypes<Tail, TConfig> : TBase : TBase>;
type AbiEventTopicToPrimitiveType<TParam extends AbiParameter, TTopic extends LogTopic, TPrimitiveType = TParam['type'] extends HashedEventTypes ? TTopic : AbiParameterToPrimitiveType<TParam>> = EventTopicParam<TPrimitiveType, TTopic>;
type AbiEventTopicsToPrimitiveTypes<TAbiParameters extends readonly AbiParameter[], TTopics extends LogTopic[] | undefined = undefined, TData extends Hex | undefined = undefined, TBase = TAbiParameters[0] extends {
    name: string;
} ? {} : []> = Prettify<TAbiParameters extends readonly [infer Head, ...infer Tail] ? TTopics extends readonly [infer TopicHead, ...infer TopicTail] ? Head extends {
    indexed: true;
} ? Head extends AbiParameter ? Head extends {
    name: infer Name;
} ? Name extends string ? {
    [name in Name]: TopicHead extends LogTopic ? AbiEventTopicToPrimitiveType<Head, TopicHead> : never;
} & (Tail extends readonly [] ? {} : Tail extends readonly AbiParameter[] ? TopicTail extends LogTopic[] ? AbiEventTopicsToPrimitiveTypes<Tail, TopicTail, TData> : {} : {}) : never : [
    TopicHead extends LogTopic ? AbiEventTopicToPrimitiveType<Head, TopicHead> : never,
    ...(Tail extends readonly [] ? [] : Tail extends readonly AbiParameter[] ? TopicTail extends LogTopic[] ? AbiEventTopicsToPrimitiveTypes<Tail, TopicTail, TData> : [] : [])
] : TBase : TBase : TTopics extends readonly [] ? TData extends '0x' ? TBase : TData extends Hex ? Head extends AbiParameter ? Head extends {
    indexed: true;
} ? Tail extends readonly AbiParameter[] ? AbiEventTopicsToPrimitiveTypes<Tail, [], TData> : TBase : Head extends {
    name: infer Name;
} ? Name extends string ? {
    [name in Name]: AbiParameterToPrimitiveType<Head>;
} & (Tail extends readonly [] ? {} : Tail extends readonly AbiParameter[] ? AbiEventTopicsToPrimitiveTypes<Tail, [], TData> : {}) : never : [
    AbiParameterToPrimitiveType<Head>,
    ...(Tail extends readonly [] ? [] : Tail extends readonly AbiParameter[] ? AbiEventTopicsToPrimitiveTypes<Tail, [], TData> : [])
] : TBase : TBase : TBase : undefined>;
type ExtractArgsFromAbi<TAbi extends Abi | readonly unknown[], TFunctionName extends string, TAbiFunction extends AbiFunction & {
    type: 'function';
} = TAbi extends Abi ? ExtractAbiFunction<TAbi, TFunctionName> : AbiFunction & {
    type: 'function';
}, TArgs = AbiParametersToPrimitiveTypes<TAbiFunction['inputs']>, FailedToParseArgs = ([TArgs] extends [never] ? true : false) | (readonly unknown[] extends TArgs ? true : false)> = true extends FailedToParseArgs ? {
    /**
     * Arguments to pass contract method
     *
     * Use a [const assertion](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) on {@link abi} for type inference.
     */
    args?: readonly unknown[];
} : TArgs extends readonly [] ? {
    args?: never;
} : {
    /** Arguments to pass contract method */ args: TArgs;
};
type ExtractConstructorArgsFromAbi<TAbi extends Abi | readonly unknown[], TAbiFunction extends AbiFunction & {
    type: 'constructor';
} = TAbi extends Abi ? Extract<TAbi[number], {
    type: 'constructor';
}> : AbiFunction & {
    type: 'constructor';
}, TArgs = AbiParametersToPrimitiveTypes<TAbiFunction['inputs']>, FailedToParseArgs = ([TArgs] extends [never] ? true : false) | (readonly unknown[] extends TArgs ? true : false)> = true extends FailedToParseArgs ? {
    /**
     * Arguments to pass contract method
     *
     * Use a [const assertion](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) on {@link abi} for type inference.
     */
    args?: readonly unknown[];
} : TArgs extends readonly [] ? {
    args?: never;
} : {
    /** Arguments to pass contract method */ args: TArgs;
};
type ExtractErrorArgsFromAbi<TAbi extends Abi | readonly unknown[], TErrorName extends string, TAbiError extends AbiError = TAbi extends Abi ? ExtractAbiError<TAbi, TErrorName> : AbiError, TArgs = AbiParametersToPrimitiveTypes<TAbiError['inputs']>, FailedToParseArgs = ([TArgs] extends [never] ? true : false) | (readonly unknown[] extends TArgs ? true : false)> = true extends FailedToParseArgs ? {
    /**
     * Arguments to pass contract method
     *
     * Use a [const assertion](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) on {@link abi} for type inference.
     */
    args?: readonly unknown[];
} : TArgs extends readonly [] ? {
    args?: never;
} : {
    /** Arguments to pass contract method */ args: TArgs;
};
type ExtractEventArgsFromAbi<TAbi extends Abi | readonly unknown[], TEventName extends string, TConfig extends EventParametersConfig = EventParametersDefaultConfig, TAbiEvent extends AbiEvent & {
    type: 'event';
} = TAbi extends Abi ? ExtractAbiEvent<TAbi, TEventName> : AbiEvent & {
    type: 'event';
}, TArgs = AbiEventParametersToPrimitiveTypes<TAbiEvent['inputs'], TConfig>, FailedToParseArgs = ([TArgs] extends [never] ? true : false) | (readonly unknown[] extends TArgs ? true : false)> = true extends FailedToParseArgs ? readonly unknown[] : TArgs extends readonly [] ? never : TArgs;
type ExtractEventArgsFromTopics<TAbi extends Abi | readonly unknown[], TEventName extends string, TTopics extends LogTopic[], TData extends Hex | undefined, TAbiEvent extends AbiEvent & {
    type: 'event';
} = TAbi extends Abi ? ExtractAbiEvent<TAbi, TEventName> : AbiEvent & {
    type: 'event';
}, TArgs = AbiEventTopicsToPrimitiveTypes<TAbiEvent['inputs'], TTopics, TData>> = TTopics extends readonly [] ? TData extends undefined ? {
    args?: never;
} : {
    args?: TArgs;
} : {
    args?: TArgs;
};
type ExtractErrorNameFromAbi<TAbi extends Abi | readonly unknown[] = Abi, TErrorName extends string = string> = TAbi extends Abi ? ExtractAbiErrorNames<TAbi> extends infer AbiErrorNames ? AbiErrorNames | (TErrorName extends AbiErrorNames ? TErrorName : never) | (Abi extends TAbi ? string : never) : never : TErrorName;
type ExtractEventNameFromAbi<TAbi extends Abi | readonly unknown[] = Abi, TEventName extends string | undefined = string> = TAbi extends Abi ? ExtractAbiEventNames<TAbi> extends infer AbiEventNames ? AbiEventNames | (TEventName extends AbiEventNames ? TEventName : never) : never : TEventName;
type ExtractFunctionNameFromAbi<TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string, TAbiStateMutability extends AbiStateMutability = AbiStateMutability> = TAbi extends Abi ? ExtractAbiFunctionNames<TAbi, TAbiStateMutability> extends infer AbiFunctionNames ? AbiFunctionNames | (TFunctionName extends AbiFunctionNames ? TFunctionName : never) | (Abi extends TAbi ? string : never) : never : TFunctionName;
type ExtractNames<TAbi extends Abi> = ExtractAbiFunctionNames<TAbi> | ExtractAbiEventNames<TAbi> | ExtractAbiErrorNames<TAbi>;
type ExtractNameFromAbi<TAbi extends Abi | readonly unknown[] = Abi, TName extends string = string> = TAbi extends Abi ? ExtractNames<TAbi> extends infer AbiNames ? AbiNames | (TName extends AbiNames ? TName : never) | (Abi extends TAbi ? string : never) : never : TName;
type ExtractResultFromAbi<TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string, TAbiFunction extends AbiFunction & {
    type: 'function';
} = TAbi extends Abi ? ExtractAbiFunction<TAbi, TFunctionName> : AbiFunction & {
    type: 'function';
}, TArgs = AbiParametersToPrimitiveTypes<TAbiFunction['outputs']>, FailedToParseArgs = ([TArgs] extends [never] ? true : false) | (readonly unknown[] extends TArgs ? true : false)> = true extends FailedToParseArgs ? unknown : TArgs extends readonly [] ? void : TArgs extends readonly [infer Arg] ? Arg : TArgs;
type MaybeAbiEventName<TAbiEvent extends AbiEvent | undefined> = TAbiEvent extends AbiEvent ? TAbiEvent['name'] : undefined;
type MaybeExtractEventArgsFromAbi<TAbi extends Abi | readonly unknown[] = Abi, TEventName extends string | undefined = undefined> = TEventName extends string ? ExtractEventArgsFromAbi<TAbi, TEventName> : undefined;
type ContractConfig<TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string, TAbiStateMutability extends AbiStateMutability = AbiStateMutability> = {
    /** Contract ABI */
    abi: Narrow<TAbi>;
    /** Contract address */
    address: Address;
    /** Function to invoke on the contract */
    functionName: ExtractFunctionNameFromAbi<TAbi, TFunctionName, TAbiStateMutability>;
} & ExtractArgsFromAbi<TAbi, TFunctionName>;
type GetValue<TAbi extends Abi | readonly unknown[], TFunctionName extends string, TValueType = TransactionRequest['value'], TAbiFunction extends AbiFunction & {
    type: 'function';
} = TAbi extends Abi ? ExtractAbiFunction<TAbi, TFunctionName> : AbiFunction & {
    type: 'function';
}> = TAbiFunction['stateMutability'] extends 'payable' ? TValueType : TAbiFunction['payable'] extends true ? TValueType : never;

type TopicFilter = (null | string | string[])[];
type DecodedAbiEvent<TAbiEvent extends AbiEvent | undefined = undefined, TAbi extends Abi | readonly unknown[] = [TAbiEvent], TEventName extends string | undefined = TAbiEvent extends AbiEvent ? TAbiEvent['name'] : undefined> = TAbi extends Abi ? TEventName extends string ? {
    args: ExtractEventArgsFromAbi<TAbi, TEventName, {
        enableUnion: false;
        indexedOnly: false;
        required: true;
    }>;
    /** The event name decoded from `topics`. */
    eventName: TEventName;
} : {
    args: ExtractEventArgsFromAbi<TAbi, string, {
        enableUnion: false;
        indexedOnly: false;
        required: true;
    }>;
    /** The event name decoded from `topics`. */
    eventName: ExtractAbiEventNames<TAbi>;
} : {};
type Log<TQuantity = bigint, TIndex = number, TAbiEvent extends AbiEvent | undefined = undefined, TAbi extends Abi | readonly unknown[] = [TAbiEvent], TEventName extends string | undefined = TAbiEvent extends AbiEvent ? TAbiEvent['name'] : undefined> = {
    /** The address from which this log originated */
    address: Address;
    /** Hash of block containing this log or `null` if pending */
    blockHash: Hash | null;
    /** Number of block containing this log or `null` if pending */
    blockNumber: TQuantity | null;
    /** Contains the non-indexed arguments of the log */
    data: Hex;
    /** Index of this log within its block or `null` if pending */
    logIndex: TIndex | null;
    /** Hash of the transaction that created this log or `null` if pending */
    transactionHash: Hash | null;
    /** Index of the transaction that created this log or `null` if pending */
    transactionIndex: TIndex | null;
    /** List of order-dependent topics */
    topics: TopicFilter;
    /** `true` if this filter has been destroyed and is invalid */
    removed: boolean;
} & DecodedAbiEvent<TAbiEvent, TAbi, TEventName>;

type Index = `0x${string}`;
type Quantity = `0x${string}`;
type Status = '0x0' | '0x1';
type TransactionType$1 = '0x0' | '0x1' | '0x2';
type RpcBlock = Block<Quantity, RpcTransaction>;
type RpcBlockNumber = BlockNumber<Quantity>;
type RpcBlockIdentifier = BlockIdentifier<Quantity>;
type RpcUncle = Uncle<Quantity>;
type RpcFeeHistory = FeeHistory<Quantity>;
type RpcFeeValues = FeeValues<Quantity>;
type RpcLog = Log<Quantity, Index>;
type RpcTransactionReceipt = TransactionReceipt<Quantity, Index, Status, TransactionType$1>;
type RpcTransactionRequest = TransactionRequest<Quantity, Index>;
type RpcTransaction = TransactionLegacy<Quantity, Index, '0x0'> | TransactionEIP2930<Quantity, Index, '0x1'> | TransactionEIP1559<Quantity, Index, '0x2'>;

type AccessList = {
    address: Address;
    storageKeys: Hex[];
}[];
type TransactionType = ValueOf<typeof transactionType>;
type TransactionReceipt<TQuantity = bigint, TIndex = number, TStatus = 'success' | 'reverted', TType = TransactionType> = {
    /** Hash of block containing this transaction */
    blockHash: Hash;
    /** Number of block containing this transaction */
    blockNumber: TQuantity;
    /** Address of new contract or `null` if no contract was created */
    contractAddress: Address | null;
    /** Gas used by this and all preceding transactions in this block */
    cumulativeGasUsed: TQuantity;
    /** Pre-London, it is equal to the transaction's gasPrice. Post-London, it is equal to the actual gas price paid for inclusion. */
    effectiveGasPrice: TQuantity;
    /** Transaction sender */
    from: Address;
    /** Gas used by this transaction */
    gasUsed: TQuantity;
    /** List of log objects generated by this transaction */
    logs: Log<TQuantity, TIndex>[];
    /** Logs bloom filter */
    logsBloom: Hex;
    /** `1` if this transaction was successful or `0` if it failed */
    status: TStatus;
    /** Transaction recipient or `null` if deploying a contract */
    to: Address | null;
    /** Hash of this transaction */
    transactionHash: Hash;
    /** Index of this transaction in the block */
    transactionIndex: TIndex;
    /** Transaction type */
    type: TType;
};
type TransactionBase<TQuantity = bigint, TIndex = number> = {
    /** Hash of block containing this transaction or `null` if pending */
    blockHash: Hash | null;
    /** Number of block containing this transaction or `null` if pending */
    blockNumber: TQuantity | null;
    /** Chain ID. */
    chainId: TIndex;
    /** Transaction sender */
    from: Address;
    /** Gas provided for transaction execution */
    gas: TQuantity;
    /** Hash of this transaction */
    hash: Hash;
    /** Contract code or a hashed method call */
    input: Hex;
    /** Unique number identifying this transaction */
    nonce: TIndex;
    /** ECDSA signature r */
    r: Hex;
    /** ECDSA signature s */
    s: Hex;
    /** Transaction recipient or `null` if deploying a contract */
    to: Address | null;
    /** Index of this transaction in the block or `null` if pending */
    transactionIndex: TIndex | null;
    /** ECDSA recovery ID */
    v: TQuantity;
    /** Value in wei sent with this transaction */
    value: TQuantity;
};
type TransactionLegacy<TQuantity = bigint, TIndex = number, TType = 'legacy'> = TransactionBase<TQuantity, TIndex> & FeeValuesLegacy<TQuantity> & {
    accessList?: never;
    type: TType;
};
type TransactionEIP2930<TQuantity = bigint, TIndex = number, TType = 'eip2930'> = TransactionBase<TQuantity, TIndex> & FeeValuesLegacy<TQuantity> & {
    accessList: AccessList;
    type: TType;
};
type TransactionEIP1559<TQuantity = bigint, TIndex = number, TType = 'eip1559'> = TransactionBase<TQuantity, TIndex> & FeeValuesEIP1559<TQuantity> & {
    accessList: AccessList;
    type: TType;
};
type Transaction<TQuantity = bigint, TIndex = number> = TransactionLegacy<TQuantity, TIndex> | TransactionEIP2930<TQuantity, TIndex> | TransactionEIP1559<TQuantity, TIndex>;
type TransactionRequestBase<TQuantity = bigint, TIndex = number> = {
    /** Contract code or a hashed method call with encoded args */
    data?: Hex;
    /** Transaction sender */
    from: Address;
    /** Gas provided for transaction execution */
    gas?: TQuantity;
    /** Unique number identifying this transaction */
    nonce?: TIndex;
    /** Transaction recipient */
    to?: Address;
    /** Value in wei sent with this transaction */
    value?: TQuantity;
};
type TransactionRequestLegacy<TQuantity = bigint, TIndex = number> = TransactionRequestBase<TQuantity, TIndex> & Partial<FeeValuesLegacy<TQuantity>> & {
    accessList?: never;
};
type TransactionRequestEIP2930<TQuantity = bigint, TIndex = number> = TransactionRequestBase<TQuantity, TIndex> & Partial<FeeValuesLegacy<TQuantity>> & {
    accessList?: AccessList;
};
type TransactionRequestEIP1559<TQuantity = bigint, TIndex = number> = TransactionRequestBase<TQuantity, TIndex> & Partial<FeeValuesEIP1559<TQuantity>> & {
    accessList?: AccessList;
};
type TransactionRequest<TQuantity = bigint, TIndex = number> = TransactionRequestLegacy<TQuantity, TIndex> | TransactionRequestEIP2930<TQuantity, TIndex> | TransactionRequestEIP1559<TQuantity, TIndex>;

type Formatter<TSource = any, TTarget = any> = (value: TSource & {
    [key: string]: unknown;
}) => TTarget;
type Formatters = {
    block?: Formatter<RpcBlock, Block>;
    transaction?: Formatter<RpcTransaction, Transaction>;
    transactionReceipt?: Formatter<RpcTransactionReceipt, TransactionReceipt>;
    transactionRequest?: Formatter<TransactionRequest, RpcTransactionRequest>;
};

type Chain<TFormatters extends Formatters = Formatters> = Chain$1 & {
    formatters?: TFormatters;
};

export { MaybeExtractEventArgsFromAbi as $, AbiItem as A, ByteArray as B, Chain as C, TransactionEIP1559 as D, TransactionEIP2930 as E, FeeHistory as F, TransactionLegacy as G, Hex as H, ExtractFormatter as I, Formatted as J, FormattedTransaction as K, Log as L, TransactionFormatter as M, defineTransaction as N, formatTransaction as O, transactionType as P, Formatters as Q, RpcBlock as R, Formatter as S, TransactionReceipt as T, Uncle as U, TransactionType as V, MergeIntersectionProperties as W, ExtractConstructorArgsFromAbi as X, GetValue as Y, ExtractResultFromAbi as Z, MaybeAbiEventName as _, Hash as a, ExtractEventNameFromAbi as a0, ExtractEventArgsFromAbi as a1, Prettify as a2, Quantity as a3, EventDefinition as a4, ExtractNameFromAbi as a5, ExtractArgsFromAbi as a6, LogTopic as a7, ExtractEventArgsFromTopics as a8, ExtractFunctionNameFromAbi as a9, ExtractErrorNameFromAbi as aa, ExtractErrorArgsFromAbi as ab, defineFormatter as ac, format as ad, AccessList as b, Block as c, BlockIdentifier as d, BlockNumber as e, BlockTag as f, ContractConfig as g, FeeValues as h, FeeValuesEIP1559 as i, FeeValuesLegacy as j, RpcBlockIdentifier as k, RpcBlockNumber as l, RpcFeeHistory as m, RpcFeeValues as n, RpcLog as o, RpcTransaction as p, RpcTransactionReceipt as q, RpcTransactionRequest as r, RpcUncle as s, TransactionRequest as t, TransactionRequestBase as u, TransactionRequestEIP1559 as v, TransactionRequestEIP2930 as w, TransactionRequestLegacy as x, Transaction as y, TransactionBase as z };
