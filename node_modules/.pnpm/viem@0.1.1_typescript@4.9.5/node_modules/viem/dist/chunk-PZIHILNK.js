"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } async function _asyncNullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return await rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/utils/abi/index.ts





var _abitype = require('abitype');

// package.json
var package_default = {
  name: "viem",
  description: "TypeScript Interface for Ethereum",
  version: "0.1.1",
  scripts: {
    anvil: "source .env && anvil --fork-url $VITE_ANVIL_FORK_URL --fork-block-number $VITE_ANVIL_BLOCK_NUMBER --block-time $VITE_ANVIL_BLOCK_TIME",
    bench: "vitest bench --no-threads",
    "bench:ci": "CI=true vitest bench --no-threads",
    build: "tsup",
    changeset: "changeset",
    "changeset:release": "pnpm build && changeset publish",
    "changeset:version": "changeset version && pnpm install --lockfile-only",
    clean: "rimraf dist abi chains contract ens public test utils wallet window",
    "contracts:build": "wagmi generate",
    dev: "DEV=true tsup",
    "dev:docs": "pnpm -r --filter site dev",
    format: "rome format src/ --write",
    lint: "rome check .",
    "lint:fix": "pnpm lint --apply-suggested",
    playground: "pnpm --filter playground-browser dev",
    postinstall: "pnpm dev && pnpm contracts:build",
    preinstall: "npx only-allow pnpm",
    prepublishOnly: "pnpm bun scripts/prepublishOnly.ts",
    prepare: "npx simple-git-hooks",
    test: "vitest dev --no-threads",
    "test:cov": "vitest dev --coverage --no-threads",
    "test:ci": "CI=true vitest --coverage --no-threads",
    "test:ui": "vitest dev --ui --no-threads",
    "ts-node": "bun",
    typecheck: "tsc --noEmit"
  },
  tsup: {
    entry: [
      "src/index.ts",
      "src/abi.ts",
      "src/chains.ts",
      "src/contract.ts",
      "src/ens.ts",
      "src/public.ts",
      "src/test.ts",
      "src/utils/index.ts",
      "src/wallet.ts",
      "src/window.ts"
    ]
  },
  files: [
    "/abi",
    "/dist",
    "/chains",
    "/contract",
    "/ens",
    "/public",
    "/test",
    "/utils",
    "/wallet",
    "/window"
  ],
  exports: {
    ".": {
      types: "./dist/index.d.ts",
      module: "./dist/index.mts",
      default: "./dist/index.js"
    },
    "./abi": {
      types: "./dist/abi.d.ts",
      module: "./dist/abi.mts",
      default: "./dist/abi.js"
    },
    "./chains": {
      types: "./dist/chains.d.ts",
      module: "./dist/chains.mts",
      default: "./dist/chains.js"
    },
    "./contract": {
      types: "./dist/contract.d.ts",
      module: "./dist/contract.mts",
      default: "./dist/contract.js"
    },
    "./ens": {
      types: "./dist/ens.d.ts",
      module: "./dist/ens.mts",
      default: "./dist/ens.js"
    },
    "./public": {
      types: "./dist/public.d.ts",
      module: "./dist/public.mts",
      default: "./dist/public.js"
    },
    "./test": {
      types: "./dist/test.d.ts",
      module: "./dist/test.mts",
      default: "./dist/test.js"
    },
    "./utils": {
      types: "./dist/utils/index.d.ts",
      module: "./dist/utils/index.mts",
      default: "./dist/utils/index.js"
    },
    "./wallet": {
      types: "./dist/wallet.d.ts",
      module: "./dist/wallet.mts",
      default: "./dist/wallet.js"
    },
    "./window": {
      types: "./dist/window.d.ts",
      module: "./dist/window.mts",
      default: "./dist/window.js"
    },
    "./package.json": "./package.json"
  },
  main: "dist/index.js",
  module: "dist/index.mjs",
  types: "dist/index.d.ts",
  sideEffects: false,
  dependencies: {
    "@noble/hashes": "^1.1.2",
    "@wagmi/chains": "~0.2.8",
    abitype: "~0.6.2",
    "idna-uts46-hx": "^4.1.2",
    "isomorphic-ws": "^5.0.0",
    ws: "^8.12.0"
  },
  devDependencies: {
    "@actions/core": "^1.10.0",
    "@actions/github": "^5.1.1",
    "@adraffy/ens-normalize": "^1.8.9",
    "@changesets/changelog-github": "^0.4.5",
    "@changesets/cli": "^2.23.2",
    "@types/dedent": "^0.7.0",
    "@types/fs-extra": "^9.0.13",
    "@types/node": "^17.0.45",
    "@types/ws": "^8.5.4",
    "@vitest/coverage-c8": "^0.29.2",
    "@vitest/ui": "^0.29.2",
    "@wagmi/cli": "^0.1.6",
    bun: "^0.5.5",
    bundlewatch: "^0.3.3",
    dedent: "^0.7.0",
    ethers: "^5.7.2",
    "ethers@6": "npm:ethers@^6.0.2",
    execa: "^6.1.0",
    "fs-extra": "^10.1.0",
    rimraf: "^4.1.2",
    rome: "^11.0.0",
    "simple-git-hooks": "^2.8.1",
    tsup: "^6.6.0",
    typescript: "^4.9.4",
    vite: "^4.1.4",
    vitest: "~0.29.2"
  },
  license: "MIT",
  repository: "wagmi-dev/viem",
  authors: [
    "awkweb.eth",
    "jxom.eth"
  ],
  keywords: [
    "eth",
    "ethereum",
    "dapps",
    "wallet",
    "web3"
  ],
  "simple-git-hooks": {
    "pre-commit": "pnpm format && pnpm lint:fix"
  },
  pnpm: {
    patchedDependencies: {
      "vitepress@1.0.0-alpha.49": "patches/vitepress@1.0.0-alpha.49.patch"
    }
  }
};

// src/errors/utils.ts
var getContractAddress = (address) => address;
var getUrl = (url) => url;
var getVersion = () => `${package_default.name}@${package_default.version}`;

// src/errors/base.ts
var BaseError = class extends Error {
  constructor(shortMessage, args = {}) {
    const details = args.cause instanceof BaseError ? args.cause.details : _optionalChain([args, 'access', _2 => _2.cause, 'optionalAccess', _3 => _3.message]) ? args.cause.message : args.details;
    const docsPath5 = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
    const message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsPath5 ? [`Docs: https://viem.sh${docsPath5}`] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: ${getVersion()}`
    ].join("\n");
    super(message);
    __publicField(this, "details");
    __publicField(this, "docsPath");
    __publicField(this, "metaMessages");
    __publicField(this, "shortMessage");
    __publicField(this, "name", "ViemError");
    if (args.cause)
      this.cause = args.cause;
    this.details = details;
    this.docsPath = docsPath5;
    this.metaMessages = args.metaMessages;
    this.shortMessage = shortMessage;
  }
};

// src/errors/abi.ts
var AbiConstructorNotFoundError = class extends BaseError {
  constructor({ docsPath: docsPath5 }) {
    super(
      [
        "A constructor was not found on the ABI.",
        "Make sure you are using the correct ABI and that the constructor exists on it."
      ].join("\n"),
      {
        docsPath: docsPath5
      }
    );
    __publicField(this, "name", "AbiConstructorNotFoundError");
  }
};
var AbiConstructorParamsNotFoundError = class extends BaseError {
  constructor({ docsPath: docsPath5 }) {
    super(
      [
        "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
        "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
      ].join("\n"),
      {
        docsPath: docsPath5
      }
    );
    __publicField(this, "name", "AbiConstructorParamsNotFoundError");
  }
};
var AbiDecodingDataSizeInvalidError = class extends BaseError {
  constructor(size2) {
    super(
      [
        `Data size of ${size2} bytes is invalid.`,
        "Size must be in increments of 32 bytes (size % 32 === 0)."
      ].join("\n")
    );
    __publicField(this, "name", "AbiDecodingDataSizeInvalidError");
  }
};
var AbiDecodingZeroDataError = class extends BaseError {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.');
    __publicField(this, "name", "AbiDecodingZeroDataError");
  }
};
var AbiEncodingArrayLengthMismatchError = class extends BaseError {
  constructor({
    expectedLength,
    givenLength,
    type
  }) {
    super(
      [
        `ABI encoding array length mismatch for type ${type}.`,
        `Expected length: ${expectedLength}`,
        `Given length: ${givenLength}`
      ].join("\n")
    );
    __publicField(this, "name", "AbiEncodingArrayLengthMismatchError");
  }
};
var AbiEncodingBytesSizeMismatchError = class extends BaseError {
  constructor({ expectedSize, value }) {
    super(
      `Size of bytes "${value}" (bytes${size(
        value
      )}) does not match expected size (bytes${expectedSize}).`
    );
    __publicField(this, "name", "AbiEncodingBytesSizeMismatchError");
  }
};
var AbiEncodingLengthMismatchError = class extends BaseError {
  constructor({
    expectedLength,
    givenLength
  }) {
    super(
      [
        "ABI encoding params/values length mismatch.",
        `Expected length (params): ${expectedLength}`,
        `Given length (values): ${givenLength}`
      ].join("\n")
    );
    __publicField(this, "name", "AbiEncodingLengthMismatchError");
  }
};
var AbiErrorInputsNotFoundError = class extends BaseError {
  constructor(errorName, { docsPath: docsPath5 }) {
    super(
      [
        `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
        "Cannot encode error result without knowing what the parameter types are.",
        "Make sure you are using the correct ABI and that the inputs exist on it."
      ].join("\n"),
      {
        docsPath: docsPath5
      }
    );
    __publicField(this, "name", "AbiErrorInputsNotFoundError");
  }
};
var AbiErrorNotFoundError = class extends BaseError {
  constructor(errorName, { docsPath: docsPath5 }) {
    super(
      [
        `Error "${errorName}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it."
      ].join("\n"),
      {
        docsPath: docsPath5
      }
    );
    __publicField(this, "name", "AbiErrorNotFoundError");
  }
};
var AbiErrorSignatureNotFoundError = class extends BaseError {
  constructor(signature, { docsPath: docsPath5 }) {
    super(
      [
        `Encoded error signature "${signature}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
      ].join("\n"),
      {
        docsPath: docsPath5
      }
    );
    __publicField(this, "name", "AbiErrorSignatureNotFoundError");
  }
};
var AbiEventSignatureNotFoundError = class extends BaseError {
  constructor(signature, { docsPath: docsPath5 }) {
    super(
      [
        `Encoded event signature "${signature}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it.",
        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
      ].join("\n"),
      {
        docsPath: docsPath5
      }
    );
    __publicField(this, "name", "AbiEventSignatureNotFoundError");
  }
};
var AbiEventNotFoundError = class extends BaseError {
  constructor(eventName, { docsPath: docsPath5 }) {
    super(
      [
        `Event "${eventName}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it."
      ].join("\n"),
      {
        docsPath: docsPath5
      }
    );
    __publicField(this, "name", "AbiEventNotFoundError");
  }
};
var AbiFunctionNotFoundError = class extends BaseError {
  constructor(functionName, { docsPath: docsPath5 }) {
    super(
      [
        `Function "${functionName}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the function exists on it."
      ].join("\n"),
      {
        docsPath: docsPath5
      }
    );
    __publicField(this, "name", "AbiFunctionNotFoundError");
  }
};
var AbiFunctionOutputsNotFoundError = class extends BaseError {
  constructor(functionName, { docsPath: docsPath5 }) {
    super(
      [
        `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
        "Cannot decode function result without knowing what the parameter types are.",
        "Make sure you are using the correct ABI and that the function exists on it."
      ].join("\n"),
      {
        docsPath: docsPath5
      }
    );
    __publicField(this, "name", "AbiFunctionOutputsNotFoundError");
  }
};
var AbiFunctionSignatureNotFoundError = class extends BaseError {
  constructor(signature, { docsPath: docsPath5 }) {
    super(
      [
        `Encoded function signature "${signature}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the function exists on it.",
        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
      ].join("\n"),
      {
        docsPath: docsPath5
      }
    );
    __publicField(this, "name", "AbiFunctionSignatureNotFoundError");
  }
};
var BytesSizeMismatchError = class extends BaseError {
  constructor({
    expectedSize,
    givenSize
  }) {
    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
    __publicField(this, "name", "BytesSizeMismatchError");
  }
};
var InvalidAbiEncodingTypeError = class extends BaseError {
  constructor(type, { docsPath: docsPath5 }) {
    super(
      [
        `Type "${type}" is not a valid encoding type.`,
        "Please provide a valid ABI type."
      ].join("\n"),
      { docsPath: docsPath5 }
    );
    __publicField(this, "name", "InvalidAbiEncodingType");
  }
};
var InvalidAbiDecodingTypeError = class extends BaseError {
  constructor(type, { docsPath: docsPath5 }) {
    super(
      [
        `Type "${type}" is not a valid decoding type.`,
        "Please provide a valid ABI type."
      ].join("\n"),
      { docsPath: docsPath5 }
    );
    __publicField(this, "name", "InvalidAbiDecodingType");
  }
};
var InvalidArrayError = class extends BaseError {
  constructor(value) {
    super([`Value "${value}" is not a valid array.`].join("\n"));
    __publicField(this, "name", "InvalidArrayError");
  }
};
var InvalidDefinitionTypeError = class extends BaseError {
  constructor(type) {
    super(
      [
        `"${type}" is not a valid definition type.`,
        'Valid types: "function", "event", "error"'
      ].join("\n")
    );
    __publicField(this, "name", "InvalidDefinitionTypeError");
  }
};
var UnsupportedPackedAbiType = class extends BaseError {
  constructor(type) {
    super(`Type "${type}" is not supported for packed encoding.`);
    __publicField(this, "name", "UnsupportedPackedAbiType");
  }
};

// src/errors/address.ts
var InvalidAddressError = class extends BaseError {
  constructor({ address }) {
    super(`Address "${address}" is invalid.`);
    __publicField(this, "name", "InvalidAddressError");
  }
};

// src/errors/block.ts
var BlockNotFoundError = class extends BaseError {
  constructor({
    blockHash,
    blockNumber
  }) {
    let identifier = "Block";
    if (blockHash)
      identifier = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier = `Block at number "${blockNumber}"`;
    super(`${identifier} could not be found.`);
    __publicField(this, "name", "BlockNotFoundError");
  }
};

// src/errors/chain.ts
var ChainDoesNotSupportContract = class extends BaseError {
  constructor({
    blockNumber,
    chain,
    contract
  }) {
    super(
      `Chain "${chain.name}" does not support contract "${contract.name}".`,
      {
        metaMessages: [
          "This could be due to any of the following:",
          ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
            `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
          ] : [
            `- The chain does not have the contract "${contract.name}" configured.`
          ]
        ]
      }
    );
    __publicField(this, "name", "ChainDoesNotSupportContract");
  }
};
var ChainMismatchError = class extends BaseError {
  constructor({
    chain,
    currentChainId
  }) {
    super(
      `The current chain (id: ${currentChainId}) does not match the chain passed to the request (id: ${chain.id} \u2013 ${chain.name}).`,
      {
        metaMessages: [
          `Current Chain ID:  ${currentChainId}`,
          `Expected Chain ID: ${chain.id} \u2013 ${chain.name}`
        ]
      }
    );
    __publicField(this, "name", "ChainMismatchError");
  }
};

// src/constants/abis.ts
var multicall3Abi = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/constants/solidity.ts
var panicReasons = {
  1: "An `assert` condition failed.",
  17: "Arithmic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
};
var solidityError = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
};
var solidityPanic = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};

// src/constants/unit.ts
var etherUnits = {
  gwei: 9,
  wei: 18
};
var gweiUnits = {
  ether: -9,
  wei: 9
};
var weiUnits = {
  ether: -18,
  gwei: -9
};

// src/errors/transaction.ts
function prettyPrint(args) {
  const entries = Object.entries(args).map(([key, value]) => {
    if (value === void 0 || value === false)
      return null;
    return [key, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
  return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
}
var FeeConflictError = class extends BaseError {
  constructor() {
    super(
      [
        "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
        "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
      ].join("\n")
    );
    __publicField(this, "name", "FeeConflictError");
  }
};
var TransactionExecutionError = class extends BaseError {
  constructor(cause, {
    account,
    docsPath: docsPath5,
    chain,
    data,
    gas,
    gasPrice,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    to,
    value
  }) {
    const prettyArgs = prettyPrint({
      chain: chain && `${_optionalChain([chain, 'optionalAccess', _4 => _4.name])} (id: ${_optionalChain([chain, 'optionalAccess', _5 => _5.id])})`,
      from: account.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${_optionalChain([chain, 'optionalAccess', _6 => _6.nativeCurrency, 'access', _7 => _7.symbol]) || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath5,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Request Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    __publicField(this, "cause");
    __publicField(this, "name", "TransactionExecutionError");
    this.cause = cause;
  }
};
var TransactionNotFoundError = class extends BaseError {
  constructor({
    blockHash,
    blockNumber,
    blockTag,
    hash: hash2,
    index
  }) {
    let identifier = "Transaction";
    if (blockTag && index !== void 0)
      identifier = `Transaction at block time "${blockTag}" at index "${index}"`;
    if (blockHash && index !== void 0)
      identifier = `Transaction at block hash "${blockHash}" at index "${index}"`;
    if (blockNumber && index !== void 0)
      identifier = `Transaction at block number "${blockNumber}" at index "${index}"`;
    if (hash2)
      identifier = `Transaction with hash "${hash2}"`;
    super(`${identifier} could not be found.`);
    __publicField(this, "name", "TransactionNotFoundError");
  }
};
var TransactionReceiptNotFoundError = class extends BaseError {
  constructor({ hash: hash2 }) {
    super(
      `Transaction receipt with hash "${hash2}" could not be found. The Transaction may not be processed on a block yet.`
    );
    __publicField(this, "name", "TransactionReceiptNotFoundError");
  }
};
var WaitForTransactionReceiptTimeoutError = class extends BaseError {
  constructor({ hash: hash2 }) {
    super(
      `Timed out while waiting for transaction with hash "${hash2}" to be confirmed.`
    );
    __publicField(this, "name", "WaitForTransactionReceiptTimeoutError");
  }
};

// src/errors/contract.ts
var CallExecutionError = class extends BaseError {
  constructor(cause, {
    account,
    docsPath: docsPath5,
    chain,
    data,
    gas,
    gasPrice,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    to,
    value
  }) {
    const prettyArgs = prettyPrint({
      from: _optionalChain([account, 'optionalAccess', _8 => _8.address]),
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${_optionalChain([chain, 'optionalAccess', _9 => _9.nativeCurrency, 'access', _10 => _10.symbol]) || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath5,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Raw Call Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    __publicField(this, "cause");
    __publicField(this, "name", "CallExecutionError");
    this.cause = cause;
  }
};
var ContractFunctionExecutionError = class extends BaseError {
  constructor(cause, {
    abi,
    args,
    contractAddress,
    docsPath: docsPath5,
    functionName,
    sender
  }) {
    const abiItem = getAbiItem({ abi, args, name: functionName });
    const formattedArgs = abiItem ? formatAbiItemWithArgs({
      abiItem,
      args,
      includeFunctionName: false,
      includeName: false
    }) : void 0;
    const functionWithParams = abiItem ? formatAbiItem(abiItem, { includeName: true }) : void 0;
    const prettyArgs = prettyPrint({
      address: contractAddress && getContractAddress(contractAddress),
      function: functionWithParams,
      args: formattedArgs && formattedArgs !== "()" && `${[...Array(_nullishCoalesce(_optionalChain([functionName, 'optionalAccess', _11 => _11.length]), () => ( 0))).keys()].map(() => " ").join("")}${formattedArgs}`,
      sender
    });
    super(
      cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`,
      {
        cause,
        docsPath: docsPath5,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          "Contract Call:",
          prettyArgs
        ].filter(Boolean)
      }
    );
    __publicField(this, "abi");
    __publicField(this, "args");
    __publicField(this, "cause");
    __publicField(this, "contractAddress");
    __publicField(this, "formattedArgs");
    __publicField(this, "functionName");
    __publicField(this, "sender");
    __publicField(this, "name", "ContractFunctionExecutionError");
    this.abi = abi;
    this.args = args;
    this.cause = cause;
    this.contractAddress = contractAddress;
    this.functionName = functionName;
    this.sender = sender;
  }
};
var ContractFunctionRevertedError = class extends BaseError {
  constructor({
    abi,
    data,
    functionName,
    message
  }) {
    let decodedData = void 0;
    let metaMessages;
    let reason;
    if (data && data !== "0x") {
      decodedData = decodeErrorResult({ abi, data });
      const { abiItem, errorName, args: errorArgs } = decodedData;
      if (errorName === "Error") {
        reason = errorArgs[0];
      } else if (errorName === "Panic") {
        const [firstArg] = errorArgs;
        reason = panicReasons[firstArg];
      } else if (errorArgs) {
        const errorWithParams = abiItem ? formatAbiItem(abiItem, { includeName: true }) : void 0;
        const formattedArgs = abiItem ? formatAbiItemWithArgs({
          abiItem,
          args: errorArgs,
          includeFunctionName: false,
          includeName: false
        }) : void 0;
        metaMessages = [
          errorWithParams ? `Error: ${errorWithParams}` : "",
          formattedArgs && formattedArgs !== "()" ? `       ${[...Array(_nullishCoalesce(_optionalChain([errorName, 'optionalAccess', _12 => _12.length]), () => ( 0))).keys()].map(() => " ").join("")}${formattedArgs}` : ""
        ];
      }
    } else if (message)
      reason = message;
    super(
      reason ? [
        `The contract function "${functionName}" reverted with the following reason:`,
        reason
      ].join("\n") : `The contract function "${functionName}" reverted.`,
      {
        metaMessages
      }
    );
    __publicField(this, "name", "ContractFunctionRevertedError");
    __publicField(this, "data");
    __publicField(this, "reason");
    this.reason = reason;
    this.data = decodedData;
  }
};
var ContractFunctionZeroDataError = class extends BaseError {
  constructor({ functionName }) {
    super(`The contract function "${functionName}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${functionName}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ]
    });
    __publicField(this, "name", "ContractFunctionZeroDataError");
  }
};
var RawContractError = class extends BaseError {
  constructor({ data, message }) {
    super(message || "");
    __publicField(this, "code", 3);
    __publicField(this, "name", "RawContractError");
    __publicField(this, "data");
    this.data = data;
  }
};

// src/errors/data.ts
var SizeExceedsPaddingSizeError = class extends BaseError {
  constructor({
    size: size2,
    targetSize,
    type
  }) {
    super(
      `${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`
    );
    __publicField(this, "name", "SizeExceedsPaddingSizeError");
  }
};

// src/errors/encoding.ts
var DataLengthTooLongError = class extends BaseError {
  constructor({ consumed, length }) {
    super(
      `Consumed bytes (${consumed}) is shorter than data length (${length - 1}).`
    );
    __publicField(this, "name", "DataLengthTooLongError");
  }
};
var DataLengthTooShortError = class extends BaseError {
  constructor({ length, dataLength }) {
    super(
      `Data length (${dataLength - 1}) is shorter than prefix length (${length - 1}).`
    );
    __publicField(this, "name", "DataLengthTooShortError");
  }
};
var InvalidBytesBooleanError = class extends BaseError {
  constructor(bytes) {
    super(
      `Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`
    );
    __publicField(this, "name", "InvalidBytesBooleanError");
  }
};
var InvalidHexBooleanError = class extends BaseError {
  constructor(hex) {
    super(
      `Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`
    );
    __publicField(this, "name", "InvalidHexBooleanError");
  }
};
var InvalidHexValueError = class extends BaseError {
  constructor(value) {
    super(
      `Hex value "${value}" is an odd length (${value.length}). It must be an even length.`
    );
    __publicField(this, "name", "InvalidHexValueError");
  }
};
var OffsetOutOfBoundsError = class extends BaseError {
  constructor({ nextOffset, offset }) {
    super(
      `Next offset (${nextOffset}) is greater than previous offset + consumed bytes (${offset})`
    );
    __publicField(this, "name", "OffsetOutOfBoundsError");
  }
};

// src/errors/estimateGas.ts
var EstimateGasExecutionError = class extends BaseError {
  constructor(cause, {
    account,
    docsPath: docsPath5,
    chain,
    data,
    gas,
    gasPrice,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    to,
    value
  }) {
    const prettyArgs = prettyPrint({
      from: account.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${_optionalChain([chain, 'optionalAccess', _13 => _13.nativeCurrency, 'access', _14 => _14.symbol]) || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath5,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    __publicField(this, "cause");
    __publicField(this, "name", "EstimateGasExecutionError");
    this.cause = cause;
  }
};

// src/errors/log.ts
var FilterTypeNotSupportedError = class extends BaseError {
  constructor(type) {
    super(`Filter type "${type}" is not supported.`);
    __publicField(this, "name", "FilterTypeNotSupportedError");
  }
};

// src/errors/node.ts
var ExecutionRevertedError = class extends BaseError {
  constructor({
    cause,
    message
  } = {}) {
    const reason = _optionalChain([message, 'optionalAccess', _15 => _15.replace, 'call', _16 => _16("execution reverted: ", ""), 'optionalAccess', _17 => _17.replace, 'call', _18 => _18("execution reverted", "")]);
    super(
      `Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`,
      {
        cause
      }
    );
    __publicField(this, "name", "ExecutionRevertedError");
  }
};
__publicField(ExecutionRevertedError, "code", 3);
__publicField(ExecutionRevertedError, "nodeMessage", /execution reverted/);
var FeeCapTooHighError = class extends BaseError {
  constructor({
    cause,
    maxFeePerGas
  } = {}) {
    super(
      `The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`,
      {
        cause
      }
    );
    __publicField(this, "name", "FeeCapTooHigh");
  }
};
__publicField(FeeCapTooHighError, "nodeMessage", /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/);
var FeeCapTooLowError = class extends BaseError {
  constructor({
    cause,
    maxFeePerGas
  } = {}) {
    super(
      `The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`,
      {
        cause
      }
    );
    __publicField(this, "name", "FeeCapTooLow");
  }
};
__publicField(FeeCapTooLowError, "nodeMessage", /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/);
var NonceTooHighError = class extends BaseError {
  constructor({ cause, nonce } = {}) {
    super(
      `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`,
      { cause }
    );
    __publicField(this, "name", "NonceTooHighError");
  }
};
__publicField(NonceTooHighError, "nodeMessage", /nonce too high/);
var NonceTooLowError = class extends BaseError {
  constructor({ cause, nonce } = {}) {
    super(
      [
        `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
        "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
      ].join("\n"),
      { cause }
    );
    __publicField(this, "name", "NonceTooLowError");
  }
};
__publicField(NonceTooLowError, "nodeMessage", /nonce too low|transaction already imported/);
var NonceMaxValueError = class extends BaseError {
  constructor({ cause, nonce } = {}) {
    super(
      `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`,
      { cause }
    );
    __publicField(this, "name", "NonceMaxValueError");
  }
};
__publicField(NonceMaxValueError, "nodeMessage", /nonce has max value/);
var InsufficientFundsError = class extends BaseError {
  constructor({ cause } = {}) {
    super(
      [
        "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
      ].join("\n"),
      {
        cause,
        metaMessages: [
          "This error could arise when the account does not have enough funds to:",
          " - pay for the total gas fee,",
          " - pay for the value to send.",
          " ",
          "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
          " - `gas` is the amount of gas needed for transaction to execute,",
          " - `gas fee` is the gas fee,",
          " - `value` is the amount of ether to send to the recipient."
        ]
      }
    );
    __publicField(this, "name", "InsufficientFundsError");
  }
};
__publicField(InsufficientFundsError, "nodeMessage", /insufficient funds/);
var IntrinsicGasTooHighError = class extends BaseError {
  constructor({ cause, gas } = {}) {
    super(
      `The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`,
      {
        cause
      }
    );
    __publicField(this, "name", "IntrinsicGasTooHighError");
  }
};
__publicField(IntrinsicGasTooHighError, "nodeMessage", /intrinsic gas too high|gas limit reached/);
var IntrinsicGasTooLowError = class extends BaseError {
  constructor({ cause, gas } = {}) {
    super(
      `The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`,
      {
        cause
      }
    );
    __publicField(this, "name", "IntrinsicGasTooLowError");
  }
};
__publicField(IntrinsicGasTooLowError, "nodeMessage", /intrinsic gas too low/);
var TransactionTypeNotSupportedError = class extends BaseError {
  constructor({ cause }) {
    super("The transaction type is not supported for this chain.", {
      cause
    });
    __publicField(this, "name", "TransactionTypeNotSupportedError");
  }
};
__publicField(TransactionTypeNotSupportedError, "nodeMessage", /transaction type not valid/);
var TipAboveFeeCapError = class extends BaseError {
  constructor({
    cause,
    maxPriorityFeePerGas,
    maxFeePerGas
  } = {}) {
    super(
      [
        `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
      ].join("\n"),
      {
        cause
      }
    );
    __publicField(this, "name", "TipAboveFeeCapError");
  }
};
__publicField(TipAboveFeeCapError, "nodeMessage", /max priority fee per gas higher than max fee per gas|tip higher than fee cap/);
var UnknownNodeError = class extends BaseError {
  constructor({ cause }) {
    super(`An error occurred while executing: ${_optionalChain([cause, 'optionalAccess', _19 => _19.message])}`, {
      cause
    });
    __publicField(this, "name", "UnknownNodeError");
  }
};

// src/errors/request.ts
var RequestError = class extends BaseError {
  constructor(err, {
    docsPath: docsPath5,
    metaMessages,
    shortMessage
  }) {
    super(shortMessage, {
      cause: err,
      docsPath: docsPath5,
      metaMessages
    });
    this.name = err.name;
  }
};
var RpcRequestError = class extends RequestError {
  constructor(err, { docsPath: docsPath5, shortMessage }) {
    super(err, { docsPath: docsPath5, metaMessages: err.metaMessages, shortMessage });
    __publicField(this, "code");
    this.code = err.code;
    this.name = err.name;
  }
};
var ParseRpcError = class extends RpcRequestError {
  constructor(err) {
    super(err, {
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
    __publicField(this, "name", "ParseRpcError");
    __publicField(this, "code", -32700);
  }
};
var InvalidRequestRpcError = class extends RpcRequestError {
  constructor(err) {
    super(err, { shortMessage: "JSON is not a valid request object." });
    __publicField(this, "name", "InvalidRequestRpcError");
    __publicField(this, "code", -32600);
  }
};
var MethodNotFoundRpcError = class extends RpcRequestError {
  constructor(err) {
    super(err, {
      shortMessage: "The method does not exist / is not available."
    });
    __publicField(this, "name", "MethodNotFoundRpcError");
    __publicField(this, "code", -32601);
  }
};
var InvalidParamsRpcError = class extends RpcRequestError {
  constructor(err) {
    super(err, {
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
    __publicField(this, "name", "InvalidParamsRpcError");
    __publicField(this, "code", -32602);
  }
};
var InternalRpcError = class extends RpcRequestError {
  constructor(err) {
    super(err, { shortMessage: "An internal error was received." });
    __publicField(this, "name", "InternalRpcError");
    __publicField(this, "code", -32603);
  }
};
var InvalidInputRpcError = class extends RpcRequestError {
  constructor(err) {
    super(err, {
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
    __publicField(this, "name", "InvalidInputRpcError");
    __publicField(this, "code", -32e3);
  }
};
var ResourceNotFoundRpcError = class extends RpcRequestError {
  constructor(err) {
    super(err, { shortMessage: "Requested resource not found." });
    __publicField(this, "name", "ResourceNotFoundRpcError");
    __publicField(this, "code", -32001);
  }
};
var ResourceUnavailableRpcError = class extends RpcRequestError {
  constructor(err) {
    super(err, { shortMessage: "Requested resource not available." });
    __publicField(this, "name", "ResourceUnavailableRpcError");
    __publicField(this, "code", -32002);
  }
};
var TransactionRejectedRpcError = class extends RpcRequestError {
  constructor(err) {
    super(err, { shortMessage: "Transaction creation failed." });
    __publicField(this, "name", "TransactionRejectedRpcError");
    __publicField(this, "code", -32003);
  }
};
var MethodNotSupportedRpcError = class extends RpcRequestError {
  constructor(err) {
    super(err, { shortMessage: "Method is not implemented." });
    __publicField(this, "name", "MethodNotSupportedRpcError");
    __publicField(this, "code", -32004);
  }
};
var LimitExceededRpcError = class extends RpcRequestError {
  constructor(err) {
    super(err, { shortMessage: "Request exceeds defined limit." });
    __publicField(this, "name", "LimitExceededRpcError");
    __publicField(this, "code", -32005);
  }
};
var JsonRpcVersionUnsupportedError = class extends RpcRequestError {
  constructor(err) {
    super(err, {
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
    __publicField(this, "name", "JsonRpcVersionUnsupportedError");
    __publicField(this, "code", -32006);
  }
};
var UserRejectedRequestError = class extends RpcRequestError {
  constructor(err) {
    super(err, {
      shortMessage: "User rejected the request."
    });
    __publicField(this, "name", "UserRejectedRequestError");
    __publicField(this, "code", 4001);
  }
};
var SwitchChainError = class extends RpcRequestError {
  constructor(err) {
    super(err, {
      shortMessage: "An error occurred when attempting to switch chain."
    });
    __publicField(this, "name", "SwitchChainError");
    __publicField(this, "code", 4902);
  }
};
var UnknownRpcError = class extends RequestError {
  constructor(err) {
    super(err, {
      shortMessage: "An unknown RPC error occurred."
    });
    __publicField(this, "name", "UnknownRpcError");
  }
};

// src/errors/rpc.ts
var HttpRequestError = class extends BaseError {
  constructor({
    body,
    details,
    headers,
    status,
    url
  }) {
    super("HTTP request failed.", {
      details,
      metaMessages: [
        status && `Status: ${status}`,
        `URL: ${getUrl(url)}`,
        `Request body: ${stringify(body)}`
      ].filter(Boolean)
    });
    __publicField(this, "name", "HttpRequestError");
    __publicField(this, "body");
    __publicField(this, "headers");
    __publicField(this, "status");
    __publicField(this, "url");
    this.body = body;
    this.headers = headers;
    this.status = status;
    this.url = url;
  }
};
var WebSocketRequestError = class extends BaseError {
  constructor({
    body,
    details,
    url
  }) {
    super("WebSocket request failed.", {
      details,
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
    });
    __publicField(this, "name", "WebSocketRequestError");
  }
};
var RpcError = class extends BaseError {
  constructor({
    body,
    error,
    url
  }) {
    super("RPC Request failed.", {
      cause: error,
      details: error.message,
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
    });
    __publicField(this, "code");
    __publicField(this, "name", "RpcError");
    this.code = error.code;
  }
};
var TimeoutError = class extends BaseError {
  constructor({
    body,
    url
  }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
    });
    __publicField(this, "name", "TimeoutError");
  }
};

// src/errors/transport.ts
var UrlRequiredError = class extends BaseError {
  constructor() {
    super(
      "No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.",
      {
        docsPath: "/docs/clients/intro"
      }
    );
  }
};

// src/utils/data/concat.ts
function concat(values) {
  if (typeof values[0] === "string")
    return concatHex(values);
  return concatBytes(values);
}
function concatBytes(values) {
  let length = 0;
  for (const arr of values) {
    length += arr.length;
  }
  const result = new Uint8Array(length);
  let offset = 0;
  for (const arr of values) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
function concatHex(values) {
  return `0x${values.reduce(
    (acc, x) => acc + x.replace("0x", ""),
    ""
  )}`;
}

// src/utils/data/isBytes.ts
function isBytes(value) {
  if (!value)
    return false;
  if (typeof value !== "object")
    return false;
  if (!("BYTES_PER_ELEMENT" in value))
    return false;
  return value.BYTES_PER_ELEMENT === 1 && value.constructor.name === "Uint8Array";
}

// src/utils/data/isHex.ts
function isHex(value) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return /^0x[0-9a-fA-F]*$/.test(value);
}

// src/utils/data/pad.ts
function pad(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size2 });
  return padBytes(hexOrBytes, { dir, size: size2 });
}
function padHex(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  let hex = hex_.replace("0x", "");
  if (hex.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](
    size2 * 2,
    "0"
  )}`;
}
function padBytes(bytes, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes;
  if (bytes.length > size2)
    throw new SizeExceedsPaddingSizeError({
      size: bytes.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let i = 0; i < size2; i++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i : size2 - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
  }
  return paddedBytes;
}

// src/utils/data/trim.ts
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i = 0; i < data.length - 1; i++) {
    if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data.length === 1 && dir === "right")
      data = `${data}0`;
    return `0x${data}`;
  }
  return data;
}

// src/utils/data/size.ts
function size(value) {
  if (isHex(value))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}

// src/utils/data/slice.ts
function slice(value, start, end) {
  if (isHex(value))
    return sliceHex(value, start, end);
  return sliceBytes(value, start, end);
}
function assertStartOffset(value, start) {
  if (typeof start === "number" && start > 0 && start > size(value) - 1)
    throw new Error(
      `Slice starting at offset "${start}" is out-of-bounds (size: ${size(
        value
      )}).`
    );
}
function sliceBytes(value, start, end) {
  assertStartOffset(value, start);
  return value.slice(start, end);
}
function sliceHex(value_, start, end) {
  assertStartOffset(value_, start);
  const value = value_.replace("0x", "").slice((_nullishCoalesce(start, () => ( 0))) * 2, (_nullishCoalesce(end, () => ( value_.length))) * 2);
  return `0x${value}`;
}

// src/utils/encoding/toHex.ts
var hexes = Array.from(
  { length: 256 },
  (_v, i) => i.toString(16).padStart(2, "0")
);
function boolToHex(value) {
  return `0x${Number(value)}`;
}
function bytesToHex(value) {
  let hex = "";
  for (let i = 0; i < value.length; i++) {
    hex += hexes[value[i]];
  }
  return `0x${hex}`;
}
function toHex(value) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value);
  if (typeof value === "string") {
    return stringToHex(value);
  }
  if (typeof value === "boolean")
    return boolToHex(value);
  return bytesToHex(value);
}
function numberToHex(value_, opts = {}) {
  const { signed, size: size2 } = opts;
  let value = BigInt(value_);
  let maxValue;
  if (size2) {
    if (signed)
      maxValue = (1n << BigInt(size2) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new Error(
      `Number "${value_}${suffix}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${maxValue ? `(${minValue}${suffix} to ${maxValue}${suffix})` : `(above ${minValue})`}`
    );
  }
  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size2)
    return pad(hex, { size: size2 });
  return hex;
}
function stringToHex(value) {
  let hex = "";
  for (let i = 0; i < value.length; i++) {
    hex += value.charCodeAt(i).toString(16);
  }
  return `0x${hex}`;
}

// src/utils/encoding/toBytes.ts
var encoder = new TextEncoder();
function toBytes(value) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value);
  if (typeof value === "boolean")
    return boolToBytes(value);
  if (value.startsWith("0x"))
    return hexToBytes(value);
  return stringToBytes(value);
}
function boolToBytes(value) {
  const bytes = new Uint8Array(1);
  bytes[0] = Number(value);
  return bytes;
}
function hexToBytes(hex_) {
  let hex = hex_.slice(2);
  if (hex.length % 2)
    hex = `0${hex}`;
  const bytes = new Uint8Array(hex.length / 2);
  for (let index = 0; index < bytes.length; index++) {
    const start = index * 2;
    const hexByte = hex.slice(start, start + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new BaseError(`Invalid byte sequence ("${hexByte}" in "${hex}").`);
    bytes[index] = byte;
  }
  return bytes;
}
function numberToBytes(value, opts) {
  const hex = numberToHex(value, opts);
  return hexToBytes(hex);
}
function stringToBytes(value) {
  return encoder.encode(value);
}

// src/utils/encoding/toRlp.ts
function toRlp(hexOrBytes, to_) {
  const to = to_ || "hex";
  return format(bytesToRlp(parse(hexOrBytes)), to);
}
function parse(hexOrBytes) {
  if (Array.isArray(hexOrBytes))
    return hexOrBytes.map(parse);
  return typeof hexOrBytes === "string" ? toBytes(hexOrBytes) : hexOrBytes;
}
function format(bytes, type = "bytes") {
  return type === "hex" ? bytesToHex(bytes) : bytes;
}
function bytesToRlp(bytes) {
  if (Array.isArray(bytes)) {
    const encoded = concat(bytes.map(bytesToRlp));
    return new Uint8Array([...encodeLength(encoded.length, 192), ...encoded]);
  }
  if (bytes.length === 1 && bytes[0] < 128)
    return bytes;
  return new Uint8Array([...encodeLength(bytes.length, 128), ...bytes]);
}
function encodeLength(length, offset) {
  if (length < 56)
    return [offset + length];
  return [toBytes(length).length + offset + 55, ...toBytes(length)];
}

// src/utils/encoding/fromHex.ts
function fromHex(hex, to) {
  if (to === "number")
    return hexToNumber(hex);
  if (to === "bigint")
    return hexToBigInt(hex);
  if (to === "string")
    return hexToString(hex);
  if (to === "boolean")
    return hexToBool(hex);
  return hexToBytes(hex);
}
function hexToBigInt(hex, opts = {}) {
  const { signed } = opts;
  const value = BigInt(hex);
  if (!signed)
    return value;
  const size2 = (hex.length - 2) / 2;
  const max = (1n << BigInt(size2) * 8n - 1n) - 1n;
  if (value <= max)
    return value;
  return value - BigInt(`0x${"f".padStart(size2 * 2, "f")}`) - 1n;
}
function hexToBool(hex) {
  if (trim(hex) === "0x0")
    return false;
  if (trim(hex) === "0x1")
    return true;
  throw new InvalidHexBooleanError(hex);
}
function hexToNumber(hex, opts = {}) {
  return Number(hexToBigInt(hex, opts));
}
function hexToString(hex) {
  const bytes = hexToBytes(hex);
  return new TextDecoder().decode(bytes);
}

// src/utils/encoding/fromBytes.ts
function fromBytes(bytes, to) {
  if (to === "number")
    return bytesToNumber(bytes);
  if (to === "bigint")
    return bytesToBigint(bytes);
  if (to === "boolean")
    return bytesToBool(bytes);
  if (to === "string")
    return bytesToString(bytes);
  return bytesToHex(bytes);
}
function bytesToBigint(bytes) {
  const hex = bytesToHex(bytes);
  return hexToBigInt(hex);
}
function bytesToBool(bytes) {
  if (bytes.length > 1 || bytes[0] > 1)
    throw new InvalidBytesBooleanError(bytes);
  return Boolean(bytes[0]);
}
function bytesToNumber(bytes) {
  const hex = bytesToHex(bytes);
  return hexToNumber(hex);
}
function bytesToString(bytes) {
  return new TextDecoder().decode(bytes);
}

// src/utils/encoding/fromRlp.ts
function fromRlp(value, to) {
  const bytes = parse2(value);
  const [data, consumed] = rlpToBytes(bytes);
  if (consumed < bytes.length)
    throw new DataLengthTooLongError({
      consumed,
      length: bytes.length
    });
  return format2(data, to);
}
function parse2(value) {
  if (typeof value === "string") {
    if (value.length > 3 && value.length % 2 !== 0)
      throw new InvalidHexValueError(value);
    return hexToBytes(value);
  }
  return value;
}
function format2(bytes, to) {
  if (Array.isArray(bytes))
    return bytes.map((b) => format2(b, to));
  return to === "hex" ? trim(bytesToHex(bytes)) : bytes;
}
function rlpToBytes(bytes, offset = 0) {
  if (bytes.length === 0)
    return [new Uint8Array([]), 0];
  const prefix = bytes[offset];
  if (prefix <= 127)
    return [new Uint8Array([bytes[offset]]), 1];
  if (prefix <= 183) {
    const length2 = prefix - 128;
    const offset_ = offset + 1;
    if (offset_ + length2 > bytes.length)
      throw new DataLengthTooShortError({
        length: offset_ + length2,
        dataLength: bytes.length
      });
    return [bytes.slice(offset_, offset_ + length2), 1 + length2];
  }
  if (prefix <= 191) {
    const lengthOfLength2 = prefix - 183;
    const offset_ = offset + 1;
    const length2 = bytesToNumber(bytes.slice(offset_, offset_ + lengthOfLength2));
    if (offset_ + lengthOfLength2 + length2 > bytes.length)
      throw new DataLengthTooShortError({
        length: lengthOfLength2 + length2,
        dataLength: bytes.length - lengthOfLength2
      });
    return [
      bytes.slice(offset_ + lengthOfLength2, offset_ + lengthOfLength2 + length2),
      1 + lengthOfLength2 + length2
    ];
  }
  let lengthOfLength = 0;
  let length = prefix - 192;
  if (prefix > 247) {
    lengthOfLength = prefix - 247;
    length = bytesToNumber(bytes.slice(offset + 1, offset + 1 + lengthOfLength));
  }
  let nextOffset = offset + 1 + lengthOfLength;
  if (nextOffset > bytes.length)
    throw new DataLengthTooShortError({
      length: nextOffset,
      dataLength: bytes.length
    });
  let consumed = 1 + lengthOfLength + length;
  let result = [];
  while (nextOffset < offset + consumed) {
    const decoded = rlpToBytes(bytes, nextOffset);
    result.push(decoded[0]);
    nextOffset += decoded[1];
    if (nextOffset > offset + consumed)
      throw new OffsetOutOfBoundsError({
        nextOffset,
        offset: offset + consumed
      });
  }
  return [result, consumed];
}

// src/utils/contract/extractFunctionParts.ts
var paramsRegex = /((function|event)\s)?(.*)(\((.*)\))/;
function extractFunctionParts(def) {
  const parts = def.match(paramsRegex);
  const type = _optionalChain([parts, 'optionalAccess', _20 => _20[2]]) || void 0;
  const name = _optionalChain([parts, 'optionalAccess', _21 => _21[3]]);
  const params = _optionalChain([parts, 'optionalAccess', _22 => _22[5]]) || void 0;
  return { type, name, params };
}
function extractFunctionName(def) {
  return extractFunctionParts(def).name;
}
function extractFunctionParams(def) {
  const params = extractFunctionParts(def).params;
  const splitParams = _optionalChain([params, 'optionalAccess', _23 => _23.split, 'call', _24 => _24(","), 'access', _25 => _25.map, 'call', _26 => _26((x) => x.trim().split(" "))]);
  return _optionalChain([splitParams, 'optionalAccess', _27 => _27.map, 'call', _28 => _28((param) => ({
    type: param[0],
    name: param[1] === "indexed" ? param[2] : param[1],
    ...param[1] === "indexed" ? { indexed: true } : {}
  }))]);
}
function extractFunctionType(def) {
  return extractFunctionParts(def).type;
}

// src/utils/hash/keccak256.ts
var _sha3 = require('@noble/hashes/sha3');
function keccak256(value, to_) {
  const to = to_ || "hex";
  const bytes = _sha3.keccak_256.call(void 0, isHex(value) ? toBytes(value) : value);
  if (to === "bytes")
    return bytes;
  return toHex(bytes);
}

// src/utils/hash/hashFunction.ts
var hash = (value) => keccak256(toBytes(value));
function hashFunction(def) {
  const name = extractFunctionName(def);
  const params = extractFunctionParams(def);
  if (!params || params.length === 0)
    return hash(def.replace(/ /g, ""));
  return hash(`${name}(${params.map(({ type }) => type).join(",")})`);
}

// src/utils/hash/getEventSelector.ts
var getEventSelector = (event) => hashFunction(event);

// src/utils/hash/getFunctionSelector.ts
var getFunctionSelector = (fn) => slice(hashFunction(fn), 0, 4);

// src/utils/address/isAddress.ts
var addressRegex = /^0x[a-fA-F0-9]{40}$/;
function isAddress(address) {
  return addressRegex.test(address);
}

// src/utils/address/getAddress.ts
function checksumAddress(address_) {
  const hexAddress = address_.substring(2).toLowerCase();
  const hash2 = keccak256(stringToBytes(hexAddress), "bytes");
  let address = hexAddress.split("");
  for (let i = 0; i < 40; i += 2) {
    if (hash2[i >> 1] >> 4 >= 8 && address[i]) {
      address[i] = address[i].toUpperCase();
    }
    if ((hash2[i >> 1] & 15) >= 8 && address[i + 1]) {
      address[i + 1] = address[i + 1].toUpperCase();
    }
  }
  return `0x${address.join("")}`;
}
function getAddress(address) {
  if (!isAddress(address))
    throw new InvalidAddressError({ address });
  return checksumAddress(address);
}

// src/utils/address/getContractAddress.ts
function getContractAddress2(opts) {
  if (opts.opcode === "CREATE2")
    return getCreate2Address(opts);
  return getCreateAddress(opts);
}
function getCreateAddress(opts) {
  const from = toBytes(getAddress(opts.from));
  let nonce = toBytes(opts.nonce);
  if (nonce[0] === 0)
    nonce = new Uint8Array([]);
  return getAddress(
    `0x${keccak256(toRlp([from, nonce], "bytes")).slice(26)}`
  );
}
function getCreate2Address(opts) {
  const from = toBytes(getAddress(opts.from));
  const salt = pad(isBytes(opts.salt) ? opts.salt : toBytes(opts.salt), {
    size: 32
  });
  const bytecodeHash = toBytes(
    keccak256(
      isBytes(opts.bytecode) ? opts.bytecode : toBytes(opts.bytecode)
    )
  );
  return getAddress(
    slice(keccak256(concat([toBytes("0xff"), from, salt, bytecodeHash])), 12)
  );
}

// src/utils/address/isAddressEqual.ts
function isAddressEqual(a, b) {
  if (!isAddress(a))
    throw new InvalidAddressError({ address: a });
  if (!isAddress(b))
    throw new InvalidAddressError({ address: b });
  return a.toLowerCase() === b.toLowerCase();
}

// src/utils/abi/encodeAbiParameters.ts
function encodeAbiParameters(params, values) {
  if (params.length !== values.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: params.length,
      givenLength: values.length
    });
  const preparedParams = prepareParams({
    params,
    values
  });
  const data = encodeParams(preparedParams);
  if (data.length === 0)
    return "0x";
  return data;
}
function prepareParams({
  params,
  values
}) {
  let preparedParams = [];
  for (let i = 0; i < params.length; i++) {
    preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
  }
  return preparedParams;
}
function prepareParam({
  param,
  value
}) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return encodeArray(value, { length, param: { ...param, type } });
  }
  if (param.type === "tuple") {
    return encodeTuple(value, {
      param
    });
  }
  if (param.type === "address") {
    return encodeAddress(value);
  }
  if (param.type === "bool") {
    return encodeBool(value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    const signed = param.type.startsWith("int");
    return encodeNumber(value, { signed });
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(value, { param });
  }
  if (param.type === "string") {
    return encodeString(value);
  }
  throw new InvalidAbiEncodingTypeError(param.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams(preparedParams) {
  let staticSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic)
      staticSize += 32;
    else
      staticSize += size(encoded);
  }
  let staticParams = [];
  let dynamicParams = [];
  let dynamicSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic) {
      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
      dynamicParams.push(encoded);
      dynamicSize += size(encoded);
    } else {
      staticParams.push(encoded);
    }
  }
  return concat([...staticParams, ...dynamicParams]);
}
function encodeAddress(value) {
  if (!isAddress(value))
    throw new InvalidAddressError({ address: value });
  return { dynamic: false, encoded: padHex(value.toLowerCase()) };
}
function encodeArray(value, {
  length,
  param
}) {
  let dynamic = length === null;
  if (!Array.isArray(value))
    throw new InvalidArrayError(value);
  if (!dynamic && value.length !== length)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: length,
      givenLength: value.length,
      type: `${param.type}[${length}]`
    });
  let dynamicChild = false;
  let preparedParams = [];
  for (let i = 0; i < value.length; i++) {
    const preparedParam = prepareParam({ param, value: value[i] });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParams.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data = encodeParams(preparedParams);
    if (dynamic) {
      const length2 = numberToHex(preparedParams.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParams.length > 0 ? concat([length2, data]) : length2
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data };
  }
  return {
    dynamic: false,
    encoded: concat(preparedParams.map(({ encoded }) => encoded))
  };
}
function encodeBytes(value, { param }) {
  const [_, size_] = param.type.split("bytes");
  if (!size_) {
    const partsLength = Math.floor(size(value) / 32);
    const parts = [];
    for (let i = 0; i < partsLength + 1; i++) {
      parts.push(
        padHex(slice(value, i * 32, (i + 1) * 32), {
          dir: "right"
        })
      );
    }
    return {
      dynamic: true,
      encoded: concat([
        padHex(numberToHex(size(value), { size: 32 })),
        ...parts
      ])
    };
  }
  if (size(value) !== parseInt(size_))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: parseInt(size_),
      value
    });
  return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
}
function encodeBool(value) {
  return { dynamic: false, encoded: padHex(boolToHex(value)) };
}
function encodeNumber(value, { signed }) {
  return {
    dynamic: false,
    encoded: numberToHex(value, {
      size: 32,
      signed
    })
  };
}
function encodeString(value) {
  return {
    dynamic: true,
    encoded: concat([
      padHex(numberToHex(value.length, { size: 32 })),
      padHex(stringToHex(value), { dir: "right" })
    ])
  };
}
function encodeTuple(value, { param }) {
  let dynamic = false;
  let preparedParams = [];
  for (let i = 0; i < param.components.length; i++) {
    const param_ = param.components[i];
    const index = Array.isArray(value) ? i : param_.name;
    const preparedParam = prepareParam({
      param: param_,
      value: value[index]
    });
    preparedParams.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(({ encoded }) => encoded))
  };
}
function getArrayComponents(type) {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ? (
    // Return `null` if the array is dynamic.
    [matches[2] ? Number(matches[2]) : null, matches[1]]
  ) : void 0;
}

// src/utils/abi/decodeAbiParameters.ts
function decodeAbiParameters(params, data) {
  if (data === "0x" && params.length > 0)
    throw new AbiDecodingZeroDataError();
  if (size(data) % 32 !== 0)
    throw new AbiDecodingDataSizeInvalidError(size(data));
  return decodeParams({
    data,
    params
  });
}
function decodeParams({
  data,
  params
}) {
  let decodedValues = [];
  let position = 0;
  for (let i = 0; i < params.length; i++) {
    const param = params[i];
    const { consumed, value } = decodeParam({ data, param, position });
    decodedValues.push(value);
    position += consumed;
  }
  return decodedValues;
}
function decodeParam({
  data,
  param,
  position
}) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return decodeArray(data, {
      length,
      param: { ...param, type },
      position
    });
  }
  if (param.type === "tuple") {
    return decodeTuple(data, { param, position });
  }
  if (param.type === "string") {
    return decodeString(data, { position });
  }
  if (param.type.startsWith("bytes")) {
    return decodeBytes(data, { param, position });
  }
  let value = slice(data, position, position + 32);
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    return decodeNumber(value, { param });
  }
  if (param.type === "address") {
    return decodeAddress(value);
  }
  if (param.type === "bool") {
    return decodeBool(value);
  }
  throw new InvalidAbiDecodingTypeError(param.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
function decodeAddress(value) {
  return { consumed: 32, value: checksumAddress(slice(value, -20)) };
}
function decodeArray(data, {
  param,
  length,
  position
}) {
  if (!length) {
    const offset = hexToNumber(slice(data, position, position + 32));
    const length2 = hexToNumber(slice(data, offset, offset + 32));
    let consumed2 = 0;
    let value2 = [];
    for (let i = 0; i < length2; ++i) {
      const decodedChild = decodeParam({
        data: slice(data, offset + 32),
        param,
        position: consumed2
      });
      consumed2 += decodedChild.consumed;
      value2.push(decodedChild.value);
    }
    return { value: value2, consumed: 32 };
  }
  if (hasDynamicChild(param)) {
    const arrayComponents = getArrayComponents(param.type);
    const dynamicChild = !_optionalChain([arrayComponents, 'optionalAccess', _29 => _29[0]]);
    let consumed2 = 0;
    let value2 = [];
    for (let i = 0; i < length; ++i) {
      const offset = hexToNumber(slice(data, position, position + 32));
      const decodedChild = decodeParam({
        data: slice(data, offset),
        param,
        position: dynamicChild ? consumed2 : i * 32
      });
      consumed2 += decodedChild.consumed;
      value2.push(decodedChild.value);
    }
    return { value: value2, consumed: consumed2 };
  }
  let consumed = 0;
  let value = [];
  for (let i = 0; i < length; ++i) {
    const decodedChild = decodeParam({
      data,
      param,
      position: position + consumed
    });
    consumed += decodedChild.consumed;
    value.push(decodedChild.value);
  }
  return { value, consumed };
}
function decodeBool(value) {
  return { consumed: 32, value: hexToBool(value) };
}
function decodeBytes(data, { param, position }) {
  const [_, size2] = param.type.split("bytes");
  if (!size2) {
    const offset = hexToNumber(slice(data, position, position + 32));
    const length = hexToNumber(slice(data, offset, offset + 32));
    const value2 = (
      // If there is no length, we have zero data.
      length === 0 ? "0x" : slice(data, offset + 32, offset + 32 + length)
    );
    return { consumed: 32, value: value2 };
  }
  const value = slice(data, position, position + parseInt(size2));
  return { consumed: 32, value };
}
function decodeNumber(value, { param }) {
  const signed = param.type.startsWith("int");
  const size2 = parseInt(param.type.split("int")[1] || "256");
  return {
    consumed: 32,
    value: size2 > 48 ? hexToBigInt(value, { signed }) : hexToNumber(value, { signed })
  };
}
function decodeString(data, { position }) {
  const offset = hexToNumber(slice(data, position, position + 32));
  const length = hexToNumber(slice(data, offset, offset + 32));
  const value = hexToString(
    trim(slice(data, offset + 32, offset + 32 + length))
  );
  return { consumed: 32, value };
}
function decodeTuple(data, { param, position }) {
  const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
  let value = hasUnnamedChild ? [] : {};
  let consumed = 0;
  if (hasDynamicChild(param)) {
    const offset = hexToNumber(slice(data, position, position + 32));
    for (let i = 0; i < param.components.length; ++i) {
      const component = param.components[i];
      const decodedChild = decodeParam({
        data: slice(data, offset),
        param: component,
        position: consumed
      });
      consumed += decodedChild.consumed;
      value[hasUnnamedChild ? i : _optionalChain([component, 'optionalAccess', _30 => _30.name])] = decodedChild.value;
    }
    return { consumed: 32, value };
  }
  for (let i = 0; i < param.components.length; ++i) {
    const component = param.components[i];
    const decodedChild = decodeParam({
      data,
      param: component,
      position: position + consumed
    });
    consumed += decodedChild.consumed;
    value[hasUnnamedChild ? i : _optionalChain([component, 'optionalAccess', _31 => _31.name])] = decodedChild.value;
  }
  return { consumed, value };
}
function hasDynamicChild(param) {
  const { type } = param;
  if (type === "string")
    return true;
  if (type === "bytes")
    return true;
  if (type.endsWith("[]"))
    return true;
  if (type === "tuple")
    return _optionalChain([param, 'access', _32 => _32.components, 'optionalAccess', _33 => _33.some, 'call', _34 => _34(hasDynamicChild)]);
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
    return true;
  return false;
}

// src/utils/abi/formatAbiItem.ts
function formatAbiItem(abiItem, { includeName = false } = {}) {
  if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
    throw new InvalidDefinitionTypeError(abiItem.type);
  return `${abiItem.name}(${getParams(abiItem.inputs, { includeName })})`;
}
function getParams(params, { includeName }) {
  if (!params)
    return "";
  return params.map((param) => getParam(param, { includeName })).join(includeName ? ", " : ",");
}
function getParam(param, { includeName }) {
  if (param.type.startsWith("tuple")) {
    return `(${getParams(
      param.components,
      { includeName }
    )})${param.type.slice("tuple".length)}`;
  }
  return param.type + (includeName && param.name ? ` ${param.name}` : "");
}

// src/utils/abi/decodeErrorResult.ts
function decodeErrorResult({
  abi,
  data
}) {
  const signature = slice(data, 0, 4);
  if (signature === "0x")
    throw new AbiDecodingZeroDataError();
  const abi_ = [...abi || [], solidityError, solidityPanic];
  const abiItem = abi_.find(
    (x) => x.type === "error" && signature === getFunctionSelector(formatAbiItem(x))
  );
  if (!abiItem)
    throw new AbiErrorSignatureNotFoundError(signature, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem,
    args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice(data, 4)) : void 0,
    errorName: abiItem.name
  };
}

// src/utils/abi/decodeEventLog.ts
function decodeEventLog({
  abi,
  data,
  topics
}) {
  const [signature, ...argTopics] = topics;
  const abiItem = abi.find(
    (x) => signature === getEventSelector(formatAbiItem(x))
  );
  if (!(abiItem && "name" in abiItem))
    throw new AbiEventSignatureNotFoundError(signature, {
      docsPath: "/docs/contract/decodeEventLog"
    });
  const { name, inputs } = abiItem;
  const isUnnamed = _optionalChain([inputs, 'optionalAccess', _35 => _35.some, 'call', _36 => _36((x) => !("name" in x && x.name))]);
  let args = isUnnamed ? [] : {};
  for (let i = 0; i < inputs.length; i++) {
    const param = inputs[i];
    const topic = argTopics[i];
    if (topic === null)
      args[param.name || i] = null;
    if (!topic)
      continue;
    if (Array.isArray(topic)) {
      args[param.name || i] = topic.map((t) => decodeTopic({ param, value: t }));
    } else {
      args[param.name || i] = decodeTopic({ param, value: topic });
    }
  }
  if (data && data !== "0x") {
    const params = inputs.filter((x) => !("indexed" in x && x.indexed));
    const decodedData = decodeAbiParameters(params, data);
    if (decodedData) {
      if (isUnnamed)
        args = [...args, ...decodedData];
      else {
        for (let i = 0; i < params.length; i++) {
          args[params[i].name] = decodedData[i];
        }
      }
    }
  }
  return {
    eventName: name,
    args: Object.values(args).length > 0 ? args : void 0
  };
}
function decodeTopic({ param, value }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    return value;
  const decodedArg = decodeAbiParameters([param], value) || [];
  return decodedArg[0];
}

// src/utils/abi/decodeFunctionData.ts
function decodeFunctionData({
  abi,
  data
}) {
  const signature = slice(data, 0, 4);
  const description = abi.find(
    (x) => signature === getFunctionSelector(formatAbiItem(x))
  );
  if (!description)
    throw new AbiFunctionSignatureNotFoundError(signature, {
      docsPath: "/docs/contract/decodeFunctionData"
    });
  return {
    functionName: description.name,
    args: "inputs" in description && description.inputs && description.inputs.length > 0 ? decodeAbiParameters(description.inputs, slice(data, 4)) : void 0
  };
}

// src/utils/abi/getAbiItem.ts
function getAbiItem({
  abi,
  args = [],
  name
}) {
  const abiItems = abi.filter((x) => "name" in x && x.name === name);
  if (abiItems.length === 0)
    return void 0;
  if (abiItems.length === 1)
    return abiItems[0];
  for (const abiItem of abiItems) {
    if (!("inputs" in abiItem))
      continue;
    if (!args || args.length === 0) {
      if (!abiItem.inputs || abiItem.inputs.length === 0)
        return abiItem;
      continue;
    }
    if (!abiItem.inputs)
      continue;
    if (abiItem.inputs.length === 0)
      continue;
    const matched = args.every((arg, index) => {
      const abiParameter = "inputs" in abiItem && abiItem.inputs[index];
      if (!abiParameter)
        return false;
      return isArgOfType(arg, abiParameter);
    });
    if (matched)
      return abiItem;
  }
  return abiItems[0];
}
function isArgOfType(arg, abiParameter) {
  const argType = typeof arg;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return isAddress(arg);
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every(
          (component, index) => {
            return isArgOfType(
              Object.values(arg)[index],
              component
            );
          }
        );
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(
        abiParameterType
      ))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every(
          (x) => isArgOfType(x, {
            ...abiParameter,
            // Pop off `[]` or `[M]` from end of type
            type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
          })
        );
      }
      return false;
    }
  }
}

// src/utils/abi/decodeFunctionResult.ts
var docsPath = "/docs/contract/decodeFunctionResult";
function decodeFunctionResult({
  abi,
  args,
  functionName,
  data
}) {
  const description = getAbiItem({
    abi,
    args,
    name: functionName
  });
  if (!description)
    throw new AbiFunctionNotFoundError(functionName, { docsPath });
  if (!("outputs" in description))
    throw new AbiFunctionOutputsNotFoundError(functionName, { docsPath });
  const values = decodeAbiParameters(description.outputs, data);
  if (values && values.length > 1)
    return values;
  if (values && values.length === 1)
    return values[0];
  return void 0;
}

// src/utils/abi/encodeDeployData.ts
var docsPath2 = "/docs/contract/encodeDeployData";
function encodeDeployData({
  abi,
  args,
  bytecode
}) {
  if (!args || args.length === 0)
    return bytecode;
  const description = abi.find(
    (x) => "type" in x && x.type === "constructor"
  );
  if (!description)
    throw new AbiConstructorNotFoundError({ docsPath: docsPath2 });
  if (!("inputs" in description))
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath2 });
  if (!description.inputs || description.inputs.length === 0)
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath2 });
  const data = encodeAbiParameters(
    description.inputs,
    args
  );
  return concatHex([bytecode, data]);
}

// src/utils/abi/encodeErrorResult.ts
var docsPath3 = "/docs/contract/encodeErrorResult";
function encodeErrorResult({ abi, errorName, args }) {
  const description = getAbiItem({
    abi,
    args,
    name: errorName
  });
  if (!description)
    throw new AbiErrorNotFoundError(errorName, { docsPath: docsPath3 });
  const definition = formatAbiItem(description);
  const signature = getFunctionSelector(definition);
  let data = "0x";
  if (args && args.length > 0) {
    if (!("inputs" in description && description.inputs))
      throw new AbiErrorInputsNotFoundError(errorName, { docsPath: docsPath3 });
    data = encodeAbiParameters(description.inputs, args);
  }
  return concatHex([signature, data]);
}

// src/utils/abi/encodeEventTopics.ts
function encodeEventTopics({ abi, eventName, args }) {
  const abiItem = getAbiItem({
    abi,
    args,
    name: eventName
  });
  if (!abiItem)
    throw new AbiEventNotFoundError(eventName, {
      docsPath: "/docs/contract/encodeEventTopics"
    });
  const definition = formatAbiItem(abiItem);
  const signature = getEventSelector(definition);
  let topics = [];
  if (args && "inputs" in abiItem) {
    const args_ = Array.isArray(args) ? args : _nullishCoalesce(_optionalChain([abiItem, 'access', _37 => _37.inputs, 'optionalAccess', _38 => _38.map, 'call', _39 => _39((x) => args[x.name])]), () => ( []));
    topics = _nullishCoalesce(_optionalChain([abiItem, 'access', _40 => _40.inputs, 'optionalAccess', _41 => _41.filter, 'call', _42 => _42((param) => "indexed" in param && param.indexed), 'access', _43 => _43.map, 'call', _44 => _44(
      (param, i) => Array.isArray(args_[i]) ? args_[i].map(
        (_, j) => encodeArg({ param, value: args_[i][j] })
      ) : args_[i] ? encodeArg({ param, value: args_[i] }) : null
    )]), () => ( []));
  }
  return [signature, ...topics];
}
function encodeArg({
  param,
  value
}) {
  if (param.type === "string" || param.type === "bytes")
    return keccak256(toBytes(value));
  if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(param.type);
  return encodeAbiParameters([param], [value]);
}

// src/utils/abi/encodeFunctionData.ts
function encodeFunctionData({
  abi,
  args,
  functionName
}) {
  const description = getAbiItem({
    abi,
    args,
    name: functionName
  });
  if (!description)
    throw new AbiFunctionNotFoundError(functionName, {
      docsPath: "/docs/contract/encodeFunctionData"
    });
  const definition = formatAbiItem(description);
  const signature = getFunctionSelector(definition);
  const data = "inputs" in description && description.inputs ? encodeAbiParameters(
    description.inputs,
    _nullishCoalesce(args, () => ( []))
  ) : void 0;
  return concatHex([signature, _nullishCoalesce(data, () => ( "0x"))]);
}

// src/utils/abi/encodeFunctionResult.ts
var docsPath4 = "/docs/contract/encodeFunctionResult";
function encodeFunctionResult({
  abi,
  functionName,
  result
}) {
  const description = abi.find(
    (x) => "name" in x && x.name === functionName
  );
  if (!description)
    throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath4 });
  if (!("outputs" in description))
    throw new AbiFunctionOutputsNotFoundError(functionName, { docsPath: docsPath4 });
  let values = Array.isArray(result) ? result : [result];
  if (description.outputs.length === 0 && !values[0])
    values = [];
  return encodeAbiParameters(description.outputs, values);
}

// src/utils/regex.ts
var arrayRegex = /^(.*)\[([0-9]*)\]$/;
var bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

// src/utils/abi/encodePacked.ts
function encodePacked(types, values) {
  if (types.length !== values.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: types.length,
      givenLength: values.length
    });
  let data = [];
  for (let i = 0; i < types.length; i++) {
    const type = types[i];
    const value = values[i];
    data.push(encode(type, value));
  }
  return concat(data);
}
function encode(type, value, isArray = false) {
  if (type === "address") {
    let address = value;
    if (!isAddress(address))
      throw new InvalidAddressError({ address });
    return pad(address.toLowerCase(), {
      size: isArray ? 32 : null
    });
  }
  if (type === "string")
    return stringToHex(value);
  if (type === "bytes")
    return value;
  if (type === "bool")
    return pad(boolToHex(value), { size: isArray ? 32 : 1 });
  const intMatch = type.match(integerRegex);
  if (intMatch) {
    const [_type, baseType, bits = "256"] = intMatch;
    const size2 = parseInt(bits) / 8;
    return numberToHex(value, {
      size: isArray ? 32 : size2,
      signed: baseType === "int"
    });
  }
  const bytesMatch = type.match(bytesRegex);
  if (bytesMatch) {
    const [_type, size2] = bytesMatch;
    if (parseInt(size2) !== (value.length - 2) / 2)
      throw new BytesSizeMismatchError({
        expectedSize: parseInt(size2),
        givenSize: (value.length - 2) / 2
      });
    return pad(value, { dir: "right", size: isArray ? 32 : null });
  }
  const arrayMatch = type.match(arrayRegex);
  if (arrayMatch && Array.isArray(value)) {
    const [_type, childType] = arrayMatch;
    let data = [];
    for (let i = 0; i < value.length; i++) {
      data.push(encode(childType, value[i], true));
    }
    return concat(data);
  }
  throw new UnsupportedPackedAbiType(type);
}

// src/utils/abi/formatAbiItemWithArgs.ts
function formatAbiItemWithArgs({
  abiItem,
  args,
  includeFunctionName = true,
  includeName = false
}) {
  if (!("name" in abiItem))
    return;
  if (!("inputs" in abiItem))
    return;
  if (!abiItem.inputs)
    return;
  return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map(
    (input, i) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i] === "object" ? stringify(args[i]) : args[i]}`
  ).join(", ")})`;
}

// src/utils/account.ts
function getAccount(account) {
  if (typeof account === "string") {
    if (!isAddress(account))
      throw new InvalidAddressError({ address: account });
    return { address: account, type: "json-rpc" };
  }
  if (!isAddress(account.address))
    throw new InvalidAddressError({ address: account.address });
  return {
    ...account,
    type: "local"
  };
}

// src/utils/promise/withCache.ts
var promiseCache = /* @__PURE__ */ new Map();
var responseCache = /* @__PURE__ */ new Map();
function getCache(cacheKey2) {
  const buildCache = (cacheKey3, cache) => ({
    clear: () => cache.delete(cacheKey3),
    get: () => cache.get(cacheKey3),
    set: (data) => cache.set(cacheKey3, data)
  });
  const promise = buildCache(cacheKey2, promiseCache);
  const response = buildCache(
    cacheKey2,
    responseCache
  );
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(fn, { cacheKey: cacheKey2, maxAge = Infinity }) {
  const cache = getCache(cacheKey2);
  const response = cache.response.get();
  if (response && maxAge > 0) {
    const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
    if (age < maxAge)
      return response.data;
  }
  let promise = cache.promise.get();
  if (!promise) {
    promise = fn();
    cache.promise.set(promise);
  }
  const data = await promise;
  cache.promise.clear();
  cache.response.set({ created: /* @__PURE__ */ new Date(), data });
  return data;
}

// src/utils/wait.ts
async function wait(time) {
  return new Promise((res) => setTimeout(res, time));
}

// src/utils/promise/withRetry.ts
function withRetry(fn, {
  delay: delay_ = 100,
  retryCount = 2,
  shouldRetry = () => true
} = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry = async ({ error }) => {
        const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
        if (delay)
          await wait(delay);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data = await fn();
        resolve(data);
      } catch (err) {
        if (count < retryCount && await shouldRetry({ count, error: err }))
          return retry({ error: err });
        reject(err);
      }
    };
    attemptRetry();
  });
}

// src/utils/promise/withTimeout.ts
function withTimeout(fn, {
  errorInstance,
  timeout,
  signal
}) {
  return new Promise((resolve, reject) => {
    ;
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        }
        resolve(await fn({ signal: _optionalChain([controller, 'optionalAccess', _45 => _45.signal]) }));
      } catch (err) {
        if (err.name === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}

// src/utils/buildRequest.ts
var isDeterministicError = (error) => {
  if ("code" in error)
    return error.code !== -32603 && error.code !== -32005;
  if (error instanceof HttpRequestError && error.status)
    return error.status !== 408 && error.status !== 413 && error.status !== 429 && error.status !== 500 && error.status !== 502 && error.status !== 503 && error.status !== 504;
  return false;
};
function buildRequest(request, {
  retryDelay = 150,
  retryCount = 3
} = {}) {
  return async (args) => withRetry(
    async () => {
      try {
        return await request(args);
      } catch (err_) {
        const err = err_;
        if (err.code === -32700)
          throw new ParseRpcError(err);
        if (err.code === -32600)
          throw new InvalidRequestRpcError(err);
        if (err.code === -32601)
          throw new MethodNotFoundRpcError(err);
        if (err.code === -32602)
          throw new InvalidParamsRpcError(err);
        if (err.code === -32603)
          throw new InternalRpcError(err);
        if (err.code === -32e3)
          throw new InvalidInputRpcError(err);
        if (err.code === -32001)
          throw new ResourceNotFoundRpcError(err);
        if (err.code === -32002)
          throw new ResourceUnavailableRpcError(err);
        if (err.code === -32003)
          throw new TransactionRejectedRpcError(err);
        if (err.code === -32004)
          throw new MethodNotSupportedRpcError(err);
        if (err.code === -32005)
          throw new LimitExceededRpcError(err);
        if (err.code === -32006)
          throw new JsonRpcVersionUnsupportedError(err);
        if (err.code === 4001)
          throw new UserRejectedRequestError(err);
        if (err.code === 4902)
          throw new SwitchChainError(err);
        if (err_ instanceof BaseError)
          throw err_;
        throw new UnknownRpcError(err);
      }
    },
    {
      delay: ({ count, error }) => {
        if (error && error instanceof HttpRequestError) {
          const retryAfter = _optionalChain([error, 'optionalAccess', _46 => _46.headers, 'optionalAccess', _47 => _47.get, 'call', _48 => _48("Retry-After")]);
          if (_optionalChain([retryAfter, 'optionalAccess', _49 => _49.match, 'call', _50 => _50(/\d/)]))
            return parseInt(retryAfter) * 1e3;
        }
        return ~~(1 << count) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error }) => !isDeterministicError(error)
    }
  );
}

// src/utils/chain.ts
function defineChain(chain) {
  return chain;
}

// src/utils/formatters/format.ts
function format3(data, { formatter }) {
  return formatter(data);
}
function defineFormatter({
  format: format4
}) {
  return ({
    exclude,
    format: formatOverride
  }) => (data) => {
    const formatted = format4(data);
    if (exclude) {
      for (const key of exclude) {
        delete formatted[key];
      }
    }
    return {
      ...formatted,
      ..._optionalChain([formatOverride, 'optionalCall', _51 => _51(data)])
    };
  };
}

// src/utils/formatters/transaction.ts
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction_.type === "legacy") {
    delete transaction_["accessList"];
    delete transaction_["maxFeePerGas"];
    delete transaction_["maxPriorityFeePerGas"];
  }
  if (transaction_.type === "eip2930") {
    delete transaction_["maxFeePerGas"];
    delete transaction_["maxPriorityFeePerGas"];
  }
  return transaction_;
}
var defineTransaction = defineFormatter({ format: formatTransaction });

// src/utils/formatters/block.ts
function formatBlock(block) {
  const transactions = _optionalChain([block, 'access', _52 => _52.transactions, 'optionalAccess', _53 => _53.map, 'call', _54 => _54((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  })]);
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter({ format: formatBlock });

// src/utils/formatters/extract.ts
function extract(value, { formatter }) {
  if (!formatter)
    return {};
  const keys = Object.keys(formatter({}));
  return keys.reduce((data, key) => {
    if (_optionalChain([value, 'optionalAccess', _55 => _55.hasOwnProperty, 'call', _56 => _56(key)])) {
      ;
      data[key] = value[key];
    }
    return data;
  }, {});
}

// src/utils/formatters/feeHistory.ts
function formatFeeHistory(feeHistory) {
  return {
    baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
    gasUsedRatio: feeHistory.gasUsedRatio,
    oldestBlock: BigInt(feeHistory.oldestBlock),
    reward: _optionalChain([feeHistory, 'access', _57 => _57.reward, 'optionalAccess', _58 => _58.map, 'call', _59 => _59(
      (reward) => reward.map((value) => BigInt(value))
    )])
  };
}

// src/utils/formatters/log.ts
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? BigInt(log.logIndex) : null,
    transactionIndex: log.transactionIndex ? BigInt(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// src/utils/formatters/transactionReceipt.ts
var statuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  return {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? statuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] : null
  };
}
var defineTransactionReceipt = defineFormatter({
  format: formatTransactionReceipt
});

// src/utils/formatters/transactionRequest.ts
function formatTransactionRequest(transactionRequest) {
  return {
    ...transactionRequest,
    gas: typeof transactionRequest.gas !== "undefined" ? numberToHex(transactionRequest.gas) : void 0,
    gasPrice: typeof transactionRequest.gasPrice !== "undefined" ? numberToHex(transactionRequest.gasPrice) : void 0,
    maxFeePerGas: typeof transactionRequest.maxFeePerGas !== "undefined" ? numberToHex(transactionRequest.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: typeof transactionRequest.maxPriorityFeePerGas !== "undefined" ? numberToHex(transactionRequest.maxPriorityFeePerGas) : void 0,
    nonce: typeof transactionRequest.nonce !== "undefined" ? numberToHex(transactionRequest.nonce) : void 0,
    value: typeof transactionRequest.value !== "undefined" ? numberToHex(transactionRequest.value) : void 0
  };
}
var defineTransactionRequest = defineFormatter({
  format: formatTransactionRequest
});

// src/utils/errors/getNodeError.ts
function containsNodeError(err) {
  return err instanceof TransactionRejectedRpcError || err instanceof InvalidInputRpcError || err instanceof RpcError && err.code === ExecutionRevertedError.code;
}
function getNodeError(err, args) {
  const message = err.details.toLowerCase();
  if (FeeCapTooHighError.nodeMessage.test(message))
    return new FeeCapTooHighError({
      cause: err,
      maxFeePerGas: _optionalChain([args, 'optionalAccess', _60 => _60.maxFeePerGas])
    });
  else if (FeeCapTooLowError.nodeMessage.test(message))
    return new FeeCapTooLowError({
      cause: err,
      maxFeePerGas: _optionalChain([args, 'optionalAccess', _61 => _61.maxFeePerGas])
    });
  else if (NonceTooHighError.nodeMessage.test(message))
    return new NonceTooHighError({ cause: err, nonce: _optionalChain([args, 'optionalAccess', _62 => _62.nonce]) });
  else if (NonceTooLowError.nodeMessage.test(message))
    return new NonceTooLowError({ cause: err, nonce: _optionalChain([args, 'optionalAccess', _63 => _63.nonce]) });
  else if (NonceMaxValueError.nodeMessage.test(message))
    return new NonceMaxValueError({ cause: err, nonce: _optionalChain([args, 'optionalAccess', _64 => _64.nonce]) });
  else if (InsufficientFundsError.nodeMessage.test(message))
    return new InsufficientFundsError({ cause: err });
  else if (IntrinsicGasTooHighError.nodeMessage.test(message))
    return new IntrinsicGasTooHighError({ cause: err, gas: _optionalChain([args, 'optionalAccess', _65 => _65.gas]) });
  else if (IntrinsicGasTooLowError.nodeMessage.test(message))
    return new IntrinsicGasTooLowError({ cause: err, gas: _optionalChain([args, 'optionalAccess', _66 => _66.gas]) });
  else if (TransactionTypeNotSupportedError.nodeMessage.test(message))
    return new TransactionTypeNotSupportedError({ cause: err });
  else if (TipAboveFeeCapError.nodeMessage.test(message))
    return new TipAboveFeeCapError({
      cause: err,
      maxFeePerGas: _optionalChain([args, 'optionalAccess', _67 => _67.maxFeePerGas]),
      maxPriorityFeePerGas: _optionalChain([args, 'optionalAccess', _68 => _68.maxPriorityFeePerGas])
    });
  else if (message.match(ExecutionRevertedError.nodeMessage) || "code" in err.cause && _optionalChain([err, 'access', _69 => _69.cause, 'optionalAccess', _70 => _70.code]) === ExecutionRevertedError.code)
    return new ExecutionRevertedError({
      cause: err,
      message: err.cause.details
    });
  return new UnknownNodeError({
    cause: err.cause.cause
  });
}

// src/utils/errors/getCallError.ts
function getCallError(err, {
  docsPath: docsPath5,
  ...args
}) {
  let cause = err;
  if (containsNodeError(err))
    cause = getNodeError(err, args);
  return new CallExecutionError(cause, {
    docsPath: docsPath5,
    ...args
  });
}

// src/utils/errors/getContractError.ts
var EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err, {
  abi,
  address,
  args,
  docsPath: docsPath5,
  functionName,
  sender
}) {
  const { code, data, message } = err instanceof RawContractError ? err : err instanceof CallExecutionError || err instanceof EstimateGasExecutionError ? _optionalChain([err, 'access', _71 => _71.cause, 'optionalAccess', _72 => _72.cause, 'optionalAccess', _73 => _73.cause]) || {} : err.cause || {};
  let cause = err;
  if (err instanceof AbiDecodingZeroDataError) {
    cause = new ContractFunctionZeroDataError({ functionName });
  } else if (code === EXECUTION_REVERTED_ERROR_CODE && (data || message)) {
    cause = new ContractFunctionRevertedError({
      abi,
      data,
      functionName,
      message
    });
  }
  return new ContractFunctionExecutionError(cause, {
    abi,
    args,
    contractAddress: address,
    docsPath: docsPath5,
    functionName,
    sender
  });
}

// src/utils/errors/getEstimateGasError.ts
function getEstimateGasError(err, {
  docsPath: docsPath5,
  ...args
}) {
  let cause = err;
  if (containsNodeError(err))
    cause = getNodeError(err, args);
  return new EstimateGasExecutionError(cause, {
    docsPath: docsPath5,
    ...args
  });
}

// src/utils/errors/getTransactionError.ts
function getTransactionError(err, {
  docsPath: docsPath5,
  ...args
}) {
  let cause = err;
  if (containsNodeError(err))
    cause = getNodeError(err, args);
  return new TransactionExecutionError(cause, {
    docsPath: docsPath5,
    ...args
  });
}

// src/utils/rpc.ts
var _isomorphicws = require('isomorphic-ws'); var _isomorphicws2 = _interopRequireDefault(_isomorphicws);

// src/utils/stringify.ts
var stringify = (value, replacer, space) => JSON.stringify(
  value,
  (key, value_) => {
    const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
    return typeof replacer === "function" ? replacer(key, value2) : value2;
  },
  space
);

// src/utils/rpc.ts
var id = 0;
async function http(url, { body, fetchOptions = {}, timeout = 1e4 }) {
  const { headers, method, signal: signal_ } = fetchOptions;
  try {
    const response = await withTimeout(
      async ({ signal }) => {
        const response2 = await fetch(url, {
          ...fetchOptions,
          body: stringify({ jsonrpc: "2.0", id: id++, ...body }),
          headers: {
            ...headers,
            "Content-Type": "application/json"
          },
          method: method || "POST",
          signal: signal_ || (timeout > 0 ? signal : void 0)
        });
        return response2;
      },
      {
        errorInstance: new TimeoutError({ body, url }),
        timeout,
        signal: true
      }
    );
    let data;
    if (_optionalChain([response, 'access', _74 => _74.headers, 'access', _75 => _75.get, 'call', _76 => _76("Content-Type"), 'optionalAccess', _77 => _77.startsWith, 'call', _78 => _78("application/json")])) {
      data = await response.json();
    } else {
      data = await response.text();
    }
    if (!response.ok) {
      throw new HttpRequestError({
        body,
        details: stringify(data.error) || response.statusText,
        headers: response.headers,
        status: response.status,
        url
      });
    }
    if (data.error) {
      throw new RpcError({ body, error: data.error, url });
    }
    return data;
  } catch (err) {
    if (err instanceof HttpRequestError)
      throw err;
    if (err instanceof RpcError)
      throw err;
    if (err instanceof TimeoutError)
      throw err;
    throw new HttpRequestError({
      body,
      details: err.message,
      url
    });
  }
}
var sockets = /* @__PURE__ */ new Map();
async function getSocket(url_) {
  const url = new URL(url_);
  const urlKey = url.toString();
  let socket = sockets.get(urlKey);
  if (socket)
    return socket;
  const webSocket2 = new (0, _isomorphicws2.default)(url);
  const requests = /* @__PURE__ */ new Map();
  const subscriptions = /* @__PURE__ */ new Map();
  const onMessage = ({ data }) => {
    const message = JSON.parse(data);
    const isSubscription = message.method === "eth_subscription";
    const id2 = isSubscription ? message.params.subscription : message.id;
    const cache = isSubscription ? subscriptions : requests;
    const callback = cache.get(id2);
    if (callback)
      callback({ data });
    if (!isSubscription)
      cache.delete(id2);
  };
  const onClose = () => {
    sockets.delete(urlKey);
    webSocket2.removeEventListener("close", onClose);
    webSocket2.removeEventListener("message", onMessage);
  };
  webSocket2.addEventListener("close", onClose);
  webSocket2.addEventListener("message", onMessage);
  if (webSocket2.readyState === _isomorphicws2.default.CONNECTING) {
    await new Promise((resolve, reject) => {
      if (!webSocket2)
        return;
      webSocket2.onopen = resolve;
      webSocket2.onerror = reject;
    });
  }
  socket = Object.assign(webSocket2, {
    requests,
    subscriptions
  });
  sockets.set(urlKey, socket);
  return socket;
}
function webSocket(socket, {
  body,
  onData,
  onError
}) {
  if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING)
    throw new WebSocketRequestError({
      body,
      url: socket.url,
      details: "Socket is closed."
    });
  const id_ = id++;
  const callback = ({ data }) => {
    const message = JSON.parse(data);
    if (typeof message.id === "number" && id_ !== message.id)
      return;
    if (message.error) {
      _optionalChain([onError, 'optionalCall', _79 => _79(new RpcError({ body, error: message.error, url: socket.url }))]);
    } else {
      _optionalChain([onData, 'optionalCall', _80 => _80(message)]);
    }
    if (body.method === "eth_subscribe" && typeof message.result === "string") {
      socket.subscriptions.set(message.result, callback);
    }
    if (body.method === "eth_unsubscribe") {
      socket.subscriptions.delete(_optionalChain([body, 'access', _81 => _81.params, 'optionalAccess', _82 => _82[0]]));
    }
  };
  socket.requests.set(id_, callback);
  socket.send(JSON.stringify({ jsonrpc: "2.0", ...body, id: id_ }));
  return socket;
}
async function webSocketAsync(socket, {
  body,
  timeout = 1e4
}) {
  return withTimeout(
    () => new Promise(
      (onData, onError) => rpc.webSocket(socket, {
        body,
        onData,
        onError
      })
    ),
    {
      errorInstance: new TimeoutError({ body, url: socket.url }),
      timeout
    }
  );
}
var rpc = {
  http,
  webSocket,
  webSocketAsync
};

// src/utils/transaction/assertRequest.ts
function assertRequest(args) {
  const { account, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
  if (account && !isAddress(account.address))
    throw new InvalidAddressError({ address: account.address });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
    throw new FeeConflictError();
  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}

// src/actions/public/call.ts
async function call(client, args) {
  const {
    account,
    blockNumber,
    blockTag = "latest",
    accessList,
    data,
    gas,
    gasPrice,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    to,
    value,
    ...rest
  } = args;
  try {
    assertRequest(args);
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const formatter = _optionalChain([client, 'access', _83 => _83.chain, 'optionalAccess', _84 => _84.formatters, 'optionalAccess', _85 => _85.transactionRequest]);
    const request_ = format3(
      {
        from: _optionalChain([account, 'optionalAccess', _86 => _86.address]),
        accessList,
        data,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value,
        // Pick out extra data that might exist on the chain's transaction request type.
        ...extract(rest, { formatter })
      },
      {
        formatter: formatter || formatTransactionRequest
      }
    );
    const response = await client.request({
      method: "eth_call",
      params: [request_, blockNumberHex || blockTag]
    });
    if (response === "0x")
      return { data: void 0 };
    return { data: response };
  } catch (err) {
    throw getCallError(err, {
      ...args,
      chain: client.chain
    });
  }
}

// src/actions/public/simulateContract.ts
async function simulateContract(client, {
  abi,
  address,
  args,
  functionName,
  ...callRequest
}) {
  const calldata = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const { data } = await call(client, {
      data: calldata,
      to: address,
      ...callRequest
    });
    const result = decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
    return {
      result,
      request: {
        abi,
        address,
        args,
        functionName,
        ...callRequest
      }
    };
  } catch (err) {
    throw getContractError(err, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: _optionalChain([callRequest, 'access', _87 => _87.account, 'optionalAccess', _88 => _88.address])
    });
  }
}

// src/actions/public/createPendingTransactionFilter.ts
async function createPendingTransactionFilter(client) {
  const id2 = await client.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id: id2, type: "transaction" };
}

// src/actions/public/createBlockFilter.ts
async function createBlockFilter(client) {
  const id2 = await client.request({
    method: "eth_newBlockFilter"
  });
  return { id: id2, type: "block" };
}

// src/actions/public/createEventFilter.ts
async function createEventFilter(client, {
  address,
  args,
  event,
  fromBlock,
  toBlock
} = {}) {
  let topics = [];
  if (event)
    topics = encodeEventTopics({
      abi: [event],
      eventName: event.name,
      args
    });
  const id2 = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        ...topics.length ? { topics } : {}
      }
    ]
  });
  return {
    abi: event ? [event] : void 0,
    args,
    eventName: event ? event.name : void 0,
    id: id2,
    type: "event"
  };
}

// src/actions/public/createContractEventFilter.ts
async function createContractEventFilter(client, {
  address,
  abi,
  args,
  eventName,
  fromBlock,
  toBlock
}) {
  const topics = eventName ? encodeEventTopics({
    abi,
    args,
    eventName
  }) : void 0;
  const id2 = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi,
    args,
    eventName,
    id: id2,
    type: "event"
  };
}

// src/actions/public/estimateGas.ts
async function estimateGas(client, args) {
  try {
    const {
      account,
      accessList,
      blockNumber,
      blockTag = "latest",
      data,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value,
      ...rest
    } = args.account.type === "local" ? await prepareRequest(client, args) : args;
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    assertRequest(args);
    const formatter = _optionalChain([client, 'access', _89 => _89.chain, 'optionalAccess', _90 => _90.formatters, 'optionalAccess', _91 => _91.transactionRequest]);
    const request = format3(
      {
        from: account.address,
        accessList,
        data,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value,
        // Pick out extra data that might exist on the chain's transaction request type.
        ...extract(rest, { formatter })
      },
      {
        formatter: formatter || formatTransactionRequest
      }
    );
    const balance = await client.request({
      method: "eth_estimateGas",
      params: [request, blockNumberHex || blockTag]
    });
    return BigInt(balance);
  } catch (err) {
    throw getEstimateGasError(err, {
      ...args,
      chain: client.chain
    });
  }
}

// src/actions/public/estimateContractGas.ts
async function estimateContractGas(client, {
  abi,
  address,
  args,
  functionName,
  ...request
}) {
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const gas = await estimateGas(client, {
      data,
      to: address,
      ...request
    });
    return gas;
  } catch (err) {
    throw getContractError(err, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: _optionalChain([request, 'access', _92 => _92.account, 'optionalAccess', _93 => _93.address])
    });
  }
}

// src/actions/public/getBalance.ts
async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const balance = await client.request({
    method: "eth_getBalance",
    params: [address, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}

// src/actions/public/getBlock.ts
async function getBlock(client, {
  blockHash,
  blockNumber,
  blockTag = "latest",
  includeTransactions = false
} = {}) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let block = null;
  if (blockHash) {
    block = await client.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    });
  } else {
    block = await client.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    });
  }
  if (!block)
    throw new BlockNotFoundError({ blockHash, blockNumber });
  return format3(block, {
    formatter: _optionalChain([client, 'access', _94 => _94.chain, 'optionalAccess', _95 => _95.formatters, 'optionalAccess', _96 => _96.block]) || formatBlock
  });
}

// src/actions/public/getBlockNumber.ts
var cacheKey = (id2) => `blockNumber.${id2}`;
function getBlockNumberCache(id2) {
  return getCache(cacheKey(id2));
}
async function getBlockNumber(client, { maxAge = client.pollingInterval } = {}) {
  const blockNumberHex = await withCache(
    () => client.request({
      method: "eth_blockNumber"
    }),
    { cacheKey: cacheKey(client.uid), maxAge }
  );
  return BigInt(blockNumberHex);
}

// src/actions/public/getBlockTransactionCount.ts
async function getBlockTransactionCount(client, {
  blockHash,
  blockNumber,
  blockTag = "latest"
} = {}) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let count = null;
  if (blockHash) {
    count = await client.request({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    });
  } else {
    count = await client.request({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumberHex || blockTag]
    });
  }
  return hexToNumber(count);
}

// src/actions/public/getBytecode.ts
async function getBytecode(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const hex = await client.request({
    method: "eth_getCode",
    params: [address, blockNumberHex || blockTag]
  });
  if (hex === "0x")
    return void 0;
  return hex;
}

// src/actions/public/getChainId.ts
async function getChainId(client) {
  const chainIdHex = await client.request({ method: "eth_chainId" });
  return hexToNumber(chainIdHex);
}

// src/actions/public/getFeeHistory.ts
async function getFeeHistory(client, {
  blockCount,
  blockNumber,
  blockTag = "latest",
  rewardPercentiles
}) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const feeHistory = await client.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(blockCount),
      blockNumberHex || blockTag,
      rewardPercentiles
    ]
  });
  return formatFeeHistory(feeHistory);
}

// src/actions/public/getFilterChanges.ts
async function getFilterChanges(client, {
  filter
}) {
  const logs = await client.request({
    method: "eth_getFilterChanges",
    params: [filter.id]
  });
  return logs.map((log) => {
    if (typeof log === "string")
      return log;
    const { eventName, args } = "abi" in filter && filter.abi ? decodeEventLog({
      abi: filter.abi,
      data: log.data,
      topics: log.topics
    }) : { eventName: void 0, args: void 0 };
    return formatLog(log, { args, eventName });
  });
}

// src/actions/public/getFilterLogs.ts
async function getFilterLogs(client, { filter }) {
  const logs = await client.request({
    method: "eth_getFilterLogs",
    params: [filter.id]
  });
  return logs.map((log) => {
    const { eventName, args } = "abi" in filter && filter.abi ? decodeEventLog({
      abi: filter.abi,
      data: log.data,
      topics: log.topics
    }) : { eventName: void 0, args: void 0 };
    return formatLog(log, { args, eventName });
  });
}

// src/actions/public/getGasPrice.ts
async function getGasPrice(client) {
  const gasPrice = await client.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}

// src/actions/public/getLogs.ts
async function getLogs(client, {
  address,
  blockHash,
  fromBlock,
  toBlock,
  event,
  args
} = {}) {
  let topics = [];
  if (event)
    topics = encodeEventTopics({
      abi: [event],
      eventName: event.name,
      args
    });
  let logs;
  if (blockHash) {
    logs = await client.request({
      method: "eth_getLogs",
      params: [{ address, topics, blockHash }]
    });
  } else {
    logs = await client.request({
      method: "eth_getLogs",
      params: [
        {
          address,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
        }
      ]
    });
  }
  return logs.map((log) => {
    const { eventName, args: args2 } = event ? decodeEventLog({
      abi: [event],
      data: log.data,
      topics: log.topics
    }) : { eventName: void 0, args: void 0 };
    return formatLog(log, { args: args2, eventName });
  });
}

// src/actions/public/getStorageAt.ts
async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const data = await client.request({
    method: "eth_getStorageAt",
    params: [address, slot, blockNumberHex || blockTag]
  });
  return data;
}

// src/actions/public/getTransaction.ts
async function getTransaction(client, {
  blockHash,
  blockNumber,
  blockTag = "latest",
  hash: hash2,
  index
}) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let transaction = null;
  if (hash2) {
    transaction = await client.request({
      method: "eth_getTransactionByHash",
      params: [hash2]
    });
  } else if (blockHash) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, numberToHex(index)]
    });
  } else if (blockNumberHex || blockTag) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumberHex || blockTag, numberToHex(index)]
    });
  }
  if (!transaction)
    throw new TransactionNotFoundError({
      blockHash,
      blockNumber,
      blockTag,
      hash: hash2,
      index
    });
  return format3(transaction, {
    formatter: _optionalChain([client, 'access', _97 => _97.chain, 'optionalAccess', _98 => _98.formatters, 'optionalAccess', _99 => _99.transaction]) || formatTransaction
  });
}

// src/actions/public/getTransactionConfirmations.ts
async function getTransactionConfirmations(client, { hash: hash2, transactionReceipt }) {
  const [blockNumber, transaction] = await Promise.all([
    getBlockNumber(client),
    hash2 ? getTransaction(client, { hash: hash2 }) : void 0
  ]);
  const transactionBlockNumber = _optionalChain([transactionReceipt, 'optionalAccess', _100 => _100.blockNumber]) || _optionalChain([transaction, 'optionalAccess', _101 => _101.blockNumber]);
  if (!transactionBlockNumber)
    return 0n;
  return blockNumber - transactionBlockNumber + 1n;
}

// src/actions/public/getTransactionCount.ts
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  });
  return hexToNumber(count);
}

// src/actions/public/getTransactionReceipt.ts
async function getTransactionReceipt(client, { hash: hash2 }) {
  const receipt = await client.request({
    method: "eth_getTransactionReceipt",
    params: [hash2]
  });
  if (!receipt)
    throw new TransactionReceiptNotFoundError({ hash: hash2 });
  return format3(receipt, {
    formatter: _optionalChain([client, 'access', _102 => _102.chain, 'optionalAccess', _103 => _103.formatters, 'optionalAccess', _104 => _104.transactionReceipt]) || formatTransactionReceipt
  });
}

// src/actions/public/readContract.ts
async function readContract(client, {
  abi,
  address,
  args,
  functionName,
  ...callRequest
}) {
  const calldata = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const { data } = await call(client, {
      data: calldata,
      to: address,
      ...callRequest
    });
    return decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
  } catch (err) {
    throw getContractError(err, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}

// src/actions/public/multicall.ts
async function multicall(client, args) {
  const {
    allowFailure = true,
    blockNumber,
    blockTag,
    contracts,
    multicallAddress
  } = args;
  const calls = contracts.map(({ abi, address, args: args2, functionName }) => {
    try {
      const callData = encodeFunctionData({
        abi,
        args: args2,
        functionName
      });
      return {
        allowFailure: true,
        callData,
        target: address
      };
    } catch (err) {
      const error = getContractError(err, {
        abi,
        address,
        args: args2,
        docsPath: "/docs/contract/multicall",
        functionName
      });
      if (!allowFailure)
        throw error;
      return {
        allowFailure: true,
        callData: "0x",
        target: address
      };
    }
  });
  const results = await readContract(client, {
    abi: multicall3Abi,
    address: multicallAddress,
    args: [calls],
    blockNumber,
    blockTag,
    functionName: "aggregate3"
  });
  return results.map(({ returnData, success }, i) => {
    const { callData } = calls[i];
    const { abi, address, functionName, args: args2 } = contracts[i];
    try {
      if (callData === "0x")
        throw new AbiDecodingZeroDataError();
      if (!success)
        throw new RawContractError({ data: returnData });
      const result = decodeFunctionResult({
        abi,
        data: returnData,
        functionName
      });
      return { result, status: "success" };
    } catch (err) {
      const error = getContractError(err, {
        abi,
        address,
        args: args2,
        docsPath: "/docs/contract/multicall",
        functionName
      });
      if (!allowFailure)
        throw error;
      return { error, result: void 0, status: "failure" };
    }
  });
}

// src/actions/public/uninstallFilter.ts
async function uninstallFilter(client, { filter }) {
  return client.request({
    method: "eth_uninstallFilter",
    params: [filter.id]
  });
}

// src/utils/observe.ts
var listenersCache = /* @__PURE__ */ new Map();
var cleanupCache = /* @__PURE__ */ new Map();
var callbackCount = 0;
function observe(observerId, callbacks, fn) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners2 = getListeners();
    listenersCache.set(
      observerId,
      listeners2.filter((cb) => cb.id !== callbackId)
    );
  };
  const unwatch = () => {
    const cleanup2 = cleanupCache.get(observerId);
    if (getListeners().length === 1 && cleanup2)
      cleanup2();
    unsubscribe();
  };
  const listeners = getListeners();
  listenersCache.set(observerId, [
    ...listeners,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners && listeners.length > 0)
    return unwatch;
  let emit = {};
  for (const key in callbacks) {
    emit[key] = (...args) => {
      const listeners2 = getListeners();
      if (listeners2.length === 0)
        return;
      listeners2.forEach((listener) => _optionalChain([listener, 'access', _105 => _105.fns, 'access', _106 => _106[key], 'optionalCall', _107 => _107(...args)]));
    };
  }
  const cleanup = fn(emit);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}

// src/actions/public/waitForTransactionReceipt.ts
async function waitForTransactionReceipt(client, {
  confirmations = 1,
  hash: hash2,
  onReplaced,
  pollingInterval = client.pollingInterval,
  timeout
}) {
  const observerId = JSON.stringify([
    "waitForTransactionReceipt",
    client.uid,
    hash2
  ]);
  let transaction;
  let replacedTransaction;
  let receipt;
  return new Promise((resolve, reject) => {
    if (timeout)
      setTimeout(
        () => reject(new WaitForTransactionReceiptTimeoutError({ hash: hash2 })),
        timeout
      );
    const _unobserve = observe(
      observerId,
      { onReplaced, resolve, reject },
      (emit) => {
        const unwatch = watchBlockNumber(client, {
          emitMissed: true,
          emitOnBegin: true,
          pollingInterval,
          async onBlockNumber(blockNumber) {
            const done = async (fn) => {
              unwatch();
              fn();
              _unobserve();
            };
            try {
              if (receipt) {
                if (blockNumber - receipt.blockNumber + 1n < confirmations)
                  return;
                done(() => emit.resolve(receipt));
                return;
              }
              transaction = await getTransaction(client, { hash: hash2 });
              receipt = await getTransactionReceipt(client, { hash: hash2 });
              if (blockNumber - receipt.blockNumber + 1n < confirmations)
                return;
              done(() => emit.resolve(receipt));
            } catch (err) {
              if (transaction && (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError)) {
                replacedTransaction = transaction;
                const block = await getBlock(client, {
                  blockNumber,
                  includeTransactions: true
                });
                const replacementTransaction = block.transactions.find(
                  ({ from, nonce }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce
                );
                if (!replacementTransaction)
                  return;
                receipt = await getTransactionReceipt(client, {
                  hash: replacementTransaction.hash
                });
                if (blockNumber - receipt.blockNumber + 1n < confirmations)
                  return;
                let reason = "replaced";
                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                  reason = "repriced";
                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                  reason = "cancelled";
                }
                done(() => {
                  _optionalChain([emit, 'access', _108 => _108.onReplaced, 'optionalCall', _109 => _109({
                    reason,
                    replacedTransaction,
                    transaction: replacementTransaction,
                    transactionReceipt: receipt
                  })]);
                  emit.resolve(receipt);
                });
              } else {
                done(() => emit.reject(err));
              }
            }
          }
        });
        return unwatch;
      }
    );
  });
}

// src/utils/poll.ts
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch = async () => {
    let data;
    if (emitOnBegin)
      data = await fn({ unpoll: unwatch });
    const initialWait = await _asyncNullishCoalesce(await _optionalChain([initialWaitTime, 'optionalCall', _110 => _110(data)]), async () => ( interval));
    await wait(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await fn({ unpoll: unwatch });
      await wait(interval);
      poll2();
    };
    poll2();
  };
  watch();
  return unwatch;
}

// src/actions/public/watchBlockNumber.ts
function watchBlockNumber(client, {
  emitOnBegin = false,
  emitMissed = false,
  onBlockNumber,
  onError,
  pollingInterval = client.pollingInterval
}) {
  const observerId = JSON.stringify([
    "watchBlockNumber",
    client.uid,
    emitOnBegin,
    emitMissed,
    pollingInterval
  ]);
  let prevBlockNumber;
  return observe(
    observerId,
    { onBlockNumber, onError },
    (emit) => poll(
      async () => {
        try {
          const blockNumber = await getBlockNumber(client, { maxAge: 0 });
          if (prevBlockNumber) {
            if (blockNumber === prevBlockNumber)
              return;
            if (blockNumber - prevBlockNumber > 1 && emitMissed) {
              for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
                emit.onBlockNumber(i, prevBlockNumber);
                prevBlockNumber = i;
              }
            }
          }
          prevBlockNumber = blockNumber;
          emit.onBlockNumber(blockNumber, prevBlockNumber);
        } catch (err) {
          _optionalChain([emit, 'access', _111 => _111.onError, 'optionalCall', _112 => _112(err)]);
        }
      },
      {
        emitOnBegin,
        interval: pollingInterval
      }
    )
  );
}

// src/actions/public/watchBlocks.ts
function watchBlocks(client, {
  blockTag = "latest",
  emitMissed = false,
  emitOnBegin = false,
  onBlock,
  onError,
  includeTransactions = false,
  pollingInterval = client.pollingInterval
}) {
  const observerId = JSON.stringify([
    "watchBlocks",
    client.uid,
    emitMissed,
    emitOnBegin,
    includeTransactions,
    pollingInterval
  ]);
  let prevBlock;
  return observe(
    observerId,
    { onBlock, onError },
    (emit) => poll(
      async () => {
        try {
          const block = await getBlock(client, {
            blockTag,
            includeTransactions
          });
          if (block.number && _optionalChain([prevBlock, 'optionalAccess', _113 => _113.number])) {
            if (block.number === prevBlock.number)
              return;
            if (block.number - prevBlock.number > 1 && emitMissed) {
              for (let i = _optionalChain([prevBlock, 'optionalAccess', _114 => _114.number]) + 1n; i < block.number; i++) {
                const block2 = await getBlock(client, {
                  blockNumber: i,
                  includeTransactions
                });
                emit.onBlock(block2, prevBlock);
                prevBlock = block2;
              }
            }
          }
          emit.onBlock(block, prevBlock);
          prevBlock = block;
        } catch (err) {
          _optionalChain([emit, 'access', _115 => _115.onError, 'optionalCall', _116 => _116(err)]);
        }
      },
      {
        emitOnBegin,
        interval: pollingInterval
      }
    )
  );
}

// src/actions/public/watchContractEvent.ts
function watchContractEvent(client, {
  abi,
  address,
  args,
  batch = true,
  eventName,
  onError,
  onLogs,
  pollingInterval = client.pollingInterval
}) {
  const observerId = JSON.stringify([
    "watchContractEvent",
    address,
    args,
    batch,
    client.uid,
    eventName,
    pollingInterval
  ]);
  return observe(observerId, { onLogs, onError }, (emit) => {
    let currentBlockNumber;
    let filter;
    let initialized = false;
    const unwatch = poll(
      async () => {
        if (!initialized) {
          try {
            filter = await createContractEventFilter(client, {
              abi,
              address,
              args,
              eventName
            });
          } catch (e) {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getFilterChanges(client, { filter });
          } else {
            const blockNumber = await getBlockNumber(client);
            if (currentBlockNumber && currentBlockNumber !== blockNumber) {
              logs = await getLogs(client, {
                address,
                args,
                fromBlock: blockNumber,
                toBlock: blockNumber,
                event: getAbiItem({
                  abi,
                  name: eventName
                })
              });
            } else {
              logs = [];
            }
            currentBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            logs.forEach((log) => emit.onLogs([log]));
        } catch (err) {
          _optionalChain([emit, 'access', _117 => _117.onError, 'optionalCall', _118 => _118(err)]);
        }
      },
      {
        emitOnBegin: true,
        interval: pollingInterval
      }
    );
    return async () => {
      if (filter)
        await uninstallFilter(client, { filter });
      unwatch();
    };
  });
}

// src/actions/public/watchEvent.ts
function watchEvent(client, {
  address,
  args,
  batch = true,
  event,
  onError,
  onLogs,
  pollingInterval = client.pollingInterval
}) {
  const observerId = JSON.stringify([
    "watchEvent",
    address,
    args,
    batch,
    client.uid,
    event,
    pollingInterval
  ]);
  return observe(observerId, { onLogs, onError }, (emit) => {
    let currentBlockNumber;
    let filter;
    let initialized = false;
    const unwatch = poll(
      async () => {
        if (!initialized) {
          try {
            filter = await createEventFilter(client, {
              address,
              args,
              event
            });
          } catch (e2) {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getFilterChanges(client, { filter });
          } else {
            const blockNumber = await getBlockNumber(client);
            if (currentBlockNumber && currentBlockNumber !== blockNumber) {
              logs = await getLogs(client, {
                address,
                args,
                fromBlock: blockNumber,
                toBlock: blockNumber,
                event
              });
            } else {
              logs = [];
            }
            currentBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            logs.forEach((log) => emit.onLogs([log]));
        } catch (err) {
          _optionalChain([emit, 'access', _119 => _119.onError, 'optionalCall', _120 => _120(err)]);
        }
      },
      {
        emitOnBegin: true,
        interval: pollingInterval
      }
    );
    return async () => {
      if (filter)
        await uninstallFilter(client, { filter });
      unwatch();
    };
  });
}

// src/actions/public/watchPendingTransactions.ts
function watchPendingTransactions(client, {
  batch = true,
  onError,
  onTransactions,
  pollingInterval = client.pollingInterval
}) {
  const observerId = JSON.stringify([
    "watchPendingTransactions",
    client.uid,
    batch,
    pollingInterval
  ]);
  return observe(observerId, { onTransactions, onError }, (emit) => {
    let filter;
    const unwatch = poll(
      async () => {
        try {
          if (!filter) {
            try {
              filter = await createPendingTransactionFilter(client);
              return;
            } catch (err) {
              unwatch();
              throw err;
            }
          }
          const hashes = await getFilterChanges(client, { filter });
          if (hashes.length === 0)
            return;
          if (batch)
            emit.onTransactions(hashes);
          else
            hashes.forEach((hash2) => emit.onTransactions([hash2]));
        } catch (err) {
          _optionalChain([emit, 'access', _121 => _121.onError, 'optionalCall', _122 => _122(err)]);
        }
      },
      {
        emitOnBegin: true,
        interval: pollingInterval
      }
    );
    return async () => {
      if (filter)
        await uninstallFilter(client, { filter });
      unwatch();
    };
  });
}

// src/actions/test/dropTransaction.ts
async function dropTransaction(client, { hash: hash2 }) {
  return await client.request({
    method: `${client.mode}_dropTransaction`,
    params: [hash2]
  });
}

// src/actions/test/getAutomine.ts
async function getAutomine(client) {
  return await client.request({
    method: `${client.mode}_getAutomine`
  });
}

// src/actions/test/getTxpoolContent.ts
async function getTxpoolContent(client) {
  return await client.request({
    method: "txpool_content"
  });
}

// src/actions/test/getTxpoolStatus.ts
async function getTxpoolStatus(client) {
  const { pending, queued } = await client.request({
    method: "txpool_status"
  });
  return {
    pending: hexToNumber(pending),
    queued: hexToNumber(queued)
  };
}

// src/actions/test/impersonateAccount.ts
async function impersonateAccount(client, { address }) {
  return await client.request({
    method: `${client.mode}_impersonateAccount`,
    params: [address]
  });
}

// src/actions/test/increaseTime.ts
async function increaseTime(client, { seconds }) {
  return await client.request({
    method: "evm_increaseTime",
    params: [numberToHex(seconds)]
  });
}

// src/actions/test/inspectTxpool.ts
async function inspectTxpool(client) {
  return await client.request({
    method: "txpool_inspect"
  });
}

// src/actions/test/mine.ts
async function mine(client, { blocks, interval }) {
  return await client.request({
    method: `${client.mode}_mine`,
    params: [numberToHex(blocks), numberToHex(interval || 0)]
  });
}

// src/actions/test/removeBlockTimestampInterval.ts
async function removeBlockTimestampInterval(client) {
  return await client.request({
    method: `${client.mode}_removeBlockTimestampInterval`
  });
}

// src/actions/test/reset.ts
async function reset(client, { blockNumber, jsonRpcUrl } = {}) {
  return await client.request({
    method: `${client.mode}_reset`,
    params: [{ forking: { blockNumber: Number(blockNumber), jsonRpcUrl } }]
  });
}

// src/actions/test/revert.ts
async function revert(client, { id: id2 }) {
  return await client.request({
    method: "evm_revert",
    params: [id2]
  });
}

// src/actions/test/sendUnsignedTransaction.ts
async function sendUnsignedTransaction(client, request) {
  const request_ = formatTransactionRequest(request);
  const hash2 = await client.request({
    method: "eth_sendUnsignedTransaction",
    params: [request_]
  });
  return hash2;
}

// src/actions/test/setAutomine.ts
async function setAutomine(client, enabled) {
  return await client.request({
    method: "evm_setAutomine",
    params: [enabled]
  });
}

// src/actions/test/setBalance.ts
async function setBalance(client, { address, value }) {
  return await client.request({
    method: `${client.mode}_setBalance`,
    params: [address, numberToHex(value)]
  });
}

// src/actions/test/setBlockGasLimit.ts
async function setBlockGasLimit(client, { gasLimit }) {
  return await client.request({
    method: "evm_setBlockGasLimit",
    params: [numberToHex(gasLimit)]
  });
}

// src/actions/test/setBlockTimestampInterval.ts
async function setBlockTimestampInterval(client, { interval }) {
  return await client.request({
    method: `${client.mode}_setBlockTimestampInterval`,
    params: [interval]
  });
}

// src/actions/test/setCode.ts
async function setCode(client, { address, bytecode }) {
  return await client.request({
    method: `${client.mode}_setCode`,
    params: [address, bytecode]
  });
}

// src/actions/test/setCoinbase.ts
async function setCoinbase(client, { address }) {
  return await client.request({
    method: `${client.mode}_setCoinbase`,
    params: [address]
  });
}

// src/actions/test/setIntervalMining.ts
async function setIntervalMining(client, { interval }) {
  return await client.request({
    method: "evm_setIntervalMining",
    params: [interval]
  });
}

// src/actions/test/setLoggingEnabled.ts
async function setLoggingEnabled(client, enabled) {
  return await client.request({
    method: `${client.mode}_setLoggingEnabled`,
    params: [enabled]
  });
}

// src/actions/test/setMinGasPrice.ts
async function setMinGasPrice(client, { gasPrice }) {
  return await client.request({
    method: `${client.mode}_setMinGasPrice`,
    params: [numberToHex(gasPrice)]
  });
}

// src/actions/test/setNextBlockBaseFeePerGas.ts
async function setNextBlockBaseFeePerGas(client, { baseFeePerGas }) {
  return await client.request({
    method: `${client.mode}_setNextBlockBaseFeePerGas`,
    params: [numberToHex(baseFeePerGas)]
  });
}

// src/actions/test/setNextBlockTimestamp.ts
async function setNextBlockTimestamp(client, { timestamp }) {
  return await client.request({
    method: "evm_setNextBlockTimestamp",
    params: [numberToHex(timestamp)]
  });
}

// src/actions/test/setNonce.ts
async function setNonce(client, { address, nonce }) {
  return await client.request({
    method: `${client.mode}_setNonce`,
    params: [address, numberToHex(nonce)]
  });
}

// src/actions/test/setRpcUrl.ts
async function setRpcUrl(client, jsonRpcUrl) {
  return await client.request({
    method: `${client.mode}_setRpcUrl`,
    params: [jsonRpcUrl]
  });
}

// src/actions/test/setStorageAt.ts
async function setStorageAt(client, { address, index, value }) {
  return await client.request({
    method: `${client.mode}_setStorageAt`,
    params: [
      address,
      typeof index === "number" ? numberToHex(index) : index,
      value
    ]
  });
}

// src/actions/test/snapshot.ts
async function snapshot(client) {
  return await client.request({
    method: "evm_snapshot"
  });
}

// src/actions/test/stopImpersonatingAccount.ts
async function stopImpersonatingAccount(client, { address }) {
  return await client.request({
    method: `${client.mode}_stopImpersonatingAccount`,
    params: [address]
  });
}

// src/actions/wallet/addChain.ts
async function addChain(client, { chain }) {
  const { id: id2, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
  await client.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: numberToHex(id2),
        chainName: name,
        nativeCurrency,
        rpcUrls: rpcUrls.default.http,
        blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
      }
    ]
  });
}

// src/actions/wallet/deployContract.ts
function deployContract(walletClient, { abi, args, bytecode, ...request }) {
  const calldata = encodeDeployData({
    abi,
    args,
    bytecode
  });
  return sendTransaction(walletClient, {
    ...request,
    data: calldata
  });
}

// src/actions/wallet/getAddresses.ts
async function getAddresses(client) {
  const addresses = await client.request({ method: "eth_accounts" });
  return addresses.map((address) => checksumAddress(address));
}

// src/actions/wallet/getPermissions.ts
async function getPermissions(client) {
  const permissions = await client.request({ method: "wallet_getPermissions" });
  return permissions;
}

// src/actions/wallet/requestAddresses.ts
async function requestAddresses(client) {
  const addresses = await client.request({ method: "eth_requestAccounts" });
  return addresses.map((address) => getAddress(address));
}

// src/actions/wallet/requestPermissions.ts
async function requestPermissions(client, permissions) {
  return client.request({
    method: "wallet_requestPermissions",
    params: [permissions]
  });
}

// src/actions/wallet/sendTransaction.ts
async function sendTransaction(client, args) {
  const {
    account,
    chain,
    accessList,
    assertChain = true,
    data,
    gas,
    gasPrice,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    to,
    value,
    ...rest
  } = args;
  try {
    assertRequest(args);
    const currentChainId = await getChainId(client);
    if (assertChain && chain && currentChainId !== _optionalChain([chain, 'optionalAccess', _123 => _123.id]))
      throw new ChainMismatchError({ chain, currentChainId });
    if (account.type === "local") {
      const chainId = _nullishCoalesce(_optionalChain([chain, 'optionalAccess', _124 => _124.id]), () => ( currentChainId));
      const request2 = await prepareRequest(client, {
        account,
        accessList,
        chain,
        data,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value,
        ...rest
      });
      const signedRequest = await account.signTransaction({
        chainId,
        ...request2
      });
      return await client.request({
        method: "eth_sendRawTransaction",
        params: [signedRequest]
      });
    }
    const formatter = _optionalChain([chain, 'optionalAccess', _125 => _125.formatters, 'optionalAccess', _126 => _126.transactionRequest]);
    const request = format3(
      {
        accessList,
        data,
        from: account.address,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value,
        // Pick out extra data that might exist on the chain's transaction request type.
        ...extract(rest, { formatter })
      },
      {
        formatter: formatter || formatTransactionRequest
      }
    );
    return await client.request({
      method: "eth_sendTransaction",
      params: [request]
    });
  } catch (err) {
    throw getTransactionError(err, args);
  }
}

// src/actions/wallet/signMessage.ts
async function signMessage(client, { account, data }) {
  if (account.type === "local")
    return account.signMessage(data);
  return client.request({
    method: "personal_sign",
    params: [toHex(data), account.address]
  });
}

// src/actions/wallet/switchChain.ts
async function switchChain(client, { id: id2 }) {
  await client.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: numberToHex(id2)
      }
    ]
  });
}

// src/actions/wallet/watchAsset.ts
async function watchAsset(client, params) {
  const added = await client.request({
    method: "wallet_watchAsset",
    params: [params]
  });
  return added;
}

// src/actions/wallet/writeContract.ts
async function writeContract(client, {
  abi,
  address,
  args,
  functionName,
  ...request
}) {
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  const hash2 = await sendTransaction(client, {
    data,
    to: address,
    ...request
  });
  return hash2;
}

// src/utils/unit/parseUnits.ts
function parseUnits(value, decimals) {
  let [integer, fraction = "0"] = value.split(".");
  const negative = integer.startsWith("-");
  if (negative)
    integer = integer.slice(1);
  fraction = fraction.replace(/(0+)$/, "");
  if (decimals === 0) {
    integer = `${Math.round(Number(`${integer}.${fraction}`))}`;
    fraction = "";
  } else if (fraction.length > decimals) {
    const [before, after] = [
      fraction.slice(0, decimals),
      fraction.slice(decimals)
    ];
    fraction = `${/^0+$/.test(before) ? before.slice(0, before.length - 1) : ""}${Math.round(Number(`${before}.${after}`))}`;
  } else {
    fraction = fraction.padEnd(decimals, "0");
  }
  return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
}

// src/utils/unit/parseGwei.ts
function parseGwei(ether, unit = "wei") {
  return parseUnits(ether, gweiUnits[unit]);
}

// src/utils/transaction/prepareRequest.ts
var defaultTip = parseGwei("1.5");
async function prepareRequest(client, args) {
  const { account, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce } = args;
  const block = await getBlock(client, { blockTag: "latest" });
  const request = { ...args, from: account.address };
  if (typeof nonce === "undefined")
    request.nonce = await getTransactionCount(client, {
      address: account.address,
      blockTag: "pending"
    });
  if (block.baseFeePerGas) {
    if (typeof gasPrice !== "undefined")
      throw new BaseError("Chain does not support legacy `gasPrice`.");
    if (typeof maxFeePerGas === "undefined") {
      request.maxPriorityFeePerGas = _nullishCoalesce(maxPriorityFeePerGas, () => ( defaultTip));
      request.maxFeePerGas = block.baseFeePerGas * 120n / 100n + request.maxPriorityFeePerGas;
    } else {
      if (typeof maxPriorityFeePerGas === "undefined" && maxFeePerGas < defaultTip)
        throw new BaseError(
          "`maxFeePerGas` cannot be less than the default `maxPriorityFeePerGas` (1.5 gwei)."
        );
      request.maxFeePerGas = maxFeePerGas;
      request.maxPriorityFeePerGas = _nullishCoalesce(maxPriorityFeePerGas, () => ( defaultTip));
    }
  } else {
    if (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined")
      throw new BaseError("Chain does not support EIP-1559 fees.");
    if (typeof gasPrice === "undefined")
      request.gasPrice = await getGasPrice(client) * 120n / 100n;
  }
  if (typeof gas === "undefined")
    request.gas = await estimateGas(client, {
      ...request,
      account: { address: account.address, type: "json-rpc" }
    });
  assertRequest(request);
  return request;
}

// src/utils/unit/formatUnits.ts
function formatUnits(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}

// src/utils/unit/formatEther.ts
function formatEther(wei, unit = "wei") {
  return formatUnits(wei, etherUnits[unit]);
}

// src/utils/unit/formatGwei.ts
function formatGwei(wei, unit = "wei") {
  return formatUnits(wei, gweiUnits[unit]);
}

// src/utils/unit/parseEther.ts
function parseEther(ether, unit = "wei") {
  return parseUnits(ether, etherUnits[unit]);
}






























































































































































































































































exports.BaseError = BaseError; exports.AbiConstructorNotFoundError = AbiConstructorNotFoundError; exports.AbiConstructorParamsNotFoundError = AbiConstructorParamsNotFoundError; exports.AbiDecodingDataSizeInvalidError = AbiDecodingDataSizeInvalidError; exports.AbiDecodingZeroDataError = AbiDecodingZeroDataError; exports.AbiEncodingArrayLengthMismatchError = AbiEncodingArrayLengthMismatchError; exports.AbiEncodingLengthMismatchError = AbiEncodingLengthMismatchError; exports.AbiErrorInputsNotFoundError = AbiErrorInputsNotFoundError; exports.AbiErrorNotFoundError = AbiErrorNotFoundError; exports.AbiErrorSignatureNotFoundError = AbiErrorSignatureNotFoundError; exports.AbiEventSignatureNotFoundError = AbiEventSignatureNotFoundError; exports.AbiEventNotFoundError = AbiEventNotFoundError; exports.AbiFunctionNotFoundError = AbiFunctionNotFoundError; exports.AbiFunctionOutputsNotFoundError = AbiFunctionOutputsNotFoundError; exports.AbiFunctionSignatureNotFoundError = AbiFunctionSignatureNotFoundError; exports.InvalidAbiEncodingTypeError = InvalidAbiEncodingTypeError; exports.InvalidAbiDecodingTypeError = InvalidAbiDecodingTypeError; exports.InvalidArrayError = InvalidArrayError; exports.InvalidDefinitionTypeError = InvalidDefinitionTypeError; exports.InvalidAddressError = InvalidAddressError; exports.BlockNotFoundError = BlockNotFoundError; exports.ChainDoesNotSupportContract = ChainDoesNotSupportContract; exports.multicall3Abi = multicall3Abi; exports.panicReasons = panicReasons; exports.etherUnits = etherUnits; exports.gweiUnits = gweiUnits; exports.weiUnits = weiUnits; exports.TransactionExecutionError = TransactionExecutionError; exports.TransactionNotFoundError = TransactionNotFoundError; exports.TransactionReceiptNotFoundError = TransactionReceiptNotFoundError; exports.WaitForTransactionReceiptTimeoutError = WaitForTransactionReceiptTimeoutError; exports.CallExecutionError = CallExecutionError; exports.ContractFunctionExecutionError = ContractFunctionExecutionError; exports.ContractFunctionRevertedError = ContractFunctionRevertedError; exports.ContractFunctionZeroDataError = ContractFunctionZeroDataError; exports.RawContractError = RawContractError; exports.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError; exports.DataLengthTooLongError = DataLengthTooLongError; exports.DataLengthTooShortError = DataLengthTooShortError; exports.InvalidBytesBooleanError = InvalidBytesBooleanError; exports.InvalidHexBooleanError = InvalidHexBooleanError; exports.InvalidHexValueError = InvalidHexValueError; exports.OffsetOutOfBoundsError = OffsetOutOfBoundsError; exports.EstimateGasExecutionError = EstimateGasExecutionError; exports.FilterTypeNotSupportedError = FilterTypeNotSupportedError; exports.ExecutionRevertedError = ExecutionRevertedError; exports.FeeCapTooHighError = FeeCapTooHighError; exports.FeeCapTooLowError = FeeCapTooLowError; exports.NonceTooHighError = NonceTooHighError; exports.NonceTooLowError = NonceTooLowError; exports.NonceMaxValueError = NonceMaxValueError; exports.InsufficientFundsError = InsufficientFundsError; exports.IntrinsicGasTooHighError = IntrinsicGasTooHighError; exports.IntrinsicGasTooLowError = IntrinsicGasTooLowError; exports.TransactionTypeNotSupportedError = TransactionTypeNotSupportedError; exports.TipAboveFeeCapError = TipAboveFeeCapError; exports.UnknownNodeError = UnknownNodeError; exports.RequestError = RequestError; exports.RpcRequestError = RpcRequestError; exports.ParseRpcError = ParseRpcError; exports.InvalidRequestRpcError = InvalidRequestRpcError; exports.MethodNotFoundRpcError = MethodNotFoundRpcError; exports.InvalidParamsRpcError = InvalidParamsRpcError; exports.InternalRpcError = InternalRpcError; exports.InvalidInputRpcError = InvalidInputRpcError; exports.ResourceNotFoundRpcError = ResourceNotFoundRpcError; exports.ResourceUnavailableRpcError = ResourceUnavailableRpcError; exports.TransactionRejectedRpcError = TransactionRejectedRpcError; exports.MethodNotSupportedRpcError = MethodNotSupportedRpcError; exports.LimitExceededRpcError = LimitExceededRpcError; exports.JsonRpcVersionUnsupportedError = JsonRpcVersionUnsupportedError; exports.UserRejectedRequestError = UserRejectedRequestError; exports.SwitchChainError = SwitchChainError; exports.UnknownRpcError = UnknownRpcError; exports.HttpRequestError = HttpRequestError; exports.WebSocketRequestError = WebSocketRequestError; exports.RpcError = RpcError; exports.TimeoutError = TimeoutError; exports.UrlRequiredError = UrlRequiredError; exports.concat = concat; exports.isBytes = isBytes; exports.isHex = isHex; exports.pad = pad; exports.padHex = padHex; exports.padBytes = padBytes; exports.trim = trim; exports.size = size; exports.slice = slice; exports.sliceBytes = sliceBytes; exports.sliceHex = sliceHex; exports.boolToHex = boolToHex; exports.bytesToHex = bytesToHex; exports.toHex = toHex; exports.numberToHex = numberToHex; exports.stringToHex = stringToHex; exports.toBytes = toBytes; exports.boolToBytes = boolToBytes; exports.hexToBytes = hexToBytes; exports.numberToBytes = numberToBytes; exports.stringToBytes = stringToBytes; exports.toRlp = toRlp; exports.fromHex = fromHex; exports.hexToBigInt = hexToBigInt; exports.hexToBool = hexToBool; exports.hexToNumber = hexToNumber; exports.hexToString = hexToString; exports.fromBytes = fromBytes; exports.bytesToBigint = bytesToBigint; exports.bytesToBool = bytesToBool; exports.bytesToNumber = bytesToNumber; exports.bytesToString = bytesToString; exports.fromRlp = fromRlp; exports.extractFunctionParts = extractFunctionParts; exports.extractFunctionName = extractFunctionName; exports.extractFunctionParams = extractFunctionParams; exports.extractFunctionType = extractFunctionType; exports.keccak256 = keccak256; exports.getEventSelector = getEventSelector; exports.getFunctionSelector = getFunctionSelector; exports.isAddress = isAddress; exports.getAddress = getAddress; exports.getContractAddress = getContractAddress2; exports.getCreateAddress = getCreateAddress; exports.getCreate2Address = getCreate2Address; exports.isAddressEqual = isAddressEqual; exports.encodeAbiParameters = encodeAbiParameters; exports.decodeAbiParameters = decodeAbiParameters; exports.formatAbiItem = formatAbiItem; exports.decodeErrorResult = decodeErrorResult; exports.decodeEventLog = decodeEventLog; exports.decodeFunctionData = decodeFunctionData; exports.getAbiItem = getAbiItem; exports.decodeFunctionResult = decodeFunctionResult; exports.encodeDeployData = encodeDeployData; exports.encodeErrorResult = encodeErrorResult; exports.encodeEventTopics = encodeEventTopics; exports.encodeFunctionData = encodeFunctionData; exports.encodeFunctionResult = encodeFunctionResult; exports.arrayRegex = arrayRegex; exports.bytesRegex = bytesRegex; exports.integerRegex = integerRegex; exports.encodePacked = encodePacked; exports.formatAbiItemWithArgs = formatAbiItemWithArgs; exports.parseAbi = _abitype.parseAbi; exports.parseAbiItem = _abitype.parseAbiItem; exports.parseAbiParameter = _abitype.parseAbiParameter; exports.parseAbiParameters = _abitype.parseAbiParameters; exports.getAccount = getAccount; exports.isDeterministicError = isDeterministicError; exports.buildRequest = buildRequest; exports.defineChain = defineChain; exports.format = format3; exports.defineFormatter = defineFormatter; exports.transactionType = transactionType; exports.formatTransaction = formatTransaction; exports.defineTransaction = defineTransaction; exports.formatBlock = formatBlock; exports.defineBlock = defineBlock; exports.extract = extract; exports.defineTransactionReceipt = defineTransactionReceipt; exports.formatTransactionRequest = formatTransactionRequest; exports.defineTransactionRequest = defineTransactionRequest; exports.containsNodeError = containsNodeError; exports.getNodeError = getNodeError; exports.getCallError = getCallError; exports.getContractError = getContractError; exports.getEstimateGasError = getEstimateGasError; exports.getTransactionError = getTransactionError; exports.stringify = stringify; exports.getSocket = getSocket; exports.rpc = rpc; exports.assertRequest = assertRequest; exports.call = call; exports.simulateContract = simulateContract; exports.createPendingTransactionFilter = createPendingTransactionFilter; exports.createBlockFilter = createBlockFilter; exports.createEventFilter = createEventFilter; exports.createContractEventFilter = createContractEventFilter; exports.estimateGas = estimateGas; exports.estimateContractGas = estimateContractGas; exports.getBalance = getBalance; exports.getBlock = getBlock; exports.getBlockNumberCache = getBlockNumberCache; exports.getBlockNumber = getBlockNumber; exports.getBlockTransactionCount = getBlockTransactionCount; exports.getBytecode = getBytecode; exports.getChainId = getChainId; exports.getFeeHistory = getFeeHistory; exports.getFilterChanges = getFilterChanges; exports.getFilterLogs = getFilterLogs; exports.getGasPrice = getGasPrice; exports.getLogs = getLogs; exports.getStorageAt = getStorageAt; exports.getTransaction = getTransaction; exports.getTransactionConfirmations = getTransactionConfirmations; exports.getTransactionCount = getTransactionCount; exports.getTransactionReceipt = getTransactionReceipt; exports.readContract = readContract; exports.multicall = multicall; exports.uninstallFilter = uninstallFilter; exports.waitForTransactionReceipt = waitForTransactionReceipt; exports.watchBlockNumber = watchBlockNumber; exports.watchBlocks = watchBlocks; exports.watchContractEvent = watchContractEvent; exports.watchEvent = watchEvent; exports.watchPendingTransactions = watchPendingTransactions; exports.dropTransaction = dropTransaction; exports.getAutomine = getAutomine; exports.getTxpoolContent = getTxpoolContent; exports.getTxpoolStatus = getTxpoolStatus; exports.impersonateAccount = impersonateAccount; exports.increaseTime = increaseTime; exports.inspectTxpool = inspectTxpool; exports.mine = mine; exports.removeBlockTimestampInterval = removeBlockTimestampInterval; exports.reset = reset; exports.revert = revert; exports.sendUnsignedTransaction = sendUnsignedTransaction; exports.setAutomine = setAutomine; exports.setBalance = setBalance; exports.setBlockGasLimit = setBlockGasLimit; exports.setBlockTimestampInterval = setBlockTimestampInterval; exports.setCode = setCode; exports.setCoinbase = setCoinbase; exports.setIntervalMining = setIntervalMining; exports.setLoggingEnabled = setLoggingEnabled; exports.setMinGasPrice = setMinGasPrice; exports.setNextBlockBaseFeePerGas = setNextBlockBaseFeePerGas; exports.setNextBlockTimestamp = setNextBlockTimestamp; exports.setNonce = setNonce; exports.setRpcUrl = setRpcUrl; exports.setStorageAt = setStorageAt; exports.snapshot = snapshot; exports.stopImpersonatingAccount = stopImpersonatingAccount; exports.addChain = addChain; exports.deployContract = deployContract; exports.getAddresses = getAddresses; exports.getPermissions = getPermissions; exports.requestAddresses = requestAddresses; exports.requestPermissions = requestPermissions; exports.sendTransaction = sendTransaction; exports.signMessage = signMessage; exports.switchChain = switchChain; exports.watchAsset = watchAsset; exports.writeContract = writeContract; exports.parseUnits = parseUnits; exports.parseGwei = parseGwei; exports.prepareRequest = prepareRequest; exports.formatUnits = formatUnits; exports.formatEther = formatEther; exports.formatGwei = formatGwei; exports.parseEther = parseEther;
//# sourceMappingURL=chunk-PZIHILNK.js.map