{"version":3,"sources":["../src/utils/abi/index.ts","../package.json","../src/errors/utils.ts","../src/errors/base.ts","../src/errors/abi.ts","../src/errors/address.ts","../src/errors/block.ts","../src/errors/chain.ts","../src/constants/abis.ts","../src/constants/solidity.ts","../src/constants/unit.ts","../src/errors/transaction.ts","../src/errors/contract.ts","../src/errors/data.ts","../src/errors/encoding.ts","../src/errors/estimateGas.ts","../src/errors/log.ts","../src/errors/node.ts","../src/errors/request.ts","../src/errors/rpc.ts","../src/errors/transport.ts","../src/utils/data/concat.ts","../src/utils/data/isBytes.ts","../src/utils/data/isHex.ts","../src/utils/data/pad.ts","../src/utils/data/trim.ts","../src/utils/data/size.ts","../src/utils/data/slice.ts","../src/utils/encoding/toHex.ts","../src/utils/encoding/toBytes.ts","../src/utils/encoding/toRlp.ts","../src/utils/encoding/fromHex.ts","../src/utils/encoding/fromBytes.ts","../src/utils/encoding/fromRlp.ts","../src/utils/contract/extractFunctionParts.ts","../src/utils/hash/keccak256.ts","../src/utils/hash/hashFunction.ts","../src/utils/hash/getEventSelector.ts","../src/utils/hash/getFunctionSelector.ts","../src/utils/address/isAddress.ts","../src/utils/address/getAddress.ts","../src/utils/address/getContractAddress.ts","../src/utils/address/isAddressEqual.ts","../src/utils/abi/encodeAbiParameters.ts","../src/utils/abi/decodeAbiParameters.ts","../src/utils/abi/formatAbiItem.ts","../src/utils/abi/decodeErrorResult.ts","../src/utils/abi/decodeEventLog.ts","../src/utils/abi/decodeFunctionData.ts","../src/utils/abi/getAbiItem.ts","../src/utils/abi/decodeFunctionResult.ts","../src/utils/abi/encodeDeployData.ts","../src/utils/abi/encodeErrorResult.ts","../src/utils/abi/encodeEventTopics.ts","../src/utils/abi/encodeFunctionData.ts","../src/utils/abi/encodeFunctionResult.ts","../src/utils/regex.ts","../src/utils/abi/encodePacked.ts","../src/utils/abi/formatAbiItemWithArgs.ts","../src/utils/account.ts","../src/utils/promise/withCache.ts","../src/utils/wait.ts","../src/utils/promise/withRetry.ts","../src/utils/promise/withTimeout.ts","../src/utils/buildRequest.ts","../src/utils/chain.ts","../src/utils/formatters/format.ts","../src/utils/formatters/transaction.ts","../src/utils/formatters/block.ts","../src/utils/formatters/extract.ts","../src/utils/formatters/feeHistory.ts","../src/utils/formatters/log.ts","../src/utils/formatters/transactionReceipt.ts","../src/utils/formatters/transactionRequest.ts","../src/utils/errors/getNodeError.ts","../src/utils/errors/getCallError.ts","../src/utils/errors/getContractError.ts","../src/utils/errors/getEstimateGasError.ts","../src/utils/errors/getTransactionError.ts","../src/utils/rpc.ts","../src/utils/stringify.ts","../src/utils/transaction/assertRequest.ts","../src/actions/public/call.ts","../src/actions/public/simulateContract.ts","../src/actions/public/createPendingTransactionFilter.ts","../src/actions/public/createBlockFilter.ts","../src/actions/public/createEventFilter.ts","../src/actions/public/createContractEventFilter.ts","../src/actions/public/estimateGas.ts","../src/actions/public/estimateContractGas.ts","../src/actions/public/getBalance.ts","../src/actions/public/getBlock.ts","../src/actions/public/getBlockNumber.ts","../src/actions/public/getBlockTransactionCount.ts","../src/actions/public/getBytecode.ts","../src/actions/public/getChainId.ts","../src/actions/public/getFeeHistory.ts","../src/actions/public/getFilterChanges.ts","../src/actions/public/getFilterLogs.ts","../src/actions/public/getGasPrice.ts","../src/actions/public/getLogs.ts","../src/actions/public/getStorageAt.ts","../src/actions/public/getTransaction.ts","../src/actions/public/getTransactionConfirmations.ts","../src/actions/public/getTransactionCount.ts","../src/actions/public/getTransactionReceipt.ts","../src/actions/public/readContract.ts","../src/actions/public/multicall.ts","../src/actions/public/uninstallFilter.ts","../src/utils/observe.ts","../src/actions/public/waitForTransactionReceipt.ts","../src/utils/poll.ts","../src/actions/public/watchBlockNumber.ts","../src/actions/public/watchBlocks.ts","../src/actions/public/watchContractEvent.ts","../src/actions/public/watchEvent.ts","../src/actions/public/watchPendingTransactions.ts","../src/actions/test/dropTransaction.ts","../src/actions/test/getAutomine.ts","../src/actions/test/getTxpoolContent.ts","../src/actions/test/getTxpoolStatus.ts","../src/actions/test/impersonateAccount.ts","../src/actions/test/increaseTime.ts","../src/actions/test/inspectTxpool.ts","../src/actions/test/mine.ts","../src/actions/test/removeBlockTimestampInterval.ts","../src/actions/test/reset.ts","../src/actions/test/revert.ts","../src/actions/test/sendUnsignedTransaction.ts","../src/actions/test/setAutomine.ts","../src/actions/test/setBalance.ts","../src/actions/test/setBlockGasLimit.ts","../src/actions/test/setBlockTimestampInterval.ts","../src/actions/test/setCode.ts","../src/actions/test/setCoinbase.ts","../src/actions/test/setIntervalMining.ts","../src/actions/test/setLoggingEnabled.ts","../src/actions/test/setMinGasPrice.ts","../src/actions/test/setNextBlockBaseFeePerGas.ts","../src/actions/test/setNextBlockTimestamp.ts","../src/actions/test/setNonce.ts","../src/actions/test/setRpcUrl.ts","../src/actions/test/setStorageAt.ts","../src/actions/test/snapshot.ts","../src/actions/test/stopImpersonatingAccount.ts","../src/actions/wallet/addChain.ts","../src/actions/wallet/deployContract.ts","../src/actions/wallet/getAddresses.ts","../src/actions/wallet/getPermissions.ts","../src/actions/wallet/requestAddresses.ts","../src/actions/wallet/requestPermissions.ts","../src/actions/wallet/sendTransaction.ts","../src/actions/wallet/signMessage.ts","../src/actions/wallet/switchChain.ts","../src/actions/wallet/watchAsset.ts","../src/actions/wallet/writeContract.ts","../src/utils/unit/parseUnits.ts","../src/utils/unit/parseGwei.ts","../src/utils/transaction/prepareRequest.ts","../src/utils/unit/formatUnits.ts","../src/utils/unit/formatEther.ts","../src/utils/unit/formatGwei.ts","../src/utils/unit/parseEther.ts"],"sourcesContent":["export type {\n  ParseAbi,\n  ParseAbiItem,\n  ParseAbiParameter,\n  ParseAbiParameters,\n} from 'abitype'\nexport {\n  parseAbi,\n  parseAbiItem,\n  parseAbiParameter,\n  parseAbiParameters,\n} from 'abitype'\n\nexport type { DecodeAbiParametersReturnType } from './decodeAbiParameters'\nexport { decodeAbiParameters } from './decodeAbiParameters'\n\nexport type {\n  DecodeErrorResultParameters,\n  DecodeErrorResultReturnType,\n} from './decodeErrorResult'\nexport { decodeErrorResult } from './decodeErrorResult'\n\nexport type {\n  DecodeEventLogParameters,\n  DecodeEventLogReturnType,\n} from './decodeEventLog'\nexport { decodeEventLog } from './decodeEventLog'\n\nexport type { DecodeFunctionDataParameters } from './decodeFunctionData'\nexport { decodeFunctionData } from './decodeFunctionData'\n\nexport type {\n  DecodeFunctionResultParameters,\n  DecodeFunctionResultReturnType,\n} from './decodeFunctionResult'\nexport { decodeFunctionResult } from './decodeFunctionResult'\n\nexport type { EncodeAbiParametersReturnType } from './encodeAbiParameters'\nexport { encodeAbiParameters } from './encodeAbiParameters'\n\nexport type { EncodeDeployDataParameters } from './encodeDeployData'\nexport { encodeDeployData } from './encodeDeployData'\n\nexport type { EncodeErrorResultParameters } from './encodeErrorResult'\nexport { encodeErrorResult } from './encodeErrorResult'\n\nexport type { EncodeEventTopicsParameters } from './encodeEventTopics'\nexport { encodeEventTopics } from './encodeEventTopics'\n\nexport type { EncodeFunctionDataParameters } from './encodeFunctionData'\nexport { encodeFunctionData } from './encodeFunctionData'\n\nexport type { EncodeFunctionResultParameters } from './encodeFunctionResult'\nexport { encodeFunctionResult } from './encodeFunctionResult'\n\nexport { encodePacked } from './encodePacked'\n\nexport { formatAbiItemWithArgs } from './formatAbiItemWithArgs'\n\nexport { formatAbiItem } from './formatAbiItem'\n\nexport type { GetAbiItemParameters } from './getAbiItem'\nexport { getAbiItem } from './getAbiItem'\n","{\n  \"name\": \"viem\",\n  \"description\": \"TypeScript Interface for Ethereum\",\n  \"version\": \"0.1.1\",\n  \"scripts\": {\n    \"anvil\": \"source .env && anvil --fork-url $VITE_ANVIL_FORK_URL --fork-block-number $VITE_ANVIL_BLOCK_NUMBER --block-time $VITE_ANVIL_BLOCK_TIME\",\n    \"bench\": \"vitest bench --no-threads\",\n    \"bench:ci\": \"CI=true vitest bench --no-threads\",\n    \"build\": \"tsup\",\n    \"changeset\": \"changeset\",\n    \"changeset:release\": \"pnpm build && changeset publish\",\n    \"changeset:version\": \"changeset version && pnpm install --lockfile-only\",\n    \"clean\": \"rimraf dist abi chains contract ens public test utils wallet window\",\n    \"contracts:build\": \"wagmi generate\",\n    \"dev\": \"DEV=true tsup\",\n    \"dev:docs\": \"pnpm -r --filter site dev\",\n    \"format\": \"rome format src/ --write\",\n    \"lint\": \"rome check .\",\n    \"lint:fix\": \"pnpm lint --apply-suggested\",\n    \"playground\": \"pnpm --filter playground-browser dev\",\n    \"postinstall\": \"pnpm dev && pnpm contracts:build\",\n    \"preinstall\": \"npx only-allow pnpm\",\n    \"prepublishOnly\": \"pnpm bun scripts/prepublishOnly.ts\",\n    \"prepare\": \"npx simple-git-hooks\",\n    \"test\": \"vitest dev --no-threads\",\n    \"test:cov\": \"vitest dev --coverage --no-threads\",\n    \"test:ci\": \"CI=true vitest --coverage --no-threads\",\n    \"test:ui\": \"vitest dev --ui --no-threads\",\n    \"ts-node\": \"bun\",\n    \"typecheck\": \"tsc --noEmit\"\n  },\n  \"tsup\": {\n    \"entry\": [\n      \"src/index.ts\",\n      \"src/abi.ts\",\n      \"src/chains.ts\",\n      \"src/contract.ts\",\n      \"src/ens.ts\",\n      \"src/public.ts\",\n      \"src/test.ts\",\n      \"src/utils/index.ts\",\n      \"src/wallet.ts\",\n      \"src/window.ts\"\n    ]\n  },\n  \"files\": [\n    \"/abi\",\n    \"/dist\",\n    \"/chains\",\n    \"/contract\",\n    \"/ens\",\n    \"/public\",\n    \"/test\",\n    \"/utils\",\n    \"/wallet\",\n    \"/window\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"module\": \"./dist/index.mts\",\n      \"default\": \"./dist/index.js\"\n    },\n    \"./abi\": {\n      \"types\": \"./dist/abi.d.ts\",\n      \"module\": \"./dist/abi.mts\",\n      \"default\": \"./dist/abi.js\"\n    },\n    \"./chains\": {\n      \"types\": \"./dist/chains.d.ts\",\n      \"module\": \"./dist/chains.mts\",\n      \"default\": \"./dist/chains.js\"\n    },\n    \"./contract\": {\n      \"types\": \"./dist/contract.d.ts\",\n      \"module\": \"./dist/contract.mts\",\n      \"default\": \"./dist/contract.js\"\n    },\n    \"./ens\": {\n      \"types\": \"./dist/ens.d.ts\",\n      \"module\": \"./dist/ens.mts\",\n      \"default\": \"./dist/ens.js\"\n    },\n    \"./public\": {\n      \"types\": \"./dist/public.d.ts\",\n      \"module\": \"./dist/public.mts\",\n      \"default\": \"./dist/public.js\"\n    },\n    \"./test\": {\n      \"types\": \"./dist/test.d.ts\",\n      \"module\": \"./dist/test.mts\",\n      \"default\": \"./dist/test.js\"\n    },\n    \"./utils\": {\n      \"types\": \"./dist/utils/index.d.ts\",\n      \"module\": \"./dist/utils/index.mts\",\n      \"default\": \"./dist/utils/index.js\"\n    },\n    \"./wallet\": {\n      \"types\": \"./dist/wallet.d.ts\",\n      \"module\": \"./dist/wallet.mts\",\n      \"default\": \"./dist/wallet.js\"\n    },\n    \"./window\": {\n      \"types\": \"./dist/window.d.ts\",\n      \"module\": \"./dist/window.mts\",\n      \"default\": \"./dist/window.js\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"main\": \"dist/index.js\",\n  \"module\": \"dist/index.mjs\",\n  \"types\": \"dist/index.d.ts\",\n  \"sideEffects\": false,\n  \"dependencies\": {\n    \"@noble/hashes\": \"^1.1.2\",\n    \"@wagmi/chains\": \"~0.2.8\",\n    \"abitype\": \"~0.6.2\",\n    \"idna-uts46-hx\": \"^4.1.2\",\n    \"isomorphic-ws\": \"^5.0.0\",\n    \"ws\": \"^8.12.0\"\n  },\n  \"devDependencies\": {\n    \"@actions/core\": \"^1.10.0\",\n    \"@actions/github\": \"^5.1.1\",\n    \"@adraffy/ens-normalize\": \"^1.8.9\",\n    \"@changesets/changelog-github\": \"^0.4.5\",\n    \"@changesets/cli\": \"^2.23.2\",\n    \"@types/dedent\": \"^0.7.0\",\n    \"@types/fs-extra\": \"^9.0.13\",\n    \"@types/node\": \"^17.0.45\",\n    \"@types/ws\": \"^8.5.4\",\n    \"@vitest/coverage-c8\": \"^0.29.2\",\n    \"@vitest/ui\": \"^0.29.2\",\n    \"@wagmi/cli\": \"^0.1.6\",\n    \"bun\": \"^0.5.5\",\n    \"bundlewatch\": \"^0.3.3\",\n    \"dedent\": \"^0.7.0\",\n    \"ethers\": \"^5.7.2\",\n    \"ethers@6\": \"npm:ethers@^6.0.2\",\n    \"execa\": \"^6.1.0\",\n    \"fs-extra\": \"^10.1.0\",\n    \"rimraf\": \"^4.1.2\",\n    \"rome\": \"^11.0.0\",\n    \"simple-git-hooks\": \"^2.8.1\",\n    \"tsup\": \"^6.6.0\",\n    \"typescript\": \"^4.9.4\",\n    \"vite\": \"^4.1.4\",\n    \"vitest\": \"~0.29.2\"\n  },\n  \"license\": \"MIT\",\n  \"repository\": \"wagmi-dev/viem\",\n  \"authors\": [\n    \"awkweb.eth\",\n    \"jxom.eth\"\n  ],\n  \"keywords\": [\n    \"eth\",\n    \"ethereum\",\n    \"dapps\",\n    \"wallet\",\n    \"web3\"\n  ],\n  \"simple-git-hooks\": {\n    \"pre-commit\": \"pnpm format && pnpm lint:fix\"\n  },\n  \"pnpm\": {\n    \"patchedDependencies\": {\n      \"vitepress@1.0.0-alpha.49\": \"patches/vitepress@1.0.0-alpha.49.patch\"\n    }\n  }\n}\n","// @ts-ignore\nimport { Address } from 'abitype'\nimport pkg from '../../package.json'\n\nexport const getContractAddress = (address: Address) => address\nexport const getUrl = (url: string) => url\nexport const getVersion = () => `${pkg.name}@${pkg.version}`\n","import { getVersion } from './utils'\n\ntype BaseErrorParameters = {\n  docsPath?: string\n  metaMessages?: string[]\n} & (\n  | {\n      cause?: never\n      details?: string\n    }\n  | {\n      cause: BaseError | Error\n      details?: never\n    }\n)\n\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string\n  metaMessages?: string[]\n  shortMessage: string\n\n  name = 'ViemError'\n\n  constructor(shortMessage: string, args: BaseErrorParameters = {}) {\n    const details =\n      args.cause instanceof BaseError\n        ? args.cause.details\n        : args.cause?.message\n        ? args.cause.message\n        : args.details!\n    const docsPath =\n      args.cause instanceof BaseError\n        ? args.cause.docsPath || args.docsPath\n        : args.docsPath\n    const message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsPath ? [`Docs: https://viem.sh${docsPath}`] : []),\n      ...(details ? [`Details: ${details}`] : []),\n      `Version: ${getVersion()}`,\n    ].join('\\n')\n\n    super(message)\n\n    if (args.cause) this.cause = args.cause\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.shortMessage = shortMessage\n  }\n}\n","import { Hex } from '../types'\nimport { size } from '../utils'\nimport { BaseError } from './base'\n\nexport class AbiConstructorNotFoundError extends BaseError {\n  name = 'AbiConstructorNotFoundError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'A constructor was not found on the ABI.',\n        'Make sure you are using the correct ABI and that the constructor exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  name = 'AbiConstructorParamsNotFoundError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  name = 'AbiDecodingDataSizeInvalidError'\n  constructor(size: number) {\n    super(\n      [\n        `Data size of ${size} bytes is invalid.`,\n        'Size must be in increments of 32 bytes (size % 32 === 0).',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class AbiDecodingZeroDataError extends BaseError {\n  name = 'AbiDecodingZeroDataError'\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.')\n  }\n}\n\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  name = 'AbiEncodingArrayLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      [\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  name = 'AbiEncodingBytesSizeMismatchError'\n  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n    )\n  }\n}\n\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  name = 'AbiEncodingLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding params/values length mismatch.',\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  name = 'AbiErrorInputsNotFoundError'\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n        'Cannot encode error result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the inputs exist on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiErrorNotFoundError extends BaseError {\n  name = 'AbiErrorNotFoundError'\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Error \"${errorName}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  name = 'AbiErrorSignatureNotFoundError'\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded error signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  name = 'AbiEventSignatureNotFoundError'\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded event signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiEventNotFoundError extends BaseError {\n  name = 'AbiEventNotFoundError'\n  constructor(eventName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Event \"${eventName}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiFunctionNotFoundError extends BaseError {\n  name = 'AbiFunctionNotFoundError'\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  name = 'AbiFunctionOutputsNotFoundError'\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n        'Cannot decode function result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  name = 'AbiFunctionSignatureNotFoundError'\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded function signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class BytesSizeMismatchError extends BaseError {\n  name = 'BytesSizeMismatchError'\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`)\n  }\n}\n\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  name = 'InvalidAbiEncodingType'\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid encoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath },\n    )\n  }\n}\n\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  name = 'InvalidAbiDecodingType'\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid decoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath },\n    )\n  }\n}\n\nexport class InvalidArrayError extends BaseError {\n  name = 'InvalidArrayError'\n  constructor(value: unknown) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'))\n  }\n}\n\nexport class InvalidDefinitionTypeError extends BaseError {\n  name = 'InvalidDefinitionTypeError'\n  constructor(type: string) {\n    super(\n      [\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class UnsupportedPackedAbiType extends BaseError {\n  name = 'UnsupportedPackedAbiType'\n  constructor(type: unknown) {\n    super(`Type \"${type}\" is not supported for packed encoding.`)\n  }\n}\n","import { BaseError } from './base'\n\nexport class InvalidAddressError extends BaseError {\n  name = 'InvalidAddressError'\n  constructor({ address }: { address: string }) {\n    super(`Address \"${address}\" is invalid.`)\n  }\n}\n","import { Hash } from '../types'\nimport { BaseError } from './base'\n\nexport class BlockNotFoundError extends BaseError {\n  name = 'BlockNotFoundError'\n  constructor({\n    blockHash,\n    blockNumber,\n  }: {\n    blockHash?: Hash\n    blockNumber?: bigint\n  }) {\n    let identifier = 'Block'\n    if (blockHash) identifier = `Block at hash \"${blockHash}\"`\n    if (blockNumber) identifier = `Block at number \"${blockNumber}\"`\n    super(`${identifier} could not be found.`)\n  }\n}\n","import { Chain } from '../types'\nimport { BaseError } from './base'\n\nexport class ChainDoesNotSupportContract extends BaseError {\n  name = 'ChainDoesNotSupportContract'\n  constructor({\n    blockNumber,\n    chain,\n    contract,\n  }: {\n    blockNumber?: bigint\n    chain: Chain\n    contract: { name: string; blockCreated?: number }\n  }) {\n    super(\n      `Chain \"${chain.name}\" does not support contract \"${contract.name}\".`,\n      {\n        metaMessages: [\n          'This could be due to any of the following:',\n          ...(blockNumber &&\n          contract.blockCreated &&\n          contract.blockCreated > blockNumber\n            ? [\n                `- The contract \"${contract.name}\" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`,\n              ]\n            : [\n                `- The chain does not have the contract \"${contract.name}\" configured.`,\n              ]),\n        ],\n      },\n    )\n  }\n}\n\nexport class ChainMismatchError extends BaseError {\n  name = 'ChainMismatchError'\n\n  constructor({\n    chain,\n    currentChainId,\n  }: { chain: Chain; currentChainId: number }) {\n    super(\n      `The current chain (id: ${currentChainId}) does not match the chain passed to the request (id: ${chain.id} – ${chain.name}).`,\n      {\n        metaMessages: [\n          `Current Chain ID:  ${currentChainId}`,\n          `Expected Chain ID: ${chain.id} – ${chain.name}`,\n        ],\n      },\n    )\n  }\n}\n","/* [Multicall3](https://github.com/mds1/multicall) */\nexport const multicall3Abi = [\n  {\n    inputs: [\n      {\n        components: [\n          {\n            name: 'target',\n            type: 'address',\n          },\n          {\n            name: 'allowFailure',\n            type: 'bool',\n          },\n          {\n            name: 'callData',\n            type: 'bytes',\n          },\n        ],\n        name: 'calls',\n        type: 'tuple[]',\n      },\n    ],\n    name: 'aggregate3',\n    outputs: [\n      {\n        components: [\n          {\n            name: 'success',\n            type: 'bool',\n          },\n          {\n            name: 'returnData',\n            type: 'bytes',\n          },\n        ],\n        name: 'returnData',\n        type: 'tuple[]',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n] as const\n","import { AbiError } from 'abitype'\n\n// https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require\nexport const panicReasons = {\n  1: 'An `assert` condition failed.',\n  17: 'Arithmic operation resulted in underflow or overflow.',\n  18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',\n  33: 'Attempted to convert to an invalid type.',\n  34: 'Attempted to access a storage byte array that is incorrectly encoded.',\n  49: 'Performed `.pop()` on an empty array',\n  50: 'Array index is out of bounds.',\n  65: 'Allocated too much memory or created an array which is too large.',\n  81: 'Attempted to call a zero-initialized variable of internal function type.',\n} as const\n\nexport const solidityError: AbiError = {\n  inputs: [\n    {\n      name: 'message',\n      type: 'string',\n    },\n  ],\n  name: 'Error',\n  type: 'error',\n}\nexport const solidityPanic: AbiError = {\n  inputs: [\n    {\n      name: 'reason',\n      type: 'uint256',\n    },\n  ],\n  name: 'Panic',\n  type: 'error',\n}\n","export const etherUnits = {\n  gwei: 9,\n  wei: 18,\n}\nexport const gweiUnits = {\n  ether: -9,\n  wei: 9,\n}\nexport const weiUnits = {\n  ether: -18,\n  gwei: -9,\n}\n","import { BlockTag, Hash } from '../types'\nimport { formatEther, formatGwei } from '../utils'\nimport { SendTransactionParameters } from '../wallet'\nimport { BaseError } from './base'\n\nexport function prettyPrint(\n  args: Record<string, bigint | number | string | undefined | false>,\n) {\n  const entries = Object.entries(args)\n    .map(([key, value]) => {\n      if (value === undefined || value === false) return null\n      return [key, value]\n    })\n    .filter(Boolean) as [string, string][]\n  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0)\n  return entries\n    .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n    .join('\\n')\n}\n\nexport class FeeConflictError extends BaseError {\n  name = 'FeeConflictError'\n  constructor() {\n    super(\n      [\n        'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',\n        'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class TransactionExecutionError extends BaseError {\n  cause: BaseError\n\n  name = 'TransactionExecutionError'\n\n  constructor(\n    cause: BaseError,\n    {\n      account,\n      docsPath,\n      chain,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    }: SendTransactionParameters & { docsPath?: string },\n  ) {\n    const prettyArgs = prettyPrint({\n      chain: chain && `${chain?.name} (id: ${chain?.id})`,\n      from: account.address,\n      to,\n      value:\n        typeof value !== 'undefined' &&\n        `${formatEther(value)} ${chain?.nativeCurrency.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice:\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Request Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n    })\n    this.cause = cause\n  }\n}\n\nexport class TransactionNotFoundError extends BaseError {\n  name = 'TransactionNotFoundError'\n  constructor({\n    blockHash,\n    blockNumber,\n    blockTag,\n    hash,\n    index,\n  }: {\n    blockHash?: Hash\n    blockNumber?: bigint\n    blockTag?: BlockTag\n    hash?: Hash\n    index?: number\n  }) {\n    let identifier = 'Transaction'\n    if (blockTag && index !== undefined)\n      identifier = `Transaction at block time \"${blockTag}\" at index \"${index}\"`\n    if (blockHash && index !== undefined)\n      identifier = `Transaction at block hash \"${blockHash}\" at index \"${index}\"`\n    if (blockNumber && index !== undefined)\n      identifier = `Transaction at block number \"${blockNumber}\" at index \"${index}\"`\n    if (hash) identifier = `Transaction with hash \"${hash}\"`\n    super(`${identifier} could not be found.`)\n  }\n}\n\nexport class TransactionReceiptNotFoundError extends BaseError {\n  name = 'TransactionReceiptNotFoundError'\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Transaction receipt with hash \"${hash}\" could not be found. The Transaction may not be processed on a block yet.`,\n    )\n  }\n}\n\nexport class WaitForTransactionReceiptTimeoutError extends BaseError {\n  name = 'WaitForTransactionReceiptTimeoutError'\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Timed out while waiting for transaction with hash \"${hash}\" to be confirmed.`,\n    )\n  }\n}\n","import { Abi } from 'abitype'\nimport { CallParameters } from '../actions'\nimport { panicReasons } from '../constants'\nimport { Address, Chain, Hex } from '../types'\nimport {\n  DecodeErrorResultReturnType,\n  decodeErrorResult,\n  getAbiItem,\n  formatAbiItem,\n  formatAbiItemWithArgs,\n  formatEther,\n  formatGwei,\n} from '../utils'\nimport { BaseError } from './base'\nimport { prettyPrint } from './transaction'\nimport { getContractAddress } from './utils'\n\nexport class CallExecutionError extends BaseError {\n  cause: BaseError\n\n  name = 'CallExecutionError'\n\n  constructor(\n    cause: BaseError,\n    {\n      account,\n      docsPath,\n      chain,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    }: CallParameters & { chain?: Chain; docsPath?: string },\n  ) {\n    const prettyArgs = prettyPrint({\n      from: account?.address,\n      to,\n      value:\n        typeof value !== 'undefined' &&\n        `${formatEther(value)} ${chain?.nativeCurrency.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice:\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Raw Call Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n    })\n    this.cause = cause\n  }\n}\n\nexport class ContractFunctionExecutionError extends BaseError {\n  abi: Abi\n  args?: unknown[]\n  cause: BaseError\n  contractAddress?: Address\n  formattedArgs?: string\n  functionName: string\n  sender?: Address\n\n  name = 'ContractFunctionExecutionError'\n\n  constructor(\n    cause: BaseError,\n    {\n      abi,\n      args,\n      contractAddress,\n      docsPath,\n      functionName,\n      sender,\n    }: {\n      abi: Abi\n      args?: any\n      contractAddress?: Address\n      docsPath?: string\n      functionName: string\n      sender?: Address\n    },\n  ) {\n    const abiItem = getAbiItem({ abi, args, name: functionName })\n    const formattedArgs = abiItem\n      ? formatAbiItemWithArgs({\n          abiItem,\n          args,\n          includeFunctionName: false,\n          includeName: false,\n        })\n      : undefined\n    const functionWithParams = abiItem\n      ? formatAbiItem(abiItem, { includeName: true })\n      : undefined\n\n    const prettyArgs = prettyPrint({\n      address: contractAddress && getContractAddress(contractAddress),\n      function: functionWithParams,\n      args:\n        formattedArgs &&\n        formattedArgs !== '()' &&\n        `${[...Array(functionName?.length ?? 0).keys()]\n          .map(() => ' ')\n          .join('')}${formattedArgs}`,\n      sender,\n    })\n\n    super(\n      cause.shortMessage ||\n        `An unknown error occurred while executing the contract function \"${functionName}\".`,\n      {\n        cause,\n        docsPath,\n        metaMessages: [\n          ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n          'Contract Call:',\n          prettyArgs,\n        ].filter(Boolean) as string[],\n      },\n    )\n    this.abi = abi\n    this.args = args\n    this.cause = cause\n    this.contractAddress = contractAddress\n    this.functionName = functionName\n    this.sender = sender\n  }\n}\n\nexport class ContractFunctionRevertedError extends BaseError {\n  name = 'ContractFunctionRevertedError'\n\n  data?: DecodeErrorResultReturnType\n  reason?: string\n\n  constructor({\n    abi,\n    data,\n    functionName,\n    message,\n  }: { abi: Abi; data?: Hex; functionName: string; message?: string }) {\n    let decodedData: DecodeErrorResultReturnType | undefined = undefined\n    let metaMessages\n    let reason\n    if (data && data !== '0x') {\n      decodedData = decodeErrorResult({ abi, data })\n      const { abiItem, errorName, args: errorArgs } = decodedData\n      if (errorName === 'Error') {\n        reason = (errorArgs as [string])[0]\n      } else if (errorName === 'Panic') {\n        const [firstArg] = errorArgs as [number]\n        reason = panicReasons[firstArg as keyof typeof panicReasons]\n      } else if (errorArgs) {\n        const errorWithParams = abiItem\n          ? formatAbiItem(abiItem, { includeName: true })\n          : undefined\n        const formattedArgs = abiItem\n          ? formatAbiItemWithArgs({\n              abiItem,\n              args: errorArgs,\n              includeFunctionName: false,\n              includeName: false,\n            })\n          : undefined\n\n        metaMessages = [\n          errorWithParams ? `Error: ${errorWithParams}` : '',\n          formattedArgs && formattedArgs !== '()'\n            ? `       ${[...Array(errorName?.length ?? 0).keys()]\n                .map(() => ' ')\n                .join('')}${formattedArgs}`\n            : '',\n        ]\n      }\n    } else if (message) reason = message\n\n    super(\n      reason\n        ? [\n            `The contract function \"${functionName}\" reverted with the following reason:`,\n            reason,\n          ].join('\\n')\n        : `The contract function \"${functionName}\" reverted.`,\n      {\n        metaMessages,\n      },\n    )\n\n    this.reason = reason\n    this.data = decodedData\n  }\n}\n\nexport class ContractFunctionZeroDataError extends BaseError {\n  name = 'ContractFunctionZeroDataError'\n  constructor({ functionName }: { functionName: string }) {\n    super(`The contract function \"${functionName}\" returned no data (\"0x\").`, {\n      metaMessages: [\n        'This could be due to any of the following:',\n        `  - The contract does not have the function \"${functionName}\",`,\n        '  - The parameters passed to the contract function may be invalid, or',\n        '  - The address is not a contract.',\n      ],\n    })\n  }\n}\n\nexport class RawContractError extends BaseError {\n  code = 3\n  name = 'RawContractError'\n\n  data?: Hex\n\n  constructor({ data, message }: { data?: Hex; message?: string }) {\n    super(message || '')\n    this.data = data\n  }\n}\n","import { BaseError } from './base'\n\nexport class SizeExceedsPaddingSizeError extends BaseError {\n  name = 'SizeExceedsPaddingSizeError'\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`,\n    )\n  }\n}\n","import { ByteArray, Hex } from '../types'\nimport { BaseError } from './base'\n\nexport class DataLengthTooLongError extends BaseError {\n  name = 'DataLengthTooLongError'\n  constructor({ consumed, length }: { consumed: number; length: number }) {\n    super(\n      `Consumed bytes (${consumed}) is shorter than data length (${\n        length - 1\n      }).`,\n    )\n  }\n}\n\nexport class DataLengthTooShortError extends BaseError {\n  name = 'DataLengthTooShortError'\n  constructor({ length, dataLength }: { length: number; dataLength: number }) {\n    super(\n      `Data length (${dataLength - 1}) is shorter than prefix length (${\n        length - 1\n      }).`,\n    )\n  }\n}\n\nexport class InvalidBytesBooleanError extends BaseError {\n  name = 'InvalidBytesBooleanError'\n  constructor(bytes: ByteArray) {\n    super(\n      `Bytes value \"${bytes}\" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,\n    )\n  }\n}\n\nexport class InvalidHexBooleanError extends BaseError {\n  name = 'InvalidHexBooleanError'\n  constructor(hex: Hex) {\n    super(\n      `Hex value \"${hex}\" is not a valid boolean. The hex value must be \"0x0\" (false) or \"0x1\" (true).`,\n    )\n  }\n}\n\nexport class InvalidHexValueError extends BaseError {\n  name = 'InvalidHexValueError'\n  constructor(value: Hex) {\n    super(\n      `Hex value \"${value}\" is an odd length (${value.length}). It must be an even length.`,\n    )\n  }\n}\n\nexport class OffsetOutOfBoundsError extends BaseError {\n  name = 'OffsetOutOfBoundsError'\n  constructor({ nextOffset, offset }: { nextOffset: number; offset: number }) {\n    super(\n      `Next offset (${nextOffset}) is greater than previous offset + consumed bytes (${offset})`,\n    )\n  }\n}\n","import { EstimateGasParameters } from '../actions'\nimport { Chain } from '../types'\nimport { formatEther, formatGwei } from '../utils'\nimport { BaseError } from './base'\nimport { prettyPrint } from './transaction'\n\nexport class EstimateGasExecutionError extends BaseError {\n  cause: BaseError\n\n  name = 'EstimateGasExecutionError'\n\n  constructor(\n    cause: BaseError,\n    {\n      account,\n      docsPath,\n      chain,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    }: EstimateGasParameters & { chain?: Chain; docsPath?: string },\n  ) {\n    const prettyArgs = prettyPrint({\n      from: account.address,\n      to,\n      value:\n        typeof value !== 'undefined' &&\n        `${formatEther(value)} ${chain?.nativeCurrency.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice:\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Estimate Gas Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n    })\n    this.cause = cause\n  }\n}\n","import { BaseError } from './base'\n\nexport class FilterTypeNotSupportedError extends BaseError {\n  name = 'FilterTypeNotSupportedError'\n  constructor(type: string) {\n    super(`Filter type \"${type}\" is not supported.`)\n  }\n}\n","import { formatGwei } from '../utils'\nimport { BaseError } from './base'\n\n/**\n * geth:    https://github.com/ethereum/go-ethereum/blob/master/core/error.go\n *          https://github.com/ethereum/go-ethereum/blob/master/core/types/transaction.go#L34-L41\n *\n * erigon:  https://github.com/ledgerwatch/erigon/blob/master/core/error.go\n *          https://github.com/ledgerwatch/erigon/blob/master/core/types/transaction.go#L41-L46\n *\n * anvil:   https://github.com/foundry-rs/foundry/blob/master/anvil/src/eth/error.rs#L108\n */\n\nexport class ExecutionRevertedError extends BaseError {\n  static code = 3\n  static nodeMessage = /execution reverted/\n\n  name = 'ExecutionRevertedError'\n\n  constructor({\n    cause,\n    message,\n  }: { cause?: BaseError; message?: string } = {}) {\n    const reason = message\n      ?.replace('execution reverted: ', '')\n      ?.replace('execution reverted', '')\n    super(\n      `Execution reverted ${\n        reason ? `with reason: ${reason}` : 'for an unknown reason'\n      }.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class FeeCapTooHighError extends BaseError {\n  static nodeMessage =\n    /max fee per gas higher than 2\\^256-1|fee cap higher than 2\\^256-1/\n  name = 'FeeCapTooHigh'\n  constructor({\n    cause,\n    maxFeePerGas,\n  }: { cause?: BaseError; maxFeePerGas?: bigint } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`${\n        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''\n      }) cannot be higher than the maximum allowed value (2^256-1).`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class FeeCapTooLowError extends BaseError {\n  static nodeMessage =\n    /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/\n  name = 'FeeCapTooLow'\n  constructor({\n    cause,\n    maxFeePerGas,\n  }: { cause?: BaseError; maxFeePerGas?: bigint } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`${\n        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ''\n      } gwei) cannot be lower than the block base fee.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class NonceTooHighError extends BaseError {\n  static nodeMessage = /nonce too high/\n  name = 'NonceTooHighError'\n  constructor({ cause, nonce }: { cause?: BaseError; nonce?: number } = {}) {\n    super(\n      `Nonce provided for the transaction ${\n        nonce ? `(${nonce}) ` : ''\n      }is higher than the next one expected.`,\n      { cause },\n    )\n  }\n}\n\nexport class NonceTooLowError extends BaseError {\n  static nodeMessage = /nonce too low|transaction already imported/\n  name = 'NonceTooLowError'\n  constructor({ cause, nonce }: { cause?: BaseError; nonce?: number } = {}) {\n    super(\n      [\n        `Nonce provided for the transaction ${\n          nonce ? `(${nonce}) ` : ''\n        }is lower than the current nonce of the account.`,\n        'Try increasing the nonce or find the latest nonce with `getTransactionCount`.',\n      ].join('\\n'),\n      { cause },\n    )\n  }\n}\n\nexport class NonceMaxValueError extends BaseError {\n  static nodeMessage = /nonce has max value/\n  name = 'NonceMaxValueError'\n  constructor({ cause, nonce }: { cause?: BaseError; nonce?: number } = {}) {\n    super(\n      `Nonce provided for the transaction ${\n        nonce ? `(${nonce}) ` : ''\n      }exceeds the maximum allowed nonce.`,\n      { cause },\n    )\n  }\n}\n\nexport class InsufficientFundsError extends BaseError {\n  static nodeMessage = /insufficient funds/\n  name = 'InsufficientFundsError'\n  constructor({ cause }: { cause?: BaseError } = {}) {\n    super(\n      [\n        'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.',\n      ].join('\\n'),\n      {\n        cause,\n        metaMessages: [\n          'This error could arise when the account does not have enough funds to:',\n          ' - pay for the total gas fee,',\n          ' - pay for the value to send.',\n          ' ',\n          'The cost of the transaction is calculated as `gas * gas fee + value`, where:',\n          ' - `gas` is the amount of gas needed for transaction to execute,',\n          ' - `gas fee` is the gas fee,',\n          ' - `value` is the amount of ether to send to the recipient.',\n        ],\n      },\n    )\n  }\n}\n\nexport class IntrinsicGasTooHighError extends BaseError {\n  static nodeMessage = /intrinsic gas too high|gas limit reached/\n  name = 'IntrinsicGasTooHighError'\n  constructor({ cause, gas }: { cause?: BaseError; gas?: bigint } = {}) {\n    super(\n      `The amount of gas ${\n        gas ? `(${gas}) ` : ''\n      }provided for the transaction exceeds the limit allowed for the block.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class IntrinsicGasTooLowError extends BaseError {\n  static nodeMessage = /intrinsic gas too low/\n  name = 'IntrinsicGasTooLowError'\n  constructor({ cause, gas }: { cause?: BaseError; gas?: bigint } = {}) {\n    super(\n      `The amount of gas ${\n        gas ? `(${gas}) ` : ''\n      }provided for the transaction is too low.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class TransactionTypeNotSupportedError extends BaseError {\n  static nodeMessage = /transaction type not valid/\n  name = 'TransactionTypeNotSupportedError'\n  constructor({ cause }: { cause?: BaseError }) {\n    super('The transaction type is not supported for this chain.', {\n      cause,\n    })\n  }\n}\n\nexport class TipAboveFeeCapError extends BaseError {\n  static nodeMessage =\n    /max priority fee per gas higher than max fee per gas|tip higher than fee cap/\n  name = 'TipAboveFeeCapError'\n  constructor({\n    cause,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n  }: {\n    cause?: BaseError\n    maxPriorityFeePerGas?: bigint\n    maxFeePerGas?: bigint\n  } = {}) {\n    super(\n      [\n        `The provided tip (\\`maxPriorityFeePerGas\\`${\n          maxPriorityFeePerGas\n            ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei`\n            : ''\n        }) cannot be higher than the fee cap (\\`maxFeePerGas\\`${\n          maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''\n        }).`,\n      ].join('\\n'),\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class UnknownNodeError extends BaseError {\n  name = 'UnknownNodeError'\n\n  constructor({ cause }: { cause?: BaseError }) {\n    super(`An error occurred while executing: ${cause?.message}`, {\n      cause,\n    })\n  }\n}\n","import { BaseError } from './base'\nimport { RpcError } from './rpc'\n\nexport class RequestError extends BaseError {\n  constructor(\n    err: Error,\n    {\n      docsPath,\n      metaMessages,\n      shortMessage,\n    }: { docsPath?: string; metaMessages?: string[]; shortMessage: string },\n  ) {\n    super(shortMessage, {\n      cause: err,\n      docsPath,\n      metaMessages,\n    })\n    this.name = err.name\n  }\n}\n\nexport class RpcRequestError extends RequestError {\n  code: number\n\n  constructor(\n    err: RpcError,\n    { docsPath, shortMessage }: { docsPath?: string; shortMessage: string },\n  ) {\n    super(err, { docsPath, metaMessages: err.metaMessages, shortMessage })\n    this.code = err.code\n    this.name = err.name\n  }\n}\n\nexport class ParseRpcError extends RpcRequestError {\n  name = 'ParseRpcError'\n  code = -32700\n\n  constructor(err: RpcError) {\n    super(err, {\n      shortMessage:\n        'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',\n    })\n  }\n}\n\nexport class InvalidRequestRpcError extends RpcRequestError {\n  name = 'InvalidRequestRpcError'\n  code = -32600\n\n  constructor(err: RpcError) {\n    super(err, { shortMessage: 'JSON is not a valid request object.' })\n  }\n}\n\nexport class MethodNotFoundRpcError extends RpcRequestError {\n  name = 'MethodNotFoundRpcError'\n  code = -32601\n\n  constructor(err: RpcError) {\n    super(err, {\n      shortMessage: 'The method does not exist / is not available.',\n    })\n  }\n}\n\nexport class InvalidParamsRpcError extends RpcRequestError {\n  name = 'InvalidParamsRpcError'\n  code = -32602\n\n  constructor(err: RpcError) {\n    super(err, {\n      shortMessage: [\n        'Invalid parameters were provided to the RPC method.',\n        'Double check you have provided the correct parameters.',\n      ].join('\\n'),\n    })\n  }\n}\n\nexport class InternalRpcError extends RpcRequestError {\n  name = 'InternalRpcError'\n  code = -32603\n\n  constructor(err: RpcError) {\n    super(err, { shortMessage: 'An internal error was received.' })\n  }\n}\n\nexport class InvalidInputRpcError extends RpcRequestError {\n  name = 'InvalidInputRpcError'\n  code = -32000\n\n  constructor(err: RpcError) {\n    super(err, {\n      shortMessage: [\n        'Missing or invalid parameters.',\n        'Double check you have provided the correct parameters.',\n      ].join('\\n'),\n    })\n  }\n}\n\nexport class ResourceNotFoundRpcError extends RpcRequestError {\n  name = 'ResourceNotFoundRpcError'\n  code = -32001\n\n  constructor(err: RpcError) {\n    super(err, { shortMessage: 'Requested resource not found.' })\n  }\n}\n\nexport class ResourceUnavailableRpcError extends RpcRequestError {\n  name = 'ResourceUnavailableRpcError'\n  code = -32002\n\n  constructor(err: RpcError) {\n    super(err, { shortMessage: 'Requested resource not available.' })\n  }\n}\n\nexport class TransactionRejectedRpcError extends RpcRequestError {\n  name = 'TransactionRejectedRpcError'\n  code = -32003\n\n  constructor(err: RpcError) {\n    super(err, { shortMessage: 'Transaction creation failed.' })\n  }\n}\n\nexport class MethodNotSupportedRpcError extends RpcRequestError {\n  name = 'MethodNotSupportedRpcError'\n  code = -32004\n\n  constructor(err: RpcError) {\n    super(err, { shortMessage: 'Method is not implemented.' })\n  }\n}\n\nexport class LimitExceededRpcError extends RpcRequestError {\n  name = 'LimitExceededRpcError'\n  code = -32005\n\n  constructor(err: RpcError) {\n    super(err, { shortMessage: 'Request exceeds defined limit.' })\n  }\n}\n\nexport class JsonRpcVersionUnsupportedError extends RpcRequestError {\n  name = 'JsonRpcVersionUnsupportedError'\n  code = -32006\n\n  constructor(err: RpcError) {\n    super(err, {\n      shortMessage: 'Version of JSON-RPC protocol is not supported.',\n    })\n  }\n}\n\nexport class UserRejectedRequestError extends RpcRequestError {\n  name = 'UserRejectedRequestError'\n  code = 4001\n\n  constructor(err: RpcError) {\n    super(err, {\n      shortMessage: 'User rejected the request.',\n    })\n  }\n}\n\nexport class SwitchChainError extends RpcRequestError {\n  name = 'SwitchChainError'\n  code = 4902\n\n  constructor(err: RpcError) {\n    super(err, {\n      shortMessage: 'An error occurred when attempting to switch chain.',\n    })\n  }\n}\n\nexport class UnknownRpcError extends RequestError {\n  name = 'UnknownRpcError'\n\n  constructor(err: Error) {\n    super(err, {\n      shortMessage: 'An unknown RPC error occurred.',\n    })\n  }\n}\n","import { stringify } from '../utils'\nimport { BaseError } from './base'\nimport { getUrl } from './utils'\n\nexport class HttpRequestError extends BaseError {\n  name = 'HttpRequestError'\n\n  body: { [key: string]: unknown }\n  headers?: Headers\n  status?: number\n  url: string\n\n  constructor({\n    body,\n    details,\n    headers,\n    status,\n    url,\n  }: {\n    body: { [key: string]: unknown }\n    details?: string\n    headers?: Headers\n    status?: number\n    url: string\n  }) {\n    super('HTTP request failed.', {\n      details,\n      metaMessages: [\n        status && `Status: ${status}`,\n        `URL: ${getUrl(url)}`,\n        `Request body: ${stringify(body)}`,\n      ].filter(Boolean) as string[],\n    })\n    this.body = body\n    this.headers = headers\n    this.status = status\n    this.url = url\n  }\n}\n\nexport class WebSocketRequestError extends BaseError {\n  name = 'WebSocketRequestError'\n\n  constructor({\n    body,\n    details,\n    url,\n  }: {\n    body: { [key: string]: unknown }\n    details: string\n    url: string\n  }) {\n    super('WebSocket request failed.', {\n      details,\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n    })\n  }\n}\n\nexport class RpcError extends BaseError {\n  code: number\n\n  name = 'RpcError'\n\n  constructor({\n    body,\n    error,\n    url,\n  }: {\n    body: { [key: string]: unknown }\n    error: { code: number; message: string }\n    url: string\n  }) {\n    super('RPC Request failed.', {\n      cause: error as any,\n      details: error.message,\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n    })\n    this.code = error.code\n  }\n}\n\nexport class TimeoutError extends BaseError {\n  name = 'TimeoutError'\n\n  constructor({\n    body,\n    url,\n  }: {\n    body: { [key: string]: unknown }\n    url: string\n  }) {\n    super('The request took too long to respond.', {\n      details: 'The request timed out.',\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n    })\n  }\n}\n","import { BaseError } from './base'\n\nexport class UrlRequiredError extends BaseError {\n  constructor() {\n    super(\n      'No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.',\n      {\n        docsPath: '/docs/clients/intro',\n      },\n    )\n  }\n}\n","import type { ByteArray, Hex } from '../../types'\n\nexport type ConcatReturnType<TValue extends Hex | ByteArray> =\n  TValue extends Hex ? Hex : ByteArray\n\nexport function concat<TValue extends Hex | ByteArray>(\n  values: TValue[],\n): ConcatReturnType<TValue> {\n  if (typeof values[0] === 'string')\n    return concatHex(values as Hex[]) as ConcatReturnType<TValue>\n  return concatBytes(values as ByteArray[]) as ConcatReturnType<TValue>\n}\n\nexport function concatBytes(values: ByteArray[]): ByteArray {\n  let length = 0\n  for (const arr of values) {\n    length += arr.length\n  }\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const arr of values) {\n    result.set(arr, offset)\n    offset += arr.length\n  }\n  return result\n}\n\nexport function concatHex(values: Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace('0x', ''),\n    '',\n  )}`\n}\n","import { ByteArray } from '../../types'\n\nexport function isBytes(value: unknown): value is ByteArray {\n  if (!value) return false\n  if (typeof value !== 'object') return false\n  if (!('BYTES_PER_ELEMENT' in value)) return false\n  return (\n    value.BYTES_PER_ELEMENT === 1 && value.constructor.name === 'Uint8Array'\n  )\n}\n","import { Hex } from '../../types'\n\nexport function isHex(value: unknown): value is Hex {\n  if (!value) return false\n  if (typeof value !== 'string') return false\n  return /^0x[0-9a-fA-F]*$/.test(value)\n}\n","import { SizeExceedsPaddingSizeError } from '../../errors'\nimport type { ByteArray, Hex } from '../../types'\n\ntype PadOptions = {\n  dir?: 'left' | 'right'\n  size?: number | null\n}\nexport type PadReturnType<TValue extends ByteArray | Hex> = TValue extends Hex\n  ? Hex\n  : ByteArray\n\nexport function pad<TValue extends ByteArray | Hex>(\n  hexOrBytes: TValue,\n  { dir, size = 32 }: PadOptions = {},\n): PadReturnType<TValue> {\n  if (typeof hexOrBytes === 'string')\n    return padHex(hexOrBytes, { dir, size }) as PadReturnType<TValue>\n  return padBytes(hexOrBytes, { dir, size }) as PadReturnType<TValue>\n}\n\nexport function padHex(hex_: Hex, { dir, size = 32 }: PadOptions = {}) {\n  if (size === null) return hex_\n  let hex = hex_.replace('0x', '')\n  if (hex.length > size * 2)\n    throw new SizeExceedsPaddingSizeError({\n      size: Math.ceil(hex.length / 2),\n      targetSize: size,\n      type: 'hex',\n    })\n\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](\n    size * 2,\n    '0',\n  )}` as Hex\n}\n\nexport function padBytes(\n  bytes: ByteArray,\n  { dir, size = 32 }: PadOptions = {},\n) {\n  if (size === null) return bytes\n  if (bytes.length > size)\n    throw new SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size,\n      type: 'bytes',\n    })\n  const paddedBytes = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right'\n    paddedBytes[padEnd ? i : size - i - 1] =\n      bytes[padEnd ? i : bytes.length - i - 1]\n  }\n  return paddedBytes\n}\n","import type { ByteArray, Hex } from '../../types'\n\ntype TrimOptions = {\n  dir?: 'left' | 'right'\n}\nexport type TrimReturnType<TValue extends ByteArray | Hex> = TValue extends Hex\n  ? Hex\n  : ByteArray\n\nexport function trim<TValue extends ByteArray | Hex>(\n  hexOrBytes: TValue,\n  { dir = 'left' }: TrimOptions = {},\n): TrimReturnType<TValue> {\n  let data: any =\n    typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes\n\n  let sliceLength = 0\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n      sliceLength++\n    else break\n  }\n  data =\n    dir === 'left'\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength)\n\n  if (typeof hexOrBytes === 'string') {\n    if (data.length === 1 && dir === 'right') data = `${data}0`\n    return `0x${data}` as TrimReturnType<TValue>\n  }\n  return data as TrimReturnType<TValue>\n}\n","import type { ByteArray, Hex } from '../../types'\nimport { isHex } from './isHex'\n\n/**\n * @description Retrieves the size of the value (in bytes).\n *\n * @param value The value (hex or byte array) to retrieve the size of.\n * @returns The size of the value (in bytes).\n */\nexport function size(value: Hex | ByteArray) {\n  if (isHex(value)) return Math.ceil((value.length - 2) / 2)\n  return value.length\n}\n","import type { ByteArray, Hex } from '../../types'\nimport { isHex } from './isHex'\nimport { size } from './size'\n\nexport type SliceReturnType<TValue extends ByteArray | Hex> = TValue extends Hex\n  ? Hex\n  : ByteArray\n\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice<TValue extends ByteArray | Hex>(\n  value: TValue,\n  start?: number,\n  end?: number,\n): SliceReturnType<TValue> {\n  if (isHex(value))\n    return sliceHex(value as Hex, start, end) as SliceReturnType<TValue>\n  return sliceBytes(value as ByteArray, start, end) as SliceReturnType<TValue>\n}\n\nfunction assertStartOffset(value: Hex | ByteArray, start?: number) {\n  if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n    throw new Error(\n      `Slice starting at offset \"${start}\" is out-of-bounds (size: ${size(\n        value,\n      )}).`,\n    )\n}\n\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(value: ByteArray, start?: number, end?: number) {\n  assertStartOffset(value, start)\n  return value.slice(start, end)\n}\n\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(value_: Hex, start?: number, end?: number) {\n  assertStartOffset(value_, start)\n  const value = value_\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value_.length) * 2)\n  return `0x${value}`\n}\n","import { pad } from '../data'\nimport type { ByteArray, Hex } from '../../types'\n\nconst hexes = Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\n/**\n * @description Encodes a boolean into a hex string\n */\nexport function boolToHex(value: boolean): Hex {\n  return `0x${Number(value)}`\n}\n\n/**\n * @description Encodes a bytes array into a hex string\n */\nexport function bytesToHex(value: ByteArray): Hex {\n  let hex = ''\n  for (let i = 0; i < value.length; i++) {\n    hex += hexes[value[i]]\n  }\n  return `0x${hex}`\n}\n\n/**\n * @description Encodes a string, number, bigint, or ByteArray into a hex string\n */\nexport function toHex(\n  value: string | number | bigint | boolean | ByteArray,\n): Hex {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToHex(value)\n  if (typeof value === 'string') {\n    return stringToHex(value)\n  }\n  if (typeof value === 'boolean') return boolToHex(value)\n  return bytesToHex(value)\n}\n\nexport type NumberToHexOpts =\n  | {\n      // Whether or not the number of a signed representation.\n      signed?: boolean\n      // The size of the output hex (in bytes).\n      size: number\n    }\n  | {\n      signed?: never\n      size?: never\n    }\n\n/**\n * @description Encodes a number or bigint into a hex string\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts\n\n  let value = BigInt(value_)\n\n  let maxValue\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : ''\n    throw new Error(\n      `Number \"${value_}${suffix}\" is not in safe ${\n        size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''\n      }integer range ${\n        maxValue\n          ? `(${minValue}${suffix} to ${maxValue}${suffix})`\n          : `(above ${minValue})`\n      }`,\n    )\n  }\n\n  const hex = `0x${(signed && value < 0\n    ? (1n << BigInt(size * 8)) + BigInt(value)\n    : value\n  ).toString(16)}` as Hex\n  if (size) return pad(hex, { size }) as Hex\n  return hex\n}\n\n/**\n * @description Encodes a UTF-8 string into a hex string\n */\nexport function stringToHex(value: string): Hex {\n  let hex = ''\n  for (let i = 0; i < value.length; i++) {\n    hex += value.charCodeAt(i).toString(16)\n  }\n  return `0x${hex}`\n}\n","import { BaseError } from '../../errors'\nimport type { ByteArray, Hex } from '../../types'\nimport type { NumberToHexOpts } from './toHex'\nimport { numberToHex } from './toHex'\n\nconst encoder = new TextEncoder()\n\n/** @description Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array. */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value)\n  if (typeof value === 'boolean') return boolToBytes(value)\n  if (value.startsWith('0x')) return hexToBytes(value as Hex)\n  return stringToBytes(value)\n}\n\n/**\n * @description Encodes a boolean into a byte array.\n */\nexport function boolToBytes(value: boolean) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  return bytes\n}\n\n/**\n * @description Encodes a hex string into a byte array.\n */\nexport function hexToBytes(hex_: Hex): ByteArray {\n  let hex = hex_.slice(2) as string\n\n  if (hex.length % 2) hex = `0${hex}`\n\n  const bytes = new Uint8Array(hex.length / 2)\n  for (let index = 0; index < bytes.length; index++) {\n    const start = index * 2\n    const hexByte = hex.slice(start, start + 2)\n    const byte = Number.parseInt(hexByte, 16)\n    if (Number.isNaN(byte) || byte < 0)\n      throw new BaseError(`Invalid byte sequence (\"${hexByte}\" in \"${hex}\").`)\n    bytes[index] = byte\n  }\n  return bytes\n}\n\n/**\n * @description Encodes a number into a byte array.\n */\nexport function numberToBytes(value: bigint | number, opts?: NumberToHexOpts) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\n/**\n * @description Encodes a UTF-8 string into a byte array.\n */\nexport function stringToBytes(value: string): ByteArray {\n  return encoder.encode(value)\n}\n","import type { ByteArray, Hex } from '../../types'\nimport { concat } from '../data'\nimport { toBytes } from './toBytes'\nimport { bytesToHex } from './toHex'\n\nexport type RecursiveArray<T> = T | RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\nexport type ToRlpReturnType<TTo extends To> = TTo extends 'bytes'\n  ? ByteArray\n  : TTo extends 'hex'\n  ? Hex\n  : never\n\nexport function toRlp<TTo extends To = 'hex'>(\n  hexOrBytes: RecursiveArray<Hex> | RecursiveArray<ByteArray>,\n  to_?: TTo,\n) {\n  const to = to_ || ('hex' as const)\n  return format(bytesToRlp(parse(hexOrBytes)), to) as ToRlpReturnType<TTo>\n}\n\nfunction parse(\n  hexOrBytes: RecursiveArray<Hex> | RecursiveArray<ByteArray>,\n): RecursiveArray<ByteArray> {\n  if (Array.isArray(hexOrBytes)) return hexOrBytes.map(parse)\n  return typeof hexOrBytes === 'string' ? toBytes(hexOrBytes) : hexOrBytes\n}\n\nfunction format(bytes: ByteArray, type: 'hex' | 'bytes' = 'bytes') {\n  return type === 'hex' ? bytesToHex(bytes) : bytes\n}\n\nexport function bytesToRlp(bytes: RecursiveArray<ByteArray>): ByteArray {\n  if (Array.isArray(bytes)) {\n    const encoded = concat(bytes.map(bytesToRlp))\n    return new Uint8Array([...encodeLength(encoded.length, 0xc0), ...encoded])\n  }\n\n  if (bytes.length === 1 && bytes[0] < 0x80) return bytes\n  return new Uint8Array([...encodeLength(bytes.length, 0x80), ...bytes])\n}\n\nfunction encodeLength(length: number, offset: number) {\n  if (length < 56) return [offset + length]\n  return [toBytes(length).length + offset + 55, ...toBytes(length)]\n}\n","import { InvalidHexBooleanError } from '../../errors'\nimport type { ByteArray, Hex } from '../../types'\nimport { trim } from '../data'\nimport { hexToBytes } from './toBytes'\n\ntype FromHexReturnType<TTo> = TTo extends 'string'\n  ? string\n  : TTo extends 'bigint'\n  ? bigint\n  : TTo extends 'number'\n  ? number\n  : TTo extends 'bytes'\n  ? ByteArray\n  : TTo extends 'boolean'\n  ? boolean\n  : never\n\n/**\n * @description Decodes a hex string into a string, number, bigint, boolean, or bytes32 array.\n */\nexport function fromHex<\n  TTo extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n>(hex: Hex, to: TTo): FromHexReturnType<TTo> {\n  if (to === 'number') return hexToNumber(hex) as FromHexReturnType<TTo>\n  if (to === 'bigint') return hexToBigInt(hex) as FromHexReturnType<TTo>\n  if (to === 'string') return hexToString(hex) as FromHexReturnType<TTo>\n  if (to === 'boolean') return hexToBool(hex) as FromHexReturnType<TTo>\n  return hexToBytes(hex) as FromHexReturnType<TTo>\n}\n\nexport type HexToBigIntOpts = {\n  // Whether or not the number of a signed representation.\n  signed?: boolean\n}\n\n/**\n * @description Decodes a hex string into a bigint.\n */\nexport function hexToBigInt(hex: Hex, opts: HexToBigIntOpts = {}): bigint {\n  const { signed } = opts\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n  const max = (1n << (BigInt(size) * 8n - 1n)) - 1n\n  if (value <= max) return value\n\n  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n\n}\n\n/**\n * @description Decodes a hex string into a boolean.\n */\nexport function hexToBool(hex: Hex): boolean {\n  if (trim(hex) === '0x0') return false\n  if (trim(hex) === '0x1') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\ntype NumberToHexOpts = HexToBigIntOpts\n\n/**\n * @description Decodes a hex string into a number.\n */\nexport function hexToNumber(hex: Hex, opts: NumberToHexOpts = {}): number {\n  return Number(hexToBigInt(hex, opts))\n}\n\n/**\n * @description Decodes a hex string into a UTF-8 string.\n */\nexport function hexToString(hex: Hex): string {\n  const bytes = hexToBytes(hex)\n  return new TextDecoder().decode(bytes)\n}\n","import { InvalidBytesBooleanError } from '../../errors'\nimport type { ByteArray, Hex } from '../../types'\nimport { hexToBigInt, hexToNumber } from './fromHex'\nimport { bytesToHex } from './toHex'\n\ntype FromBytesReturnType<TTo> = TTo extends 'string'\n  ? string\n  : TTo extends 'hex'\n  ? Hex\n  : TTo extends 'bigint'\n  ? bigint\n  : TTo extends 'number'\n  ? number\n  : TTo extends 'boolean'\n  ? boolean\n  : never\n\n/**\n * @description Decodes a byte array into a UTF-8 string, hex value, number, bigint or boolean.\n */\nexport function fromBytes<\n  TTo extends 'string' | 'hex' | 'bigint' | 'number' | 'boolean',\n>(bytes: ByteArray, to: TTo): FromBytesReturnType<TTo> {\n  if (to === 'number') return bytesToNumber(bytes) as FromBytesReturnType<TTo>\n  if (to === 'bigint') return bytesToBigint(bytes) as FromBytesReturnType<TTo>\n  if (to === 'boolean') return bytesToBool(bytes) as FromBytesReturnType<TTo>\n  if (to === 'string') return bytesToString(bytes) as FromBytesReturnType<TTo>\n  return bytesToHex(bytes) as FromBytesReturnType<TTo>\n}\n\n/**\n * @description Decodes a byte array into a bigint.\n */\nexport function bytesToBigint(bytes: ByteArray): bigint {\n  const hex = bytesToHex(bytes)\n  return hexToBigInt(hex)\n}\n\n/**\n * @description Decodes a byte array into a boolean.\n */\nexport function bytesToBool(bytes: ByteArray): boolean {\n  if (bytes.length > 1 || bytes[0] > 1)\n    throw new InvalidBytesBooleanError(bytes)\n  return Boolean(bytes[0])\n}\n\nexport { bytesToHex }\n\n/**\n * @description Decodes a byte array into a number.\n */\nexport function bytesToNumber(bytes: ByteArray): number {\n  const hex = bytesToHex(bytes)\n  return hexToNumber(hex)\n}\n\n/**\n * @description Decodes a byte array into a UTF-8 string.\n */\nexport function bytesToString(bytes: ByteArray): string {\n  return new TextDecoder().decode(bytes)\n}\n","import {\n  DataLengthTooLongError,\n  DataLengthTooShortError,\n  InvalidHexValueError,\n  OffsetOutOfBoundsError,\n} from '../../errors'\nimport type { ByteArray, Hex } from '../../types'\nimport { trim } from '../data'\nimport { bytesToNumber } from './fromBytes'\nimport { hexToBytes } from './toBytes'\nimport { bytesToHex } from './toHex'\nimport type { RecursiveArray } from './toRlp'\n\ntype FromRlpReturnType<TTo> = TTo extends 'bytes'\n  ? ByteArray\n  : TTo extends 'hex'\n  ? Hex\n  : never\n\nexport function fromRlp<TTo extends 'bytes' | 'hex'>(\n  value: ByteArray | Hex,\n  to: TTo,\n): RecursiveArray<FromRlpReturnType<TTo>> {\n  const bytes = parse(value)\n  const [data, consumed] = rlpToBytes(bytes)\n  if (consumed < bytes.length)\n    throw new DataLengthTooLongError({\n      consumed,\n      length: bytes.length,\n    })\n  return format(data, to)\n}\n\nfunction parse(value: ByteArray | Hex) {\n  if (typeof value === 'string') {\n    if (value.length > 3 && value.length % 2 !== 0)\n      throw new InvalidHexValueError(value)\n    return hexToBytes(value)\n  }\n  return value\n}\n\nfunction format<TTo extends 'bytes' | 'hex'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: TTo,\n): RecursiveArray<FromRlpReturnType<TTo>> {\n  if (Array.isArray(bytes)) return bytes.map((b) => format(b, to))\n  return (\n    to === 'hex' ? trim(bytesToHex(bytes)) : bytes\n  ) as FromRlpReturnType<TTo>\n}\n\nfunction rlpToBytes(\n  bytes: ByteArray,\n  offset = 0,\n): [result: RecursiveArray<ByteArray>, consumed: number] {\n  if (bytes.length === 0) return [new Uint8Array([]), 0]\n\n  const prefix = bytes[offset]\n\n  if (prefix <= 0x7f) return [new Uint8Array([bytes[offset]]), 1]\n\n  if (prefix <= 0xb7) {\n    const length = prefix - 0x80\n    const offset_ = offset + 1\n\n    if (offset_ + length > bytes.length)\n      throw new DataLengthTooShortError({\n        length: offset_ + length,\n        dataLength: bytes.length,\n      })\n\n    return [bytes.slice(offset_, offset_ + length), 1 + length]\n  }\n\n  if (prefix <= 0xbf) {\n    const lengthOfLength = prefix - 0xb7\n    const offset_ = offset + 1\n    const length = bytesToNumber(bytes.slice(offset_, offset_ + lengthOfLength))\n\n    if (offset_ + lengthOfLength + length > bytes.length)\n      throw new DataLengthTooShortError({\n        length: lengthOfLength + length,\n        dataLength: bytes.length - lengthOfLength,\n      })\n\n    return [\n      bytes.slice(offset_ + lengthOfLength, offset_ + lengthOfLength + length),\n      1 + lengthOfLength + length,\n    ]\n  }\n\n  let lengthOfLength = 0\n  let length = prefix - 0xc0\n  if (prefix > 0xf7) {\n    lengthOfLength = prefix - 0xf7\n    length = bytesToNumber(bytes.slice(offset + 1, offset + 1 + lengthOfLength))\n  }\n\n  let nextOffset = offset + 1 + lengthOfLength\n  if (nextOffset > bytes.length)\n    throw new DataLengthTooShortError({\n      length: nextOffset,\n      dataLength: bytes.length,\n    })\n\n  let consumed = 1 + lengthOfLength + length\n  let result = []\n  while (nextOffset < offset + consumed) {\n    const decoded = rlpToBytes(bytes, nextOffset)\n    result.push(decoded[0])\n    nextOffset += decoded[1]\n    if (nextOffset > offset + consumed)\n      throw new OffsetOutOfBoundsError({\n        nextOffset: nextOffset,\n        offset: offset + consumed,\n      })\n  }\n\n  return [result, consumed]\n}\n","const paramsRegex = /((function|event)\\s)?(.*)(\\((.*)\\))/\n\nexport function extractFunctionParts(def: string) {\n  const parts = def.match(paramsRegex)\n  const type = parts?.[2] || undefined\n  const name = parts?.[3]\n  const params = parts?.[5] || undefined\n  return { type, name, params }\n}\n\nexport function extractFunctionName(def: string) {\n  return extractFunctionParts(def).name\n}\n\nexport function extractFunctionParams(def: string) {\n  const params = extractFunctionParts(def).params\n  const splitParams = params?.split(',').map((x) => x.trim().split(' '))\n  return splitParams?.map((param) => ({\n    type: param[0],\n    name: param[1] === 'indexed' ? param[2] : param[1],\n    ...(param[1] === 'indexed' ? { indexed: true } : {}),\n  }))\n}\n\nexport function extractFunctionType(def: string) {\n  return extractFunctionParts(def).type\n}\n","import { keccak_256 } from '@noble/hashes/sha3'\n\nimport type { ByteArray, Hex } from '../../types'\nimport { isHex } from '../data'\nimport { toBytes, toHex } from '../encoding'\n\ntype To = 'hex' | 'bytes'\n\nexport type Keccak256Hash<TTo extends To> =\n  | (TTo extends 'bytes' ? ByteArray : never)\n  | (TTo extends 'hex' ? Hex : never)\n\nexport function keccak256<TTo extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: TTo,\n): Keccak256Hash<TTo> {\n  const to = to_ || 'hex'\n  const bytes = keccak_256(isHex(value) ? toBytes(value) : value)\n  if (to === 'bytes') return bytes as Keccak256Hash<TTo>\n  return toHex(bytes) as Keccak256Hash<TTo>\n}\n","import { toBytes } from '../encoding'\nimport { extractFunctionName, extractFunctionParams } from '../contract'\nimport { keccak256 } from './keccak256'\n\nconst hash = (value: string) => keccak256(toBytes(value))\n\nexport function hashFunction(def: string) {\n  const name = extractFunctionName(def)\n  const params = extractFunctionParams(def)\n  if (!params || params.length === 0) return hash(def.replace(/ /g, ''))\n  return hash(`${name}(${params.map(({ type }) => type).join(',')})`)\n}\n","import { EventDefinition } from '../../types'\nimport { hashFunction } from './hashFunction'\n\nexport const getEventSelector = (event: EventDefinition) => hashFunction(event)\n","import { slice } from '../data'\nimport { hashFunction } from './hashFunction'\n\nexport const getFunctionSelector = (fn: string) => slice(hashFunction(fn), 0, 4)\n","import type { Address } from '../../types'\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/\n\nexport function isAddress(address: string): address is Address {\n  return addressRegex.test(address)\n}\n","import { InvalidAddressError } from '../../errors'\nimport type { Address } from '../../types'\nimport { stringToBytes } from '../encoding'\nimport { keccak256 } from '../hash'\nimport { isAddress } from './isAddress'\n\nexport function checksumAddress(address_: Address): Address {\n  const hexAddress = address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  let address = hexAddress.split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  return `0x${address.join('')}`\n}\n\nexport function getAddress(address: string): Address {\n  if (!isAddress(address)) throw new InvalidAddressError({ address })\n  return checksumAddress(address)\n}\n","import type { Address, ByteArray, Hex } from '../../types'\nimport { concat, isBytes, pad, slice } from '../data'\nimport { toBytes, toRlp } from '../encoding'\nimport { keccak256 } from '../hash'\nimport { getAddress } from './getAddress'\n\nexport type GetCreateAddressOptions = {\n  from: Address\n  nonce: bigint\n}\n\nexport type GetCreate2AddressOptions = {\n  bytecode: ByteArray | Hex\n  from: Address\n  salt: ByteArray | Hex\n}\n\nexport type GetContractAddressOptions =\n  | ({\n      opcode?: 'CREATE'\n    } & GetCreateAddressOptions)\n  | ({ opcode: 'CREATE2' } & GetCreate2AddressOptions)\n\nexport function getContractAddress(opts: GetContractAddressOptions) {\n  if (opts.opcode === 'CREATE2') return getCreate2Address(opts)\n  return getCreateAddress(opts)\n}\n\nexport function getCreateAddress(opts: GetCreateAddressOptions) {\n  const from = toBytes(getAddress(opts.from))\n\n  let nonce = toBytes(opts.nonce)\n  if (nonce[0] === 0) nonce = new Uint8Array([])\n\n  return getAddress(\n    `0x${keccak256(toRlp([from, nonce], 'bytes')).slice(26)}` as Address,\n  )\n}\n\nexport function getCreate2Address(opts: GetCreate2AddressOptions) {\n  const from = toBytes(getAddress(opts.from))\n  const salt = pad(isBytes(opts.salt) ? opts.salt : toBytes(opts.salt as Hex), {\n    size: 32,\n  }) as ByteArray\n  const bytecodeHash = toBytes(\n    keccak256(\n      (isBytes(opts.bytecode)\n        ? opts.bytecode\n        : toBytes(opts.bytecode as Hex)) as ByteArray,\n    ),\n  )\n  return getAddress(\n    slice(keccak256(concat([toBytes('0xff'), from, salt, bytecodeHash])), 12),\n  )\n}\n","import type { Address } from '../../types'\nimport { InvalidAddressError } from '../../errors'\nimport { isAddress } from './isAddress'\n\nexport function isAddressEqual(a: Address, b: Address) {\n  if (!isAddress(a)) throw new InvalidAddressError({ address: a })\n  if (!isAddress(b)) throw new InvalidAddressError({ address: b })\n  return a.toLowerCase() === b.toLowerCase()\n}\n","import {\n  AbiParameter,\n  AbiParametersToPrimitiveTypes,\n  AbiParameterToPrimitiveType,\n  Narrow,\n} from 'abitype'\n\nimport {\n  AbiEncodingArrayLengthMismatchError,\n  AbiEncodingBytesSizeMismatchError,\n  AbiEncodingLengthMismatchError,\n  InvalidAbiEncodingTypeError,\n  InvalidAddressError,\n  InvalidArrayError,\n} from '../../errors'\nimport { Hex } from '../../types'\nimport { isAddress } from '../address'\nimport { concat, padHex, size, slice } from '../data'\nimport { boolToHex, numberToHex, stringToHex } from '../encoding'\n\nexport type EncodeAbiParametersReturnType = Hex\n\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n */\nexport function encodeAbiParameters<\n  TParams extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: Narrow<TParams>,\n  values: TParams extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<TParams>\n    : never,\n): EncodeAbiParametersReturnType {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length as number,\n      givenLength: values.length,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values,\n  })\n  const data = encodeParams(preparedParams)\n  if (data.length === 0) return '0x'\n  return data\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex }\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>\n\nfunction prepareParams<TParams extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: Narrow<TParams>\n  values: AbiParametersToPrimitiveTypes<TParams>\n}) {\n  let preparedParams: PreparedParam[] = []\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }))\n  }\n  return preparedParams\n}\n\nfunction prepareParam<TParam extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: TParam\n  value: AbiParameterToPrimitiveType<TParam>\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, { length, param: { ...param, type } })\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    })\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value as unknown as Hex)\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value as unknown as boolean)\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int')\n    return encodeNumber(value as unknown as number, { signed })\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex, { param })\n  }\n  if (param.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters',\n  })\n}\n\n/////////////////////////////////////////////////////////////////\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) staticSize += 32\n    else staticSize += size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  let staticParams: Hex[] = []\n  let dynamicParams: Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }))\n      dynamicParams.push(encoded)\n      dynamicSize += size(encoded)\n    } else {\n      staticParams.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams])\n}\n\n/////////////////////////////////////////////////////////////////\n\nfunction encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) throw new InvalidAddressError({ address: value })\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) }\n}\n\nfunction encodeArray<TParam extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null\n    param: TParam\n  },\n): PreparedParam {\n  let dynamic = length === null\n\n  if (!Array.isArray(value)) throw new InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  let preparedParams: PreparedParam[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParams.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams)\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\nfunction encodeBytes<TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n): PreparedParam {\n  const [_, size_] = param.type.split('bytes')\n  if (!size_) {\n    const partsLength = Math.floor(size(value) / 32)\n    const parts: Hex[] = []\n    for (let i = 0; i < partsLength + 1; i++) {\n      parts.push(\n        padHex(slice(value, i * 32, (i + 1) * 32), {\n          dir: 'right',\n        }),\n      )\n    }\n    return {\n      dynamic: true,\n      encoded: concat([\n        padHex(numberToHex(size(value), { size: 32 })),\n        ...parts,\n      ]),\n    }\n  }\n  if (size(value) !== parseInt(size_))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: parseInt(size_),\n      value,\n    })\n  return { dynamic: false, encoded: padHex(value, { dir: 'right' }) }\n}\n\nfunction encodeBool(value: boolean): PreparedParam {\n  return { dynamic: false, encoded: padHex(boolToHex(value)) }\n}\n\nfunction encodeNumber(\n  value: number,\n  { signed }: { signed: boolean },\n): PreparedParam {\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\nfunction encodeString(value: string): PreparedParam {\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(value.length, { size: 32 })),\n      padHex(stringToHex(value), { dir: 'right' }),\n    ]),\n  }\n}\n\nfunction encodeTuple<\n  TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  { param }: { param: TParam },\n): PreparedParam {\n  let dynamic = false\n  let preparedParams: PreparedParam[] = []\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i]\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParam({\n      param: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParams.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined\n}\n","import {\n  AbiParameter,\n  AbiParametersToPrimitiveTypes,\n  AbiParameterToPrimitiveType,\n  Narrow,\n} from 'abitype'\n\nimport {\n  AbiDecodingDataSizeInvalidError,\n  AbiDecodingZeroDataError,\n  InvalidAbiDecodingTypeError,\n} from '../../errors'\nimport { Hex } from '../../types'\nimport { checksumAddress } from '../address'\nimport { size, slice, trim } from '../data'\nimport { hexToBigInt, hexToBool, hexToNumber, hexToString } from '../encoding'\nimport { getArrayComponents } from './encodeAbiParameters'\n\nexport type DecodeAbiParametersReturnType<\n  TParams extends\n    | readonly AbiParameter[]\n    | readonly unknown[] = readonly AbiParameter[],\n> = AbiParametersToPrimitiveTypes<\n  TParams extends readonly AbiParameter[] ? TParams : AbiParameter[]\n>\n\nexport function decodeAbiParameters<\n  TParams extends readonly AbiParameter[] | readonly unknown[],\n>(params: Narrow<TParams>, data: Hex): DecodeAbiParametersReturnType<TParams> {\n  if (data === '0x' && params.length > 0) throw new AbiDecodingZeroDataError()\n  if (size(data) % 32 !== 0)\n    throw new AbiDecodingDataSizeInvalidError(size(data))\n  return decodeParams({\n    data,\n    params: params as readonly AbiParameter[],\n  }) as unknown as DecodeAbiParametersReturnType<TParams>\n}\n\n////////////////////////////////////////////////////////////////////\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\n\nfunction decodeParams<TParams extends readonly AbiParameter[]>({\n  data,\n  params,\n}: { data: Hex; params: TParams }) {\n  let decodedValues: unknown[] = []\n  let position = 0\n\n  for (let i = 0; i < params.length; i++) {\n    const param = params[i]\n    const { consumed, value } = decodeParam({ data, param, position })\n    decodedValues.push(value)\n    // Step across the data by the amount of data consumed by this parameter.\n    position += consumed\n  }\n\n  return decodedValues as unknown as AbiParametersToPrimitiveTypes<TParams>\n}\n\nfunction decodeParam({\n  data,\n  param,\n  position,\n}: { data: Hex; param: AbiParameter; position: number }): {\n  consumed: number\n  value: any\n} {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(data, {\n      length,\n      param: { ...param, type: type } as AbiParameter,\n      position,\n    })\n  }\n  if (param.type === 'tuple') {\n    return decodeTuple(data, { param: param as TupleAbiParameter, position })\n  }\n  if (param.type === 'string') {\n    return decodeString(data, { position })\n  }\n  if (param.type.startsWith('bytes')) {\n    return decodeBytes(data, { param, position })\n  }\n\n  let value = slice(data, position, position + 32) as Hex\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    return decodeNumber(value, { param })\n  }\n  if (param.type === 'address') {\n    return decodeAddress(value)\n  }\n  if (param.type === 'bool') {\n    return decodeBool(value)\n  }\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters',\n  })\n}\n\n////////////////////////////////////////////////////////////////////\n\nfunction decodeAddress(value: Hex) {\n  return { consumed: 32, value: checksumAddress(slice(value, -20)) }\n}\n\nfunction decodeArray<TParam extends AbiParameter>(\n  data: Hex,\n  {\n    param,\n    length,\n    position,\n  }: {\n    param: TParam\n    length: number | null\n    position: number\n  },\n) {\n  // If the length of the array is not known in advance (dynamic array),\n  // we will need to decode the offset of the array data.\n  if (!length) {\n    // Get the offset of the array data.\n    const offset = hexToNumber(slice(data, position, position + 32))\n    // Get the length of the array from the offset.\n    const length = hexToNumber(slice(data, offset, offset + 32))\n\n    let consumed = 0\n    let value: AbiParameterToPrimitiveType<TParam>[] = []\n    for (let i = 0; i < length; ++i) {\n      const decodedChild = decodeParam({\n        data: slice(data, offset + 32),\n        param,\n        position: consumed,\n      })\n      consumed += decodedChild.consumed\n      value.push(decodedChild.value)\n    }\n    return { value, consumed: 32 }\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Get the child type of the array.\n    const arrayComponents = getArrayComponents(param.type)\n    // If the child type is not known, the array is dynamic.\n    const dynamicChild = !arrayComponents?.[0]\n\n    let consumed = 0\n    let value: AbiParameterToPrimitiveType<TParam>[] = []\n    for (let i = 0; i < length; ++i) {\n      const offset = hexToNumber(slice(data, position, position + 32))\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param,\n        position: dynamicChild ? consumed : i * 32,\n      })\n      consumed += decodedChild.consumed\n      value.push(decodedChild.value)\n    }\n    return { value, consumed }\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of each element in the array is known,\n  // the array data is encoded contiguously after the array.\n  let consumed = 0\n  let value: AbiParameterToPrimitiveType<TParam>[] = []\n  for (let i = 0; i < length; ++i) {\n    const decodedChild = decodeParam({\n      data,\n      param,\n      position: position + consumed,\n    })\n    consumed += decodedChild.consumed\n    value.push(decodedChild.value)\n  }\n  return { value, consumed }\n}\n\nfunction decodeBool(value: Hex) {\n  return { consumed: 32, value: hexToBool(value) }\n}\n\nfunction decodeBytes<TParam extends AbiParameter>(\n  data: Hex,\n  { param, position }: { param: TParam; position: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // If we don't have a size, we're dealing with a dynamic-size array\n    // so we need to read the offset of the data part first.\n    const offset = hexToNumber(slice(data, position, position + 32))\n    const length = hexToNumber(slice(data, offset, offset + 32))\n    const value =\n      // If there is no length, we have zero data.\n      length === 0 ? '0x' : slice(data, offset + 32, offset + 32 + length)\n    return { consumed: 32, value }\n  }\n\n  const value = slice(data, position, position + parseInt(size))\n  return { consumed: 32, value }\n}\n\nfunction decodeNumber<TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n) {\n  const signed = param.type.startsWith('int')\n  const size = parseInt(param.type.split('int')[1] || '256')\n  return {\n    consumed: 32,\n    value:\n      size > 48\n        ? hexToBigInt(value, { signed })\n        : hexToNumber(value, { signed }),\n  }\n}\n\nfunction decodeString(data: Hex, { position }: { position: number }) {\n  const offset = hexToNumber(slice(data, position, position + 32))\n  const length = hexToNumber(slice(data, offset, offset + 32))\n  const value = hexToString(\n    trim(slice(data, offset + 32, offset + 32 + length)),\n  )\n  return { consumed: 32, value }\n}\n\nfunction decodeTuple<\n  TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(data: Hex, { param, position }: { param: TParam; position: number }) {\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  let value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    const offset = hexToNumber(slice(data, position, position + 32))\n    // Decode each component of the tuple, starting at the offset.\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param: component,\n        position: consumed,\n      })\n      consumed += decodedChild.consumed\n      value[hasUnnamedChild ? i : component?.name!] = decodedChild.value\n    }\n    return { consumed: 32, value }\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]\n    const decodedChild = decodeParam({\n      data,\n      param: component,\n      position: position + consumed,\n    })\n    consumed += decodedChild.consumed\n    value[hasUnnamedChild ? i : component?.name!] = decodedChild.value\n  }\n  return { consumed, value }\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true\n\n  return false\n}\n","import { AbiParameter } from 'abitype'\n\nimport { InvalidDefinitionTypeError } from '../../errors'\nimport { AbiItem } from '../../types'\n\nexport function formatAbiItem(\n  abiItem: AbiItem,\n  { includeName = false }: { includeName?: boolean } = {},\n) {\n  if (\n    abiItem.type !== 'function' &&\n    abiItem.type !== 'event' &&\n    abiItem.type !== 'error'\n  )\n    throw new InvalidDefinitionTypeError(abiItem.type)\n\n  return `${abiItem.name}(${getParams(abiItem.inputs, { includeName })})`\n}\n\nfunction getParams(\n  params: readonly AbiParameter[] | undefined,\n  { includeName }: { includeName: boolean },\n): string {\n  if (!params) return ''\n  return params\n    .map((param) => getParam(param, { includeName }))\n    .join(includeName ? ', ' : ',')\n}\n\nfunction getParam(\n  param: AbiParameter,\n  { includeName }: { includeName: boolean },\n): string {\n  if (param.type.startsWith('tuple')) {\n    return `(${getParams(\n      (param as unknown as { components: AbiParameter[] }).components,\n      { includeName },\n    )})${param.type.slice('tuple'.length)}`\n  }\n  return param.type + (includeName && param.name ? ` ${param.name}` : '')\n}\n","import { Abi } from 'abitype'\nimport { solidityError, solidityPanic } from '../../constants'\nimport {\n  AbiDecodingZeroDataError,\n  AbiErrorSignatureNotFoundError,\n} from '../../errors'\nimport { AbiItem, Hex } from '../../types'\nimport { slice } from '../data'\nimport { getFunctionSelector } from '../hash'\nimport { decodeAbiParameters } from './decodeAbiParameters'\nimport { formatAbiItem } from './formatAbiItem'\n\nexport type DecodeErrorResultParameters = { abi?: Abi; data: Hex }\n\nexport type DecodeErrorResultReturnType = {\n  abiItem: AbiItem\n  errorName: string\n  args?: readonly unknown[]\n}\n\nexport function decodeErrorResult({\n  abi,\n  data,\n}: DecodeErrorResultParameters): DecodeErrorResultReturnType {\n  const signature = slice(data, 0, 4)\n  if (signature === '0x') throw new AbiDecodingZeroDataError()\n\n  const abi_ = [...(abi || []), solidityError, solidityPanic]\n  const abiItem = abi_.find(\n    (x) =>\n      x.type === 'error' && signature === getFunctionSelector(formatAbiItem(x)),\n  )\n  if (!abiItem)\n    throw new AbiErrorSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeErrorResult',\n    })\n  return {\n    abiItem,\n    args: ('inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0\n      ? decodeAbiParameters(abiItem.inputs, slice(data, 4))\n      : undefined) as readonly unknown[] | undefined,\n    errorName: (abiItem as { name: string }).name,\n  }\n}\n","import { Abi, AbiParameter, Narrow } from 'abitype'\nimport { AbiEventSignatureNotFoundError } from '../../errors'\nimport {\n  EventDefinition,\n  ExtractEventArgsFromTopics,\n  ExtractEventNameFromAbi,\n  Hex,\n  LogTopic,\n} from '../../types'\nimport { getEventSelector } from '../hash'\nimport { decodeAbiParameters } from './decodeAbiParameters'\nimport { formatAbiItem } from './formatAbiItem'\n\nexport type DecodeEventLogParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TEventName extends string = string,\n  TTopics extends LogTopic[] = LogTopic[],\n  TData extends Hex | undefined = undefined,\n> = {\n  abi: Narrow<TAbi>\n  data?: TData\n  eventName?: ExtractEventNameFromAbi<TAbi, TEventName>\n  topics: [signature: Hex, ...args: TTopics]\n}\n\nexport type DecodeEventLogReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TEventName extends string = string,\n  TTopics extends LogTopic[] = LogTopic[],\n  TData extends Hex | undefined = undefined,\n> = {\n  eventName: TEventName\n} & ExtractEventArgsFromTopics<TAbi, TEventName, TTopics, TData>\n\nexport function decodeEventLog<\n  TAbi extends Abi | readonly unknown[],\n  TEventName extends string,\n  TTopics extends LogTopic[],\n  TData extends Hex | undefined = undefined,\n>({\n  abi,\n  data,\n  topics,\n}: DecodeEventLogParameters<\n  TAbi,\n  TEventName,\n  TTopics,\n  TData\n>): DecodeEventLogReturnType<TAbi, TEventName, TTopics, TData> {\n  const [signature, ...argTopics] = topics\n  const abiItem = (abi as Abi).find(\n    (x) => signature === getEventSelector(formatAbiItem(x) as EventDefinition),\n  )\n  if (!(abiItem && 'name' in abiItem))\n    throw new AbiEventSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeEventLog',\n    })\n\n  const { name, inputs } = abiItem\n  const isUnnamed = inputs?.some((x) => !('name' in x && x.name))\n\n  let args: any = isUnnamed ? [] : {}\n\n  // Decode topics (indexed args).\n  for (let i = 0; i < inputs.length; i++) {\n    const param = inputs[i]\n    const topic = argTopics[i]\n    if (topic === null) args[param.name || i] = null\n    if (!topic) continue\n    if (Array.isArray(topic)) {\n      args[param.name || i] = topic.map((t) => decodeTopic({ param, value: t }))\n    } else {\n      args[param.name || i] = decodeTopic({ param, value: topic })\n    }\n  }\n\n  // Decode data (non-indexed args).\n  if (data && data !== '0x') {\n    const params = inputs.filter((x) => !('indexed' in x && x.indexed))\n    const decodedData = decodeAbiParameters(params, data)\n    if (decodedData) {\n      if (isUnnamed) args = [...args, ...decodedData]\n      else {\n        for (let i = 0; i < params.length; i++) {\n          args[params[i].name!] = decodedData[i]\n        }\n      }\n    }\n  }\n\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined,\n  } as unknown as DecodeEventLogReturnType<TAbi, TEventName, TTopics, TData>\n}\n\nfunction decodeTopic({ param, value }: { param: AbiParameter; value: Hex }) {\n  if (\n    param.type === 'string' ||\n    param.type === 'bytes' ||\n    param.type === 'tuple' ||\n    param.type.match(/^(.*)\\[(\\d+)?\\]$/)\n  )\n    return value\n  const decodedArg = decodeAbiParameters([param], value) || []\n  return decodedArg[0]\n}\n","import { Abi } from 'abitype'\n\nimport { AbiFunctionSignatureNotFoundError } from '../../errors'\nimport { Hex } from '../../types'\nimport { slice } from '../data'\nimport { getFunctionSelector } from '../hash'\nimport { decodeAbiParameters } from './decodeAbiParameters'\nimport { formatAbiItem } from './formatAbiItem'\n\nexport type DecodeFunctionDataParameters = {\n  abi: Abi | readonly unknown[]\n  data: Hex\n}\n\nexport function decodeFunctionData({\n  abi,\n  data,\n}: DecodeFunctionDataParameters) {\n  const signature = slice(data, 0, 4)\n  const description = (abi as Abi).find(\n    (x) => signature === getFunctionSelector(formatAbiItem(x)),\n  )\n  if (!description)\n    throw new AbiFunctionSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeFunctionData',\n    })\n  return {\n    functionName: (description as { name: string }).name,\n    args: ('inputs' in description &&\n    description.inputs &&\n    description.inputs.length > 0\n      ? decodeAbiParameters(description.inputs, slice(data, 4))\n      : undefined) as readonly unknown[] | undefined,\n  }\n}\n","import type { Abi, AbiParameter, Address, Narrow } from 'abitype'\nimport type { ExtractArgsFromAbi, ExtractNameFromAbi } from '../../types'\nimport { isAddress } from '../address'\n\nexport type GetAbiItemParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TItemName extends string = string,\n> = {\n  abi: Narrow<TAbi>\n  name: ExtractNameFromAbi<TAbi, TItemName>\n} & Partial<ExtractArgsFromAbi<TAbi, TItemName>>\n\nexport type GetAbiItemReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TItemName extends string = string,\n> = Extract<\n  TAbi[number],\n  {\n    name: TItemName\n  }\n>\n\nexport function getAbiItem<\n  TAbi extends Abi | readonly unknown[],\n  TItemName extends string,\n  TReturnType = GetAbiItemReturnType<TAbi, TItemName>,\n>({\n  abi,\n  args = [],\n  name,\n}: GetAbiItemParameters<TAbi, TItemName>): TReturnType {\n  const abiItems = (abi as Abi).filter((x) => 'name' in x && x.name === name)\n\n  if (abiItems.length === 0) return undefined as unknown as TReturnType\n  if (abiItems.length === 1) return abiItems[0] as unknown as TReturnType\n\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return abiItem as unknown as TReturnType\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    const matched = (args as readonly unknown[]).every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter as AbiParameter)\n    })\n    if (matched) return abiItem as unknown as TReturnType\n  }\n  return abiItems[0] as unknown as TReturnType\n}\n\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address)\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n","import { Abi, Narrow } from 'abitype'\nimport {\n  AbiFunctionNotFoundError,\n  AbiFunctionOutputsNotFoundError,\n} from '../../errors'\nimport {\n  ExtractArgsFromAbi,\n  ExtractFunctionNameFromAbi,\n  ExtractResultFromAbi,\n  Hex,\n} from '../../types'\nimport { decodeAbiParameters } from './decodeAbiParameters'\nimport { getAbiItem, GetAbiItemParameters } from './getAbiItem'\n\nconst docsPath = '/docs/contract/decodeFunctionResult'\n\nexport type DecodeFunctionResultParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = string,\n> = {\n  abi: Narrow<TAbi>\n  functionName: ExtractFunctionNameFromAbi<TAbi, TFunctionName>\n  data: Hex\n} & Partial<ExtractArgsFromAbi<TAbi, TFunctionName>>\n\nexport type DecodeFunctionResultReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = string,\n> = ExtractResultFromAbi<TAbi, TFunctionName>\n\nexport function decodeFunctionResult<\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n>({\n  abi,\n  args,\n  functionName,\n  data,\n}: DecodeFunctionResultParameters<\n  TAbi,\n  TFunctionName\n>): DecodeFunctionResultReturnType<TAbi, TFunctionName> {\n  const description = getAbiItem({\n    abi,\n    args,\n    name: functionName,\n  } as GetAbiItemParameters)\n  if (!description)\n    throw new AbiFunctionNotFoundError(functionName, { docsPath })\n  if (!('outputs' in description))\n    throw new AbiFunctionOutputsNotFoundError(functionName, { docsPath })\n\n  const values = decodeAbiParameters(description.outputs, data)\n  if (values && values.length > 1) return values as any\n  if (values && values.length === 1) return values[0] as any\n  return undefined as any\n}\n","import { Abi, Narrow } from 'abitype'\n\nimport {\n  AbiConstructorNotFoundError,\n  AbiConstructorParamsNotFoundError,\n} from '../../errors'\nimport { ExtractConstructorArgsFromAbi, Hex } from '../../types'\nimport { concatHex } from '../data'\nimport { encodeAbiParameters } from './encodeAbiParameters'\n\nconst docsPath = '/docs/contract/encodeDeployData'\n\nexport type EncodeDeployDataParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n> = {\n  abi: Narrow<TAbi>\n  bytecode: Hex\n} & ExtractConstructorArgsFromAbi<TAbi>\n\nexport function encodeDeployData<TAbi extends Abi | readonly unknown[]>({\n  abi,\n  args,\n  bytecode,\n}: EncodeDeployDataParameters<TAbi>) {\n  if (!args || args.length === 0) return bytecode\n\n  const description = (abi as Abi).find(\n    (x) => 'type' in x && x.type === 'constructor',\n  )\n  if (!description) throw new AbiConstructorNotFoundError({ docsPath })\n  if (!('inputs' in description))\n    throw new AbiConstructorParamsNotFoundError({ docsPath })\n  if (!description.inputs || description.inputs.length === 0)\n    throw new AbiConstructorParamsNotFoundError({ docsPath })\n\n  const data = encodeAbiParameters(\n    description.inputs,\n    args as readonly unknown[],\n  )\n  return concatHex([bytecode, data!])\n}\n","import { Abi, Narrow } from 'abitype'\nimport {\n  AbiErrorInputsNotFoundError,\n  AbiErrorNotFoundError,\n} from '../../errors'\nimport {\n  ExtractErrorArgsFromAbi,\n  ExtractErrorNameFromAbi,\n  Hex,\n} from '../../types'\nimport { concatHex } from '../data'\nimport { getFunctionSelector } from '../hash'\nimport { encodeAbiParameters } from './encodeAbiParameters'\nimport { formatAbiItem } from './formatAbiItem'\nimport { getAbiItem, GetAbiItemParameters } from './getAbiItem'\n\nconst docsPath = '/docs/contract/encodeErrorResult'\n\nexport type EncodeErrorResultParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TErrorName extends string = string,\n> = {\n  abi: Narrow<TAbi>\n  errorName: ExtractErrorNameFromAbi<TAbi, TErrorName>\n} & ExtractErrorArgsFromAbi<TAbi, TErrorName>\n\nexport function encodeErrorResult<\n  TAbi extends Abi | readonly unknown[],\n  TErrorName extends string,\n>({ abi, errorName, args }: EncodeErrorResultParameters<TAbi, TErrorName>) {\n  const description = getAbiItem({\n    abi,\n    args,\n    name: errorName,\n  } as GetAbiItemParameters)\n  if (!description) throw new AbiErrorNotFoundError(errorName, { docsPath })\n  const definition = formatAbiItem(description)\n  const signature = getFunctionSelector(definition)\n\n  let data: Hex = '0x'\n  if (args && args.length > 0) {\n    if (!('inputs' in description && description.inputs))\n      throw new AbiErrorInputsNotFoundError(errorName, { docsPath })\n    data = encodeAbiParameters(description.inputs, args as readonly unknown[])\n  }\n  return concatHex([signature, data])\n}\n","import { Abi, AbiParameter, AbiParameterToPrimitiveType, Narrow } from 'abitype'\n\nimport {\n  AbiEventNotFoundError,\n  FilterTypeNotSupportedError,\n} from '../../errors'\nimport {\n  EventDefinition,\n  ExtractEventArgsFromAbi,\n  ExtractEventNameFromAbi,\n  Hex,\n} from '../../types'\nimport { toBytes } from '../encoding'\nimport { keccak256, getEventSelector } from '../hash'\nimport { encodeAbiParameters } from './encodeAbiParameters'\nimport { formatAbiItem } from './formatAbiItem'\nimport { getAbiItem, GetAbiItemParameters } from './getAbiItem'\n\nexport type EncodeEventTopicsParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TEventName extends string = string,\n> = {\n  abi: Narrow<TAbi>\n  args?: ExtractEventArgsFromAbi<TAbi, TEventName>\n  eventName: ExtractEventNameFromAbi<TAbi, TEventName>\n}\n\nexport function encodeEventTopics<\n  TAbi extends Abi | readonly unknown[],\n  TEventName extends string,\n>({ abi, eventName, args }: EncodeEventTopicsParameters<TAbi, TEventName>) {\n  const abiItem = getAbiItem({\n    abi,\n    args,\n    name: eventName,\n  } as GetAbiItemParameters)\n  if (!abiItem)\n    throw new AbiEventNotFoundError(eventName, {\n      docsPath: '/docs/contract/encodeEventTopics',\n    })\n  const definition = formatAbiItem(abiItem)\n  const signature = getEventSelector(definition as EventDefinition)\n\n  let topics: Hex[] = []\n  if (args && 'inputs' in abiItem) {\n    const args_ = Array.isArray(args)\n      ? args\n      : abiItem.inputs?.map((x: any) => (args as any)[x.name]) ?? []\n    topics =\n      abiItem.inputs\n        ?.filter((param) => 'indexed' in param && param.indexed)\n        .map((param, i) =>\n          Array.isArray(args_[i])\n            ? args_[i].map((_: any, j: number) =>\n                encodeArg({ param, value: args_[i][j] }),\n              )\n            : args_[i]\n            ? encodeArg({ param, value: args_[i] })\n            : null,\n        ) ?? []\n  }\n  return [signature, ...topics]\n}\n\nfunction encodeArg({\n  param,\n  value,\n}: { param: AbiParameter; value: AbiParameterToPrimitiveType<AbiParameter> }) {\n  if (param.type === 'string' || param.type === 'bytes')\n    return keccak256(toBytes(value as string))\n  if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n    throw new FilterTypeNotSupportedError(param.type)\n  return encodeAbiParameters([param], [value])\n}\n","import { Abi, Narrow } from 'abitype'\n\nimport { AbiFunctionNotFoundError } from '../../errors'\nimport { ExtractArgsFromAbi, ExtractFunctionNameFromAbi } from '../../types'\nimport { concatHex } from '../data'\nimport { getFunctionSelector } from '../hash'\nimport { encodeAbiParameters } from './encodeAbiParameters'\nimport { formatAbiItem } from './formatAbiItem'\nimport { getAbiItem, GetAbiItemParameters } from './getAbiItem'\n\nexport type EncodeFunctionDataParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = string,\n> = {\n  abi: Narrow<TAbi>\n  functionName: ExtractFunctionNameFromAbi<TAbi, TFunctionName>\n} & ExtractArgsFromAbi<TAbi, TFunctionName>\n\nexport function encodeFunctionData<\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n>({\n  abi,\n  args,\n  functionName,\n}: EncodeFunctionDataParameters<TAbi, TFunctionName>) {\n  const description = getAbiItem({\n    abi,\n    args,\n    name: functionName,\n  } as GetAbiItemParameters)\n  if (!description)\n    throw new AbiFunctionNotFoundError(functionName, {\n      docsPath: '/docs/contract/encodeFunctionData',\n    })\n  const definition = formatAbiItem(description)\n  const signature = getFunctionSelector(definition)\n  const data =\n    'inputs' in description && description.inputs\n      ? encodeAbiParameters(\n          description.inputs,\n          (args ?? []) as readonly unknown[],\n        )\n      : undefined\n  return concatHex([signature, data ?? '0x'])\n}\n","import { Abi, Narrow } from 'abitype'\nimport {\n  AbiFunctionNotFoundError,\n  AbiFunctionOutputsNotFoundError,\n} from '../../errors'\n\nimport { ExtractFunctionNameFromAbi, ExtractResultFromAbi } from '../../types'\nimport { encodeAbiParameters } from './encodeAbiParameters'\n\nconst docsPath = '/docs/contract/encodeFunctionResult'\n\nexport type EncodeFunctionResultParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = string,\n> = {\n  abi: Narrow<TAbi>\n  functionName: ExtractFunctionNameFromAbi<TAbi, TFunctionName>\n  result?: ExtractResultFromAbi<TAbi, TFunctionName>\n}\n\nexport function encodeFunctionResult<\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n>({\n  abi,\n  functionName,\n  result,\n}: EncodeFunctionResultParameters<TAbi, TFunctionName>) {\n  const description = (abi as Abi).find(\n    (x) => 'name' in x && x.name === functionName,\n  )\n  if (!description)\n    throw new AbiFunctionNotFoundError(functionName, { docsPath })\n  if (!('outputs' in description))\n    throw new AbiFunctionOutputsNotFoundError(functionName, { docsPath })\n\n  let values = Array.isArray(result) ? result : [result]\n  if (description.outputs.length === 0 && !values[0]) values = []\n\n  return encodeAbiParameters(description.outputs, values)\n}\n","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n","import {\n  AbiParameterToPrimitiveType,\n  AbiType,\n  Narrow,\n  SolidityAddress,\n  SolidityArrayWithoutTuple,\n  SolidityBool,\n  SolidityBytes,\n  SolidityInt,\n  SolidityString,\n} from 'abitype'\nimport {\n  AbiEncodingLengthMismatchError,\n  BytesSizeMismatchError,\n  InvalidAddressError,\n  UnsupportedPackedAbiType,\n} from '../../errors'\nimport { Address, Hex } from '../../types'\nimport { isAddress } from '../address'\nimport { concat, pad } from '../data'\nimport { boolToHex, numberToHex, stringToHex } from '../encoding'\nimport { arrayRegex, bytesRegex, integerRegex } from '../regex'\n\ntype PackedAbiType =\n  | SolidityAddress\n  | SolidityBool\n  | SolidityBytes\n  | SolidityInt\n  | SolidityString\n  | SolidityArrayWithoutTuple\n\ntype EncodePackedValues<TPackedAbiTypes extends PackedAbiType[] | unknown[],> =\n  {\n    [K in keyof TPackedAbiTypes]: TPackedAbiTypes[K] extends AbiType\n      ? AbiParameterToPrimitiveType<{ type: TPackedAbiTypes[K] }>\n      : unknown\n  }\n\nexport function encodePacked<\n  TPackedAbiTypes extends PackedAbiType[] | unknown[],\n>(\n  types: Narrow<TPackedAbiTypes>,\n  values: EncodePackedValues<TPackedAbiTypes>,\n): Hex {\n  if (types.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: types.length as number,\n      givenLength: values.length as number,\n    })\n\n  let data: Hex[] = []\n  for (let i = 0; i < types.length; i++) {\n    const type = types[i]\n    const value = values[i]\n    data.push(encode(type, value))\n  }\n  return concat(data)\n}\n\nfunction encode<TPackedAbiType extends PackedAbiType | unknown>(\n  type: TPackedAbiType,\n  value: EncodePackedValues<[TPackedAbiType]>[0],\n  isArray: boolean = false,\n): Hex {\n  if (type === 'address') {\n    let address = value as Address\n    if (!isAddress(address)) throw new InvalidAddressError({ address })\n    return pad(address.toLowerCase() as Hex, {\n      size: isArray ? 32 : null,\n    }) as Address\n  }\n  if (type === 'string') return stringToHex(value as string)\n  if (type === 'bytes') return value as Hex\n  if (type === 'bool')\n    return pad(boolToHex(value as boolean), { size: isArray ? 32 : 1 })\n\n  const intMatch = (type as string).match(integerRegex)\n  if (intMatch) {\n    const [_type, baseType, bits = '256'] = intMatch\n    const size = parseInt(bits) / 8\n    return numberToHex(value as number, {\n      size: isArray ? 32 : size,\n      signed: baseType === 'int',\n    })\n  }\n\n  const bytesMatch = (type as string).match(bytesRegex)\n  if (bytesMatch) {\n    const [_type, size] = bytesMatch\n    if (parseInt(size) !== ((value as Hex).length - 2) / 2)\n      throw new BytesSizeMismatchError({\n        expectedSize: parseInt(size),\n        givenSize: ((value as Hex).length - 2) / 2,\n      })\n    return pad(value as Hex, { dir: 'right', size: isArray ? 32 : null }) as Hex\n  }\n\n  const arrayMatch = (type as string).match(arrayRegex)\n  if (arrayMatch && Array.isArray(value)) {\n    const [_type, childType] = arrayMatch\n    let data: Hex[] = []\n    for (let i = 0; i < value.length; i++) {\n      data.push(encode(childType, value[i], true))\n    }\n    return concat(data)\n  }\n\n  throw new UnsupportedPackedAbiType(type)\n}\n","import { AbiParameter } from 'abitype'\nimport { AbiItem } from '../../types'\nimport { stringify } from '../../utils'\n\nexport function formatAbiItemWithArgs({\n  abiItem,\n  args,\n  includeFunctionName = true,\n  includeName = false,\n}: {\n  abiItem: AbiItem\n  args: readonly unknown[]\n  includeFunctionName?: boolean\n  includeName?: boolean\n}) {\n  if (!('name' in abiItem)) return\n  if (!('inputs' in abiItem)) return\n  if (!abiItem.inputs) return\n  return `${includeFunctionName ? abiItem.name : ''}(${abiItem.inputs\n    .map(\n      (input: AbiParameter, i: number) =>\n        `${includeName && input.name ? `${input.name}: ` : ''}${\n          typeof args[i] === 'object' ? stringify(args[i]) : args[i]\n        }`,\n    )\n    .join(', ')})`\n}\n","import { InvalidAddressError } from '../errors'\nimport { Address } from '../types'\nimport { Account, LocalAccount } from '../types/account'\nimport { isAddress } from './address'\n\nexport function getAccount(\n  account: Address | Omit<LocalAccount, 'type'>,\n): Account {\n  if (typeof account === 'string') {\n    if (!isAddress(account)) throw new InvalidAddressError({ address: account })\n    return { address: account, type: 'json-rpc' }\n  }\n\n  if (!isAddress(account.address))\n    throw new InvalidAddressError({ address: account.address })\n  return {\n    ...account,\n    type: 'local',\n  }\n}\n","export const promiseCache = new Map()\nexport const responseCache = new Map()\n\nexport function getCache<TData>(cacheKey: string) {\n  const buildCache = <TData>(cacheKey: string, cache: Map<string, TData>) => ({\n    clear: () => cache.delete(cacheKey),\n    get: () => cache.get(cacheKey),\n    set: (data: TData) => cache.set(cacheKey, data),\n  })\n\n  const promise = buildCache<Promise<TData>>(cacheKey, promiseCache)\n  const response = buildCache<{ created: Date; data: TData }>(\n    cacheKey,\n    responseCache,\n  )\n\n  return {\n    clear: () => {\n      promise.clear()\n      response.clear()\n    },\n    promise,\n    response,\n  }\n}\n\nexport type WithCacheParameters = {\n  /** The key to cache the data against. */\n  cacheKey: string\n  /** The maximum age (in ms) of the cached value. Default: Infinity (no expiry) */\n  maxAge?: number\n}\n\n/**\n * @description Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n */\nexport async function withCache<TData>(\n  fn: () => Promise<TData>,\n  { cacheKey, maxAge = Infinity }: WithCacheParameters,\n) {\n  const cache = getCache<TData>(cacheKey)\n\n  // If a response exists in the cache, and it's not expired, return it\n  // and do not invoke the promise.\n  // If the max age is 0, the cache is disabled.\n  const response = cache.response.get()\n  if (response && maxAge > 0) {\n    const age = new Date().getTime() - response.created.getTime()\n    if (age < maxAge) return response.data\n  }\n\n  let promise = cache.promise.get()\n  if (!promise) {\n    promise = fn()\n\n    // Store the promise in the cache so that subsequent invocations\n    // will wait for the same promise to resolve (deduping).\n    cache.promise.set(promise)\n  }\n\n  const data = await promise\n\n  // Clear the promise cache so that subsequent invocations will\n  // invoke the promise again.\n  cache.promise.clear()\n\n  // Store the response in the cache so that subsequent invocations\n  // will return the same response.\n  cache.response.set({ created: new Date(), data })\n\n  return data\n}\n","export async function wait(time: number) {\n  return new Promise((res) => setTimeout(res, time))\n}\n","import { wait } from '../wait'\n\nexport function withRetry<TData>(\n  fn: () => Promise<TData>,\n  {\n    delay: delay_ = 100,\n    retryCount = 2,\n    shouldRetry = () => true,\n  }: {\n    // The delay (in ms) between retries.\n    delay?: ((config: { count: number; error: Error }) => number) | number\n    // The max number of times to retry.\n    retryCount?: number\n    // Whether or not to retry when an error is thrown.\n    shouldRetry?: ({\n      count,\n      error,\n    }: {\n      count: number\n      error: Error\n    }) => Promise<boolean> | boolean\n  } = {},\n) {\n  return new Promise<TData>((resolve, reject) => {\n    const attemptRetry = async ({ count = 0 } = {}) => {\n      const retry = async ({ error }: { error: Error }) => {\n        const delay =\n          typeof delay_ === 'function' ? delay_({ count, error }) : delay_\n        if (delay) await wait(delay)\n        attemptRetry({ count: count + 1 })\n      }\n\n      try {\n        const data = await fn()\n        resolve(data)\n      } catch (err) {\n        if (\n          count < retryCount &&\n          (await shouldRetry({ count, error: err as Error }))\n        )\n          return retry({ error: err as Error })\n        reject(err)\n      }\n    }\n    attemptRetry()\n  })\n}\n","export function withTimeout<TData>(\n  fn: ({ signal }: { signal?: AbortController['signal'] }) => Promise<TData>,\n  {\n    errorInstance,\n    timeout,\n    signal,\n  }: {\n    // The error instance to throw when the timeout is reached.\n    errorInstance: Error\n    // The timeout (in ms).\n    timeout: number\n    // Whether or not the timeout should use an abort signal.\n    signal?: boolean\n  },\n): Promise<TData> {\n  return new Promise((resolve, reject) => {\n    ;(async () => {\n      let timeoutId!: NodeJS.Timeout\n      try {\n        const controller = new AbortController()\n        if (timeout > 0) {\n          timeoutId = setTimeout(() => {\n            if (signal) {\n              controller.abort()\n            } else {\n              reject(errorInstance)\n            }\n          }, timeout)\n        }\n        resolve(await fn({ signal: controller?.signal }))\n      } catch (err) {\n        if ((err as Error).name === 'AbortError') reject(errorInstance)\n        reject(err)\n      } finally {\n        clearTimeout(timeoutId)\n      }\n    })()\n  })\n}\n","import {\n  BaseError,\n  HttpRequestError,\n  InternalRpcError,\n  InvalidInputRpcError,\n  InvalidParamsRpcError,\n  InvalidRequestRpcError,\n  JsonRpcVersionUnsupportedError,\n  LimitExceededRpcError,\n  MethodNotFoundRpcError,\n  MethodNotSupportedRpcError,\n  ParseRpcError,\n  ResourceNotFoundRpcError,\n  ResourceUnavailableRpcError,\n  RpcError,\n  SwitchChainError,\n  TransactionRejectedRpcError,\n  UnknownRpcError,\n  UserRejectedRequestError,\n} from '../errors'\nimport { withRetry } from './promise'\n\nexport const isDeterministicError = (error: Error) => {\n  if ('code' in error) return error.code !== -32603 && error.code !== -32005\n  if (error instanceof HttpRequestError && error.status)\n    return (\n      error.status !== 408 &&\n      error.status !== 413 &&\n      error.status !== 429 &&\n      error.status !== 500 &&\n      error.status !== 502 &&\n      error.status !== 503 &&\n      error.status !== 504\n    )\n  return false\n}\n\nexport function buildRequest<TRequest extends (args: any) => Promise<any>>(\n  request: TRequest,\n  {\n    retryDelay = 150,\n    retryCount = 3,\n  }: {\n    // The base delay (in ms) between retries.\n    retryDelay?: number\n    // The max number of times to retry.\n    retryCount?: number\n  } = {},\n) {\n  return (async (args: any) =>\n    withRetry(\n      async () => {\n        try {\n          return await request(args)\n        } catch (err_) {\n          const err = err_ as unknown as RpcError\n          if (err.code === -32700) throw new ParseRpcError(err)\n          if (err.code === -32600) throw new InvalidRequestRpcError(err)\n          if (err.code === -32601) throw new MethodNotFoundRpcError(err)\n          if (err.code === -32602) throw new InvalidParamsRpcError(err)\n          if (err.code === -32603) throw new InternalRpcError(err)\n          if (err.code === -32000) throw new InvalidInputRpcError(err)\n          if (err.code === -32001) throw new ResourceNotFoundRpcError(err)\n          if (err.code === -32002) throw new ResourceUnavailableRpcError(err)\n          if (err.code === -32003) throw new TransactionRejectedRpcError(err)\n          if (err.code === -32004) throw new MethodNotSupportedRpcError(err)\n          if (err.code === -32005) throw new LimitExceededRpcError(err)\n          if (err.code === -32006) throw new JsonRpcVersionUnsupportedError(err)\n          if (err.code === 4001) throw new UserRejectedRequestError(err)\n          if (err.code === 4902) throw new SwitchChainError(err)\n          if (err_ instanceof BaseError) throw err_\n          throw new UnknownRpcError(err as Error)\n        }\n      },\n      {\n        delay: ({ count, error }) => {\n          // If we find a Retry-After header, let's retry after the given time.\n          if (error && error instanceof HttpRequestError) {\n            const retryAfter = error?.headers?.get('Retry-After')\n            if (retryAfter?.match(/\\d/)) return parseInt(retryAfter) * 1000\n          }\n\n          // Otherwise, let's retry with an exponential backoff.\n          return ~~(1 << count) * retryDelay\n        },\n        retryCount,\n        shouldRetry: ({ error }) => !isDeterministicError(error),\n      },\n    )) as TRequest\n}\n","import { Chain, Formatters } from '../types'\n\nexport function defineChain<\n  TFormatters extends Formatters = Formatters,\n  TChain extends Chain<TFormatters> = Chain<TFormatters>,\n>(chain: TChain) {\n  return chain\n}\n","import type { Chain, Formatter, OptionalNullable } from '../../types'\n\nexport type ExtractFormatter<\n  TChain extends Chain,\n  TKey extends keyof NonNullable<TChain['formatters']>,\n  TFallbackFormatter extends Formatter = Formatter,\n> = NonNullable<TChain['formatters']>[TKey] extends NonNullable<unknown>\n  ? NonNullable<TChain['formatters']>[TKey]\n  : TFallbackFormatter\n\nexport type FormatOptions<TSource, TTarget> = {\n  formatter: Formatter<TSource, TTarget>\n}\n\n/**\n * Creates a type that is the result of applying `TFormatter` to `TSource`.\n *\n * @example\n * Formatted<() => { a: undefined, b: bigint }, { a: bigint }>\n * => { a: undefined, b: bigint }\n *\n * @example\n * Formatted<() => {}, { a: bigint }>\n * => { a: bigint }\n *\n * @example\n * Formatted<() => { a: bigint | undefined, b: bigint }, { a: bigint, b: bigint }, true>\n * => { a?: bigint | undefined, b: bigint }\n */\nexport type Formatted<\n  TFormatter,\n  TFallback,\n  TAllowOptional = false,\n  TUseParameters = false,\n> = TFormatter extends Formatter\n  ? // If Formatter attributes exist, attach them; otherwise attach the Target type (e.g. Block).\n    ReturnType<TFormatter> extends Record<string, never>\n    ? TFallback\n    : TAllowOptional extends true\n    ? OptionalNullable<\n        TUseParameters extends true\n          ? Parameters<TFormatter>[0]\n          : ReturnType<TFormatter>\n      >\n    : TUseParameters extends true\n    ? Parameters<TFormatter>[0]\n    : ReturnType<TFormatter>\n  : never\n\n/**\n * @description Formats a data object using the given replacer and an optional formatter.\n */\nexport function format<\n  TFormatter,\n  TSource extends Record<string, any>,\n  TTarget,\n>(data: TSource, { formatter }: FormatOptions<TSource, TTarget>) {\n  return formatter(data) as Formatted<TFormatter, TTarget>\n}\n\nexport function defineFormatter<\n  TSource extends Record<string, unknown>,\n  TFormatted,\n>({\n  format,\n}: {\n  format: (data: TSource) => TFormatted\n}) {\n  return <\n      TFormat extends Formatter<\n        TSource,\n        Partial<TFormatted> & { [key: string]: unknown }\n      >,\n      TExclude extends (keyof TSource)[] = [],\n    >({\n      exclude,\n      format: formatOverride,\n    }: {\n      exclude?: TExclude\n      format?: TFormat\n    }) =>\n    (data: TSource & { [key: string]: unknown }) => {\n      const formatted = format(data)\n      if (exclude) {\n        for (const key of exclude) {\n          delete (formatted as any)[key]\n        }\n      }\n      return {\n        ...formatted,\n        ...formatOverride?.(data),\n      } as TFormatted &\n        ReturnType<TFormat> & {\n          [K in TExclude[number]]: never\n        }\n    }\n}\n","import type {\n  Chain,\n  Formatter,\n  Formatters,\n  RpcTransaction,\n  Transaction,\n} from '../../types'\nimport { hexToNumber } from '../encoding'\nimport { defineFormatter, ExtractFormatter, Formatted } from './format'\n\nexport type TransactionFormatter<TChain extends Chain = Chain> =\n  ExtractFormatter<\n    TChain,\n    'transaction',\n    NonNullable<Formatters['transaction']>\n  >\n\nexport type FormattedTransaction<\n  TFormatter extends Formatter | undefined = Formatter,\n> = Formatted<TFormatter, Transaction>\n\nexport const transactionType = {\n  '0x0': 'legacy',\n  '0x1': 'eip2930',\n  '0x2': 'eip1559',\n} as const\n\nexport function formatTransaction(transaction: Partial<RpcTransaction>) {\n  const transaction_ = {\n    ...transaction,\n    blockNumber: transaction.blockNumber\n      ? BigInt(transaction.blockNumber)\n      : null,\n    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,\n    gas: transaction.gas ? BigInt(transaction.gas) : undefined,\n    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,\n    maxFeePerGas: transaction.maxFeePerGas\n      ? BigInt(transaction.maxFeePerGas)\n      : undefined,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n      ? BigInt(transaction.maxPriorityFeePerGas)\n      : undefined,\n    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,\n    transactionIndex: transaction.transactionIndex\n      ? Number(transaction.transactionIndex)\n      : null,\n    type: transaction.type ? transactionType[transaction.type] : undefined,\n    value: transaction.value ? BigInt(transaction.value) : undefined,\n    v: transaction.v ? BigInt(transaction.v) : undefined,\n  }\n\n  if (transaction_.type === 'legacy') {\n    delete transaction_['accessList']\n    delete transaction_['maxFeePerGas']\n    delete transaction_['maxPriorityFeePerGas']\n  }\n  if (transaction_.type === 'eip2930') {\n    delete transaction_['maxFeePerGas']\n    delete transaction_['maxPriorityFeePerGas']\n  }\n  return transaction_ as Transaction\n}\n\nexport const defineTransaction = defineFormatter({ format: formatTransaction })\n","import type { Chain, Block, Formatter, Formatters, RpcBlock } from '../../types'\nimport { defineFormatter, ExtractFormatter, Formatted } from './format'\nimport { formatTransaction } from './transaction'\n\nexport type BlockFormatter<TChain extends Chain = Chain> = ExtractFormatter<\n  TChain,\n  'block',\n  NonNullable<Formatters['block']>\n>\n\nexport type FormattedBlock<\n  TFormatter extends Formatter | undefined = Formatter,\n> = Formatted<TFormatter, Block>\n\nexport function formatBlock(block: Partial<RpcBlock>) {\n  // TODO: Properly format transactions with a custom formatter\n  const transactions = block.transactions?.map((transaction) => {\n    if (typeof transaction === 'string') return transaction\n    return formatTransaction(transaction)\n  })\n  return {\n    ...block,\n    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,\n    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,\n    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,\n    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,\n    number: block.number ? BigInt(block.number) : null,\n    size: block.size ? BigInt(block.size) : undefined,\n    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,\n    transactions,\n    totalDifficulty: block.totalDifficulty\n      ? BigInt(block.totalDifficulty)\n      : null,\n  } as Block\n}\n\nexport const defineBlock = defineFormatter({ format: formatBlock })\n","import { Formatter } from '../../types'\n\n/**\n * @description Picks out the keys from `value` that exist in the formatter.\n */\nexport function extract(\n  value: Record<string, unknown>,\n  { formatter }: { formatter?: Formatter },\n) {\n  if (!formatter) return {}\n  const keys = Object.keys(formatter({}))\n  return keys.reduce((data, key) => {\n    if (value?.hasOwnProperty(key)) {\n      ;(data as any)[key] = value[key]\n    }\n    return data\n  }, {})\n}\n","import type { FeeHistory, RpcFeeHistory } from '../../types'\n\nexport function formatFeeHistory(feeHistory: RpcFeeHistory): FeeHistory {\n  return {\n    baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),\n    gasUsedRatio: feeHistory.gasUsedRatio,\n    oldestBlock: BigInt(feeHistory.oldestBlock),\n    reward: feeHistory.reward?.map((reward) =>\n      reward.map((value) => BigInt(value)),\n    ),\n  }\n}\n","import type { Log, RpcLog } from '../../types'\n\nexport function formatLog(\n  log: Partial<RpcLog>,\n  { args, eventName }: { args?: unknown; eventName?: string } = {},\n) {\n  return {\n    ...log,\n    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,\n    logIndex: log.logIndex ? BigInt(log.logIndex) : null,\n    transactionIndex: log.transactionIndex\n      ? BigInt(log.transactionIndex)\n      : null,\n    ...(eventName ? { args, eventName } : {}),\n  } as Log\n}\n","import type {\n  Chain,\n  Formatter,\n  Formatters,\n  RpcTransactionReceipt,\n  TransactionReceipt,\n} from '../../types'\nimport { hexToNumber } from '../encoding'\nimport { defineFormatter, ExtractFormatter, Formatted } from './format'\nimport { formatLog } from './log'\nimport { transactionType } from './transaction'\n\nexport type TransactionReceiptFormatter<TChain extends Chain = Chain> =\n  ExtractFormatter<\n    TChain,\n    'transactionReceipt',\n    NonNullable<Formatters['transactionReceipt']>\n  >\n\nexport type FormattedTransactionReceipt<\n  TFormatter extends Formatter | undefined = Formatter,\n> = Formatted<TFormatter, TransactionReceipt>\n\nconst statuses = {\n  '0x0': 'reverted',\n  '0x1': 'success',\n} as const\n\nexport function formatTransactionReceipt(\n  transactionReceipt: Partial<RpcTransactionReceipt>,\n) {\n  return {\n    ...transactionReceipt,\n    blockNumber: transactionReceipt.blockNumber\n      ? BigInt(transactionReceipt.blockNumber)\n      : null,\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\n      ? BigInt(transactionReceipt.cumulativeGasUsed)\n      : null,\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice\n      ? BigInt(transactionReceipt.effectiveGasPrice)\n      : null,\n    gasUsed: transactionReceipt.gasUsed\n      ? BigInt(transactionReceipt.gasUsed)\n      : null,\n    logs: transactionReceipt.logs\n      ? transactionReceipt.logs.map((log) => formatLog(log))\n      : null,\n    transactionIndex: transactionReceipt.transactionIndex\n      ? hexToNumber(transactionReceipt.transactionIndex)\n      : null,\n    status: transactionReceipt.status\n      ? statuses[transactionReceipt.status]\n      : null,\n    type: transactionReceipt.type\n      ? transactionType[transactionReceipt.type]\n      : null,\n  } as TransactionReceipt\n}\n\nexport const defineTransactionReceipt = defineFormatter({\n  format: formatTransactionReceipt,\n})\n","import type {\n  Chain,\n  Formatter,\n  Formatters,\n  RpcTransactionRequest,\n  TransactionRequest,\n} from '../../types'\nimport { defineFormatter, ExtractFormatter, Formatted } from './format'\nimport { numberToHex } from '../encoding'\n\nexport type TransactionRequestFormatter<TChain extends Chain = Chain> =\n  ExtractFormatter<\n    TChain,\n    'transactionRequest',\n    NonNullable<Formatters['transactionRequest']>\n  >\n\nexport type FormattedTransactionRequest<\n  TFormatter extends Formatter | undefined = Formatter,\n> = Formatted<TFormatter, RpcTransactionRequest>\n\nexport function formatTransactionRequest(\n  transactionRequest: Partial<TransactionRequest>,\n) {\n  return {\n    ...transactionRequest,\n    gas:\n      typeof transactionRequest.gas !== 'undefined'\n        ? numberToHex(transactionRequest.gas)\n        : undefined,\n    gasPrice:\n      typeof transactionRequest.gasPrice !== 'undefined'\n        ? numberToHex(transactionRequest.gasPrice)\n        : undefined,\n    maxFeePerGas:\n      typeof transactionRequest.maxFeePerGas !== 'undefined'\n        ? numberToHex(transactionRequest.maxFeePerGas)\n        : undefined,\n    maxPriorityFeePerGas:\n      typeof transactionRequest.maxPriorityFeePerGas !== 'undefined'\n        ? numberToHex(transactionRequest.maxPriorityFeePerGas)\n        : undefined,\n    nonce:\n      typeof transactionRequest.nonce !== 'undefined'\n        ? numberToHex(transactionRequest.nonce)\n        : undefined,\n    value:\n      typeof transactionRequest.value !== 'undefined'\n        ? numberToHex(transactionRequest.value)\n        : undefined,\n  } as RpcTransactionRequest\n}\n\nexport const defineTransactionRequest = defineFormatter({\n  format: formatTransactionRequest,\n})\n","import { SendTransactionParameters } from '../../actions'\nimport {\n  BaseError,\n  ExecutionRevertedError,\n  FeeCapTooHighError,\n  FeeCapTooLowError,\n  InsufficientFundsError,\n  IntrinsicGasTooHighError,\n  IntrinsicGasTooLowError,\n  InvalidInputRpcError,\n  NonceMaxValueError,\n  NonceTooHighError,\n  NonceTooLowError,\n  RpcError,\n  TipAboveFeeCapError,\n  TransactionRejectedRpcError,\n  TransactionTypeNotSupportedError,\n  UnknownNodeError,\n} from '../../errors'\n\nexport function containsNodeError(err: BaseError) {\n  return (\n    err instanceof TransactionRejectedRpcError ||\n    err instanceof InvalidInputRpcError ||\n    (err instanceof RpcError && err.code === ExecutionRevertedError.code)\n  )\n}\n\nexport function getNodeError(\n  err: BaseError,\n  args: Partial<SendTransactionParameters<any>>,\n) {\n  const message = err.details.toLowerCase()\n  if (FeeCapTooHighError.nodeMessage.test(message))\n    return new FeeCapTooHighError({\n      cause: err,\n      maxFeePerGas: args?.maxFeePerGas,\n    })\n  else if (FeeCapTooLowError.nodeMessage.test(message))\n    return new FeeCapTooLowError({\n      cause: err,\n      maxFeePerGas: args?.maxFeePerGas,\n    })\n  else if (NonceTooHighError.nodeMessage.test(message))\n    return new NonceTooHighError({ cause: err, nonce: args?.nonce })\n  else if (NonceTooLowError.nodeMessage.test(message))\n    return new NonceTooLowError({ cause: err, nonce: args?.nonce })\n  else if (NonceMaxValueError.nodeMessage.test(message))\n    return new NonceMaxValueError({ cause: err, nonce: args?.nonce })\n  else if (InsufficientFundsError.nodeMessage.test(message))\n    return new InsufficientFundsError({ cause: err })\n  else if (IntrinsicGasTooHighError.nodeMessage.test(message))\n    return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas })\n  else if (IntrinsicGasTooLowError.nodeMessage.test(message))\n    return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas })\n  else if (TransactionTypeNotSupportedError.nodeMessage.test(message))\n    return new TransactionTypeNotSupportedError({ cause: err })\n  else if (TipAboveFeeCapError.nodeMessage.test(message))\n    return new TipAboveFeeCapError({\n      cause: err,\n      maxFeePerGas: args?.maxFeePerGas,\n      maxPriorityFeePerGas: args?.maxPriorityFeePerGas,\n    })\n  else if (\n    message.match(ExecutionRevertedError.nodeMessage) ||\n    ('code' in (err.cause as BaseError) &&\n      (err.cause as { code: number })?.code === ExecutionRevertedError.code)\n  )\n    return new ExecutionRevertedError({\n      cause: err,\n      message: (err.cause as BaseError).details,\n    })\n  return new UnknownNodeError({\n    cause: (err.cause as BaseError).cause as BaseError,\n  })\n}\n","import { CallParameters } from '../../actions'\nimport { BaseError, CallExecutionError } from '../../errors'\nimport { Chain } from '../../types'\nimport { containsNodeError, getNodeError } from './getNodeError'\n\nexport function getCallError(\n  err: BaseError,\n  {\n    docsPath,\n    ...args\n  }: CallParameters & {\n    chain?: Chain\n    docsPath?: string\n  },\n) {\n  let cause = err\n  if (containsNodeError(err)) cause = getNodeError(err, args)\n  return new CallExecutionError(cause, {\n    docsPath,\n    ...args,\n  })\n}\n","import { Abi } from 'abitype'\nimport {\n  AbiDecodingZeroDataError,\n  BaseError,\n  ContractFunctionExecutionError,\n  EstimateGasExecutionError,\n  RawContractError,\n} from '../../errors'\nimport {\n  CallExecutionError,\n  ContractFunctionRevertedError,\n  ContractFunctionZeroDataError,\n} from '../../errors/contract'\nimport { Address } from '../../types'\n\nconst EXECUTION_REVERTED_ERROR_CODE = 3\n\nexport function getContractError(\n  err: BaseError,\n  {\n    abi,\n    address,\n    args,\n    docsPath,\n    functionName,\n    sender,\n  }: {\n    abi: Abi\n    args: any\n    address?: Address\n    docsPath?: string\n    functionName: string\n    sender?: Address\n  },\n) {\n  const { code, data, message } = (\n    err instanceof RawContractError\n      ? err\n      : err instanceof CallExecutionError ||\n        err instanceof EstimateGasExecutionError\n      ? ((err.cause as BaseError)?.cause as BaseError)?.cause || {}\n      : err.cause || {}\n  ) as RawContractError\n\n  let cause = err\n  if (err instanceof AbiDecodingZeroDataError) {\n    cause = new ContractFunctionZeroDataError({ functionName })\n  } else if (code === EXECUTION_REVERTED_ERROR_CODE && (data || message)) {\n    cause = new ContractFunctionRevertedError({\n      abi,\n      data,\n      functionName,\n      message,\n    })\n  }\n\n  return new ContractFunctionExecutionError(cause, {\n    abi,\n    args,\n    contractAddress: address,\n    docsPath,\n    functionName,\n    sender,\n  })\n}\n","import { EstimateGasParameters } from '../../actions'\nimport { BaseError, EstimateGasExecutionError } from '../../errors'\nimport { Chain } from '../../types'\nimport { containsNodeError, getNodeError } from './getNodeError'\n\nexport function getEstimateGasError(\n  err: BaseError,\n  {\n    docsPath,\n    ...args\n  }: EstimateGasParameters & {\n    chain?: Chain\n    docsPath?: string\n  },\n) {\n  let cause = err\n  if (containsNodeError(err)) cause = getNodeError(err, args)\n  return new EstimateGasExecutionError(cause, {\n    docsPath,\n    ...args,\n  })\n}\n","import { BaseError, TransactionExecutionError } from '../../errors'\nimport { SendTransactionParameters } from '../../wallet'\nimport { containsNodeError, getNodeError } from './getNodeError'\n\nexport function getTransactionError(\n  err: BaseError,\n  {\n    docsPath,\n    ...args\n  }: SendTransactionParameters & {\n    docsPath?: string\n  },\n) {\n  let cause = err\n  if (containsNodeError(err)) cause = getNodeError(err, args)\n  return new TransactionExecutionError(cause, {\n    docsPath,\n    ...args,\n  })\n}\n","import WebSocket from 'isomorphic-ws'\nimport {\n  HttpRequestError,\n  RpcError,\n  TimeoutError,\n  WebSocketRequestError,\n} from '../errors'\nimport { withTimeout } from './promise/withTimeout'\nimport { stringify } from './stringify'\n\nlet id = 0\n\ntype SuccessResult<T> = {\n  method?: never\n  result: T\n  error?: never\n}\ntype ErrorResult<T> = {\n  method?: never\n  result?: never\n  error: T\n}\ntype Subscription<TResult, TError> = {\n  method: 'eth_subscription'\n  error?: never\n  result?: never\n  params: {\n    subscription: string\n  } & (\n    | {\n        result: TResult\n        error?: never\n      }\n    | {\n        result?: never\n        error: TError\n      }\n  )\n}\n\ntype RpcRequest = { method: string; params?: any[] }\n\nexport type RpcResponse<TResult = any, TError = any> = {\n  jsonrpc: `${number}`\n  id: number\n} & (\n  | SuccessResult<TResult>\n  | ErrorResult<TError>\n  | Subscription<TResult, TError>\n)\n\n///////////////////////////////////////////////////\n// HTTP\n\nexport type HttpOptions = {\n  // The RPC request body.\n  body: RpcRequest\n  // Request configuration to pass to `fetch`.\n  fetchOptions?: Omit<RequestInit, 'body'>\n  // The timeout (in ms) for the request.\n  timeout?: number\n}\n\nasync function http(\n  url: string,\n  { body, fetchOptions = {}, timeout = 10_000 }: HttpOptions,\n) {\n  const { headers, method, signal: signal_ } = fetchOptions\n  try {\n    const response = await withTimeout(\n      async ({ signal }) => {\n        const response = await fetch(url, {\n          ...fetchOptions,\n          body: stringify({ jsonrpc: '2.0', id: id++, ...body }),\n          headers: {\n            ...headers,\n            'Content-Type': 'application/json',\n          },\n          method: method || 'POST',\n          signal: signal_ || (timeout > 0 ? signal : undefined),\n        })\n        return response\n      },\n      {\n        errorInstance: new TimeoutError({ body, url }),\n        timeout,\n        signal: true,\n      },\n    )\n\n    let data\n    if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n      data = await response.json()\n    } else {\n      data = await response.text()\n    }\n\n    if (!response.ok) {\n      throw new HttpRequestError({\n        body,\n        details: stringify(data.error) || response.statusText,\n        headers: response.headers,\n        status: response.status,\n        url,\n      })\n    }\n\n    if (data.error) {\n      throw new RpcError({ body, error: data.error, url })\n    }\n    return data as RpcResponse\n  } catch (err) {\n    if (err instanceof HttpRequestError) throw err\n    if (err instanceof RpcError) throw err\n    if (err instanceof TimeoutError) throw err\n    throw new HttpRequestError({\n      body,\n      details: (err as Error).message,\n      url,\n    })\n  }\n}\n\n///////////////////////////////////////////////////\n// WebSocket\n\ntype Id = string | number\ntype CallbackFn = (message: any) => void\ntype CallbackMap = Map<Id, CallbackFn>\n\nexport type Socket = WebSocket & {\n  requests: CallbackMap\n  subscriptions: CallbackMap\n}\n\nconst sockets = new Map<string, Socket>()\n\nexport async function getSocket(url_: string) {\n  const url = new URL(url_)\n  const urlKey = url.toString()\n\n  let socket = sockets.get(urlKey)\n\n  // If the socket already exists, return it.\n  if (socket) return socket\n\n  const webSocket = new WebSocket(url)\n\n  // Set up a cache for incoming \"synchronous\" requests.\n  const requests = new Map<Id, CallbackFn>()\n\n  // Set up a cache for subscriptions (eth_subscribe).\n  const subscriptions = new Map<Id, CallbackFn>()\n\n  const onMessage: (event: WebSocket.MessageEvent) => void = ({ data }) => {\n    const message: RpcResponse = JSON.parse(data as string)\n    const isSubscription = message.method === 'eth_subscription'\n    const id = isSubscription ? message.params.subscription : message.id\n    const cache = isSubscription ? subscriptions : requests\n    const callback = cache.get(id)\n    if (callback) callback({ data })\n    if (!isSubscription) cache.delete(id)\n  }\n  const onClose = () => {\n    sockets.delete(urlKey)\n    webSocket.removeEventListener('close', onClose)\n    webSocket.removeEventListener('message', onMessage)\n  }\n\n  // Setup event listeners for RPC & subscription responses.\n  webSocket.addEventListener('close', onClose)\n  webSocket.addEventListener('message', onMessage)\n\n  // Wait for the socket to open.\n  if (webSocket.readyState === WebSocket.CONNECTING) {\n    await new Promise((resolve, reject) => {\n      if (!webSocket) return\n      webSocket.onopen = resolve\n      webSocket.onerror = reject\n    })\n  }\n\n  // Create a new socket instance.\n  socket = Object.assign(webSocket, {\n    requests,\n    subscriptions,\n  })\n  sockets.set(urlKey, socket)\n\n  return socket\n}\n\nfunction webSocket(\n  socket: Socket,\n  {\n    body,\n    onData,\n    onError,\n  }: {\n    // The RPC request body.\n    body: RpcRequest\n    // The callback to invoke when the request is successful.\n    onData?: (message: RpcResponse) => void\n    // The callback to invoke if the request errors.\n    onError?: (message: RpcResponse['error']) => void\n  },\n) {\n  if (\n    socket.readyState === socket.CLOSED ||\n    socket.readyState === socket.CLOSING\n  )\n    throw new WebSocketRequestError({\n      body,\n      url: socket.url,\n      details: 'Socket is closed.',\n    })\n\n  const id_ = id++\n\n  const callback = ({ data }: { data: any }) => {\n    const message: RpcResponse = JSON.parse(data)\n\n    if (typeof message.id === 'number' && id_ !== message.id) return\n\n    if (message.error) {\n      onError?.(new RpcError({ body, error: message.error, url: socket.url }))\n    } else {\n      onData?.(message)\n    }\n\n    // If we are subscribing to a topic, we want to set up a listener for incoming\n    // messages.\n    if (body.method === 'eth_subscribe' && typeof message.result === 'string') {\n      socket.subscriptions.set(message.result, callback)\n    }\n\n    // If we are unsubscribing from a topic, we want to remove the listener.\n    if (body.method === 'eth_unsubscribe') {\n      socket.subscriptions.delete(body.params?.[0])\n    }\n  }\n  socket.requests.set(id_, callback)\n\n  socket.send(JSON.stringify({ jsonrpc: '2.0', ...body, id: id_ }))\n\n  return socket\n}\n\nasync function webSocketAsync(\n  socket: Socket,\n  {\n    body,\n    timeout = 10_000,\n  }: {\n    // The RPC request body.\n    body: RpcRequest\n    // The timeout (in ms) for the request.\n    timeout?: number\n  },\n) {\n  return withTimeout(\n    () =>\n      new Promise<RpcResponse>((onData, onError) =>\n        rpc.webSocket(socket, {\n          body,\n          onData,\n          onError,\n        }),\n      ),\n    {\n      errorInstance: new TimeoutError({ body, url: socket.url }),\n      timeout,\n    },\n  )\n}\n\n///////////////////////////////////////////////////\n\nexport const rpc = {\n  http,\n  webSocket,\n  webSocketAsync,\n}\n","export const stringify: typeof JSON.stringify = (value, replacer, space) =>\n  JSON.stringify(\n    value,\n    (key, value_) => {\n      const value = typeof value_ === 'bigint' ? value_.toString() : value_\n      return typeof replacer === 'function' ? replacer(key, value) : value\n    },\n    space,\n  )\n","import { SendTransactionParameters } from '../../actions'\nimport {\n  FeeCapTooHighError,\n  InvalidAddressError,\n  TipAboveFeeCapError,\n} from '../../errors'\nimport { FeeConflictError } from '../../errors/transaction'\nimport { Chain } from '../../types'\nimport { isAddress } from '../address'\n\nexport function assertRequest(args: Partial<SendTransactionParameters<Chain>>) {\n  const { account, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args\n  if (account && !isAddress(account.address))\n    throw new InvalidAddressError({ address: account.address })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (\n    typeof gasPrice !== 'undefined' &&\n    (typeof maxFeePerGas !== 'undefined' ||\n      typeof maxPriorityFeePerGas !== 'undefined')\n  )\n    throw new FeeConflictError()\n\n  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas })\n  if (\n    maxPriorityFeePerGas &&\n    maxFeePerGas &&\n    maxPriorityFeePerGas > maxFeePerGas\n  )\n    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })\n}\n","import type { PublicClient } from '../../clients'\nimport { BaseError } from '../../errors'\nimport type {\n  BlockTag,\n  Chain,\n  Formatter,\n  Hex,\n  MergeIntersectionProperties,\n  TransactionRequest,\n} from '../../types'\nimport { Account } from '../../types/account'\nimport {\n  assertRequest,\n  extract,\n  Formatted,\n  getCallError,\n  TransactionRequestFormatter,\n} from '../../utils'\nimport { format, formatTransactionRequest, numberToHex } from '../../utils'\n\nexport type FormattedCall<\n  TFormatter extends Formatter | undefined = Formatter,\n> = MergeIntersectionProperties<\n  Omit<Formatted<TFormatter, TransactionRequest, true>, 'from'>,\n  TransactionRequest\n>\n\nexport type CallParameters<TChain extends Chain = Chain> = FormattedCall<\n  TransactionRequestFormatter<TChain>\n> & {\n  account?: Account\n} & (\n    | {\n        /** The balance of the account at a block number. */\n        blockNumber?: bigint\n        blockTag?: never\n      }\n    | {\n        blockNumber?: never\n        /** The balance of the account at a block tag. */\n        blockTag?: BlockTag\n      }\n  )\n\nexport type CallReturnType = { data: Hex | undefined }\n\nexport async function call<TChain extends Chain>(\n  client: PublicClient<any, TChain>,\n  args: CallParameters<TChain>,\n): Promise<CallReturnType> {\n  const {\n    account,\n    blockNumber,\n    blockTag = 'latest',\n    accessList,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    ...rest\n  } = args\n  try {\n    assertRequest(args)\n\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n    const formatter = client.chain?.formatters?.transactionRequest\n    const request_ = format(\n      {\n        from: account?.address,\n        accessList,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        to,\n        value,\n        // Pick out extra data that might exist on the chain's transaction request type.\n        ...extract(rest, { formatter }),\n      } as TransactionRequest,\n      {\n        formatter: formatter || formatTransactionRequest,\n      },\n    )\n\n    const response = await client.request({\n      method: 'eth_call',\n      params: [request_, blockNumberHex || blockTag],\n    })\n    if (response === '0x') return { data: undefined }\n    return { data: response }\n  } catch (err) {\n    throw getCallError(err as BaseError, {\n      ...args,\n      chain: client.chain,\n    })\n  }\n}\n","import { Abi } from 'abitype'\n\nimport type { PublicClient } from '../../clients'\nimport { BaseError } from '../../errors'\nimport type {\n  Chain,\n  ContractConfig,\n  ExtractResultFromAbi,\n  GetValue,\n} from '../../types'\nimport {\n  DecodeFunctionResultParameters,\n  EncodeFunctionDataParameters,\n  decodeFunctionResult,\n  encodeFunctionData,\n  getContractError,\n} from '../../utils'\nimport { WriteContractParameters } from '../wallet'\nimport { call, CallParameters } from './call'\n\nexport type SimulateContractParameters<\n  TChain extends Chain = Chain,\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = any,\n  TChainOverride extends Chain | undefined = undefined,\n> = Omit<\n  CallParameters<TChainOverride extends Chain ? TChainOverride : TChain>,\n  'to' | 'data' | 'value'\n> & {\n  chain?: TChainOverride\n} & ContractConfig<TAbi, TFunctionName, 'payable' | 'nonpayable'> & {\n    value?: GetValue<TAbi, TFunctionName, CallParameters<TChain>['value']>\n  }\n\nexport type SimulateContractReturnType<\n  TChain extends Chain = Chain,\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = string,\n> = {\n  result: ExtractResultFromAbi<TAbi, TFunctionName>\n  request: WriteContractParameters<TChain, TAbi, TFunctionName> &\n    ContractConfig<TAbi, TFunctionName, 'payable' | 'nonpayable'>\n}\n\nexport async function simulateContract<\n  TChain extends Chain,\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n  TChainOverride extends Chain | undefined,\n>(\n  client: PublicClient<any, TChain>,\n  {\n    abi,\n    address,\n    args,\n    functionName,\n    ...callRequest\n  }: SimulateContractParameters<TChain, TAbi, TFunctionName, TChainOverride>,\n): Promise<\n  SimulateContractReturnType<\n    TChainOverride extends Chain ? TChainOverride : TChain,\n    TAbi,\n    TFunctionName\n  >\n> {\n  const calldata = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as unknown as EncodeFunctionDataParameters<TAbi, TFunctionName>)\n  try {\n    const { data } = await call(client, {\n      data: calldata,\n      to: address,\n      ...callRequest,\n    } as unknown as CallParameters<TChain>)\n    const result = decodeFunctionResult({\n      abi,\n      args,\n      functionName,\n      data: data || '0x',\n    } as DecodeFunctionResultParameters)\n    return {\n      result,\n      request: {\n        abi,\n        address,\n        args,\n        functionName,\n        ...callRequest,\n      },\n    } as unknown as SimulateContractReturnType<\n      TChainOverride extends Chain ? TChainOverride : TChain,\n      TAbi,\n      TFunctionName\n    >\n  } catch (err) {\n    throw getContractError(err as BaseError, {\n      abi: abi as Abi,\n      address,\n      args,\n      docsPath: '/docs/contract/simulateContract',\n      functionName,\n      sender: callRequest.account?.address,\n    })\n  }\n}\n","import type { PublicClient } from '../../clients'\n\nimport type { Filter } from '../../types'\n\nexport type CreatePendingTransactionFilterReturnType = Filter<'transaction'>\n\nexport async function createPendingTransactionFilter(\n  client: PublicClient,\n): Promise<CreatePendingTransactionFilterReturnType> {\n  const id = await client.request({\n    method: 'eth_newPendingTransactionFilter',\n  })\n  return { id, type: 'transaction' }\n}\n","import type { PublicClient } from '../../clients'\n\nimport type { Filter } from '../../types'\n\nexport type CreateBlockFilterReturnType = Filter<'block'>\n\nexport async function createBlockFilter(\n  client: PublicClient,\n): Promise<CreateBlockFilterReturnType> {\n  const id = await client.request({\n    method: 'eth_newBlockFilter',\n  })\n  return { id, type: 'block' }\n}\n","import { Abi, AbiEvent } from 'abitype'\nimport type { PublicClient } from '../../clients'\n\nimport type {\n  Address,\n  BlockNumber,\n  BlockTag,\n  Filter,\n  LogTopic,\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types'\nimport {\n  EncodeEventTopicsParameters,\n  encodeEventTopics,\n  numberToHex,\n} from '../../utils'\n\nexport type CreateEventFilterParameters<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbi extends Abi | readonly unknown[] = [TAbiEvent],\n  TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n  TArgs extends\n    | MaybeExtractEventArgsFromAbi<TAbi, TEventName>\n    | undefined = undefined,\n> = {\n  address?: Address | Address[]\n  fromBlock?: BlockNumber | BlockTag\n  toBlock?: BlockNumber | BlockTag\n} & (MaybeExtractEventArgsFromAbi<\n  TAbi,\n  TEventName\n> extends infer TEventFilterArgs\n  ?\n      | {\n          args:\n            | TEventFilterArgs\n            | (TArgs extends TEventFilterArgs ? TArgs : never)\n          event: TAbiEvent\n        }\n      | {\n          args?: never\n          event?: TAbiEvent\n        }\n      | {\n          args?: never\n          event?: never\n        }\n  : {\n      args?: never\n      event?: never\n    })\n\nexport type CreateEventFilterReturnType<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbi extends Abi | readonly unknown[] = [TAbiEvent],\n  TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n  TArgs extends\n    | MaybeExtractEventArgsFromAbi<TAbi, TEventName>\n    | undefined = undefined,\n> = Filter<'event', TAbi, TEventName, TArgs>\n\nexport async function createEventFilter<\n  TAbiEvent extends AbiEvent | undefined,\n  TAbi extends Abi | readonly unknown[] = [TAbiEvent],\n  TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n  TArgs extends\n    | MaybeExtractEventArgsFromAbi<TAbi, TEventName>\n    | undefined = undefined,\n>(\n  client: PublicClient,\n  {\n    address,\n    args,\n    event,\n    fromBlock,\n    toBlock,\n  }: CreateEventFilterParameters<\n    TAbiEvent,\n    TAbi,\n    TEventName,\n    TArgs\n  > = {} as any,\n): Promise<CreateEventFilterReturnType<TAbiEvent, TAbi, TEventName, TArgs>> {\n  let topics: LogTopic[] = []\n  if (event)\n    topics = encodeEventTopics({\n      abi: [event],\n      eventName: event.name,\n      args,\n    } as EncodeEventTopicsParameters)\n\n  const id = await client.request({\n    method: 'eth_newFilter',\n    params: [\n      {\n        address,\n        fromBlock:\n          typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n        toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n        ...(topics.length ? { topics } : {}),\n      },\n    ],\n  })\n  return {\n    abi: event ? [event] : undefined,\n    args,\n    eventName: event ? event.name : undefined,\n    id,\n    type: 'event',\n  } as unknown as CreateEventFilterReturnType<\n    TAbiEvent,\n    TAbi,\n    TEventName,\n    TArgs\n  >\n}\n","import { Abi, Narrow } from 'abitype'\nimport type { PublicClient } from '../../clients'\n\nimport type {\n  Address,\n  BlockNumber,\n  BlockTag,\n  ExtractEventNameFromAbi,\n  Filter,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types'\nimport {\n  encodeEventTopics,\n  EncodeEventTopicsParameters,\n  numberToHex,\n} from '../../utils'\n\nexport type CreateContractEventFilterParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TEventName extends string | undefined = undefined,\n  TArgs extends\n    | MaybeExtractEventArgsFromAbi<TAbi, TEventName>\n    | undefined = undefined,\n> = {\n  address?: Address | Address[]\n  abi: Narrow<TAbi>\n  eventName?: ExtractEventNameFromAbi<TAbi, TEventName>\n  fromBlock?: BlockNumber | BlockTag\n  toBlock?: BlockNumber | BlockTag\n} & (undefined extends TEventName\n  ? {\n      args?: never\n    }\n  : MaybeExtractEventArgsFromAbi<\n      TAbi,\n      TEventName\n    > extends infer TEventFilterArgs\n  ? {\n      args?: TEventFilterArgs | (TArgs extends TEventFilterArgs ? TArgs : never)\n    }\n  : {\n      args?: never\n    })\n\nexport type CreateContractEventFilterReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TEventName extends string | undefined = undefined,\n  TArgs extends\n    | MaybeExtractEventArgsFromAbi<TAbi, TEventName>\n    | undefined = undefined,\n> = Filter<'event', TAbi, TEventName, TArgs>\n\nexport async function createContractEventFilter<\n  TAbi extends Abi | readonly unknown[],\n  TEventName extends string | undefined,\n  TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined,\n>(\n  client: PublicClient,\n  {\n    address,\n    abi,\n    args,\n    eventName,\n    fromBlock,\n    toBlock,\n  }: CreateContractEventFilterParameters<TAbi, TEventName, TArgs>,\n): Promise<CreateContractEventFilterReturnType<TAbi, TEventName, TArgs>> {\n  const topics = eventName\n    ? encodeEventTopics({\n        abi,\n        args,\n        eventName,\n      } as unknown as EncodeEventTopicsParameters)\n    : undefined\n  const id = await client.request({\n    method: 'eth_newFilter',\n    params: [\n      {\n        address,\n        fromBlock:\n          typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n        toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n        topics,\n      },\n    ],\n  })\n  return {\n    abi,\n    args,\n    eventName,\n    id,\n    type: 'event',\n  } as unknown as CreateContractEventFilterReturnType<TAbi, TEventName, TArgs>\n}\n","import type { PublicClient, WalletClient } from '../../clients'\nimport { BaseError } from '../../errors'\nimport type {\n  BlockTag,\n  Chain,\n  Formatter,\n  MergeIntersectionProperties,\n  TransactionRequest,\n} from '../../types'\nimport { Account } from '../../types/account'\nimport {\n  assertRequest,\n  extract,\n  format,\n  Formatted,\n  formatTransactionRequest,\n  getEstimateGasError,\n  numberToHex,\n  prepareRequest,\n  TransactionRequestFormatter,\n} from '../../utils'\n\nexport type FormattedEstimateGas<\n  TFormatter extends Formatter | undefined = Formatter,\n> = MergeIntersectionProperties<\n  Omit<Formatted<TFormatter, TransactionRequest, true>, 'from'>,\n  TransactionRequest\n>\n\nexport type EstimateGasParameters<TChain extends Chain = Chain> =\n  FormattedEstimateGas<TransactionRequestFormatter<TChain>> & {\n    account: Account\n  } & (\n      | {\n          /** The balance of the account at a block number. */\n          blockNumber?: bigint\n          blockTag?: never\n        }\n      | {\n          blockNumber?: never\n          /** The balance of the account at a block tag. */\n          blockTag?: BlockTag\n        }\n    )\n\nexport type EstimateGasReturnType = bigint\n\n/**\n * @description Estimates the gas necessary to complete a transaction without submitting it to the network.\n */\nexport async function estimateGas<TChain extends Chain>(\n  client: PublicClient<any, TChain> | WalletClient,\n  args: EstimateGasParameters<TChain>,\n): Promise<EstimateGasReturnType> {\n  try {\n    const {\n      account,\n      accessList,\n      blockNumber,\n      blockTag = 'latest',\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n      ...rest\n    } = args.account.type === 'local'\n      ? await prepareRequest(client, args)\n      : args\n\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n\n    assertRequest(args)\n\n    const formatter = client.chain?.formatters?.transactionRequest\n    const request = format(\n      {\n        from: account.address,\n        accessList,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        to,\n        value,\n        // Pick out extra data that might exist on the chain's transaction request type.\n        ...extract(rest, { formatter }),\n      } as TransactionRequest,\n      {\n        formatter: formatter || formatTransactionRequest,\n      },\n    )\n\n    const balance = await client.request({\n      method: 'eth_estimateGas',\n      params: [request, blockNumberHex || blockTag],\n    })\n    return BigInt(balance)\n  } catch (err) {\n    throw getEstimateGasError(err as BaseError, {\n      ...args,\n      chain: client.chain,\n    })\n  }\n}\n","import { Abi } from 'abitype'\n\nimport type { PublicClient } from '../../clients'\nimport { BaseError } from '../../errors'\nimport type { Chain, ContractConfig, GetValue } from '../../types'\nimport {\n  EncodeFunctionDataParameters,\n  encodeFunctionData,\n  getContractError,\n} from '../../utils'\nimport { estimateGas, EstimateGasParameters } from './estimateGas'\n\nexport type EstimateContractGasParameters<\n  TChain extends Chain = Chain,\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = any,\n> = Omit<EstimateGasParameters<TChain>, 'data' | 'to' | 'value'> &\n  ContractConfig<TAbi, TFunctionName, 'payable' | 'nonpayable'> & {\n    value?: GetValue<\n      TAbi,\n      TFunctionName,\n      EstimateGasParameters<TChain>['value']\n    >\n  }\nexport type EstimateContractGasReturnType = bigint\n\nexport async function estimateContractGas<\n  TChain extends Chain,\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n>(\n  client: PublicClient<any, TChain>,\n  {\n    abi,\n    address,\n    args,\n    functionName,\n    ...request\n  }: EstimateContractGasParameters<TChain, TAbi, TFunctionName>,\n): Promise<EstimateContractGasReturnType> {\n  const data = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as unknown as EncodeFunctionDataParameters<TAbi, TFunctionName>)\n  try {\n    const gas = await estimateGas(client, {\n      data,\n      to: address,\n      ...request,\n    } as unknown as EstimateGasParameters<TChain>)\n    return gas\n  } catch (err) {\n    throw getContractError(err as BaseError, {\n      abi: abi as Abi,\n      address,\n      args,\n      docsPath: '/docs/contract/simulateContract',\n      functionName,\n      sender: request.account?.address,\n    })\n  }\n}\n","import type { PublicClient } from '../../clients'\nimport type { Address, BlockTag } from '../../types'\nimport { numberToHex } from '../../utils'\n\nexport type GetBalanceParameters = {\n  /** The address of the account. */\n  address: Address\n} & (\n  | {\n      /** The balance of the account at a block number. */\n      blockNumber?: bigint\n      blockTag?: never\n    }\n  | {\n      blockNumber?: never\n      /** The balance of the account at a block tag. */\n      blockTag?: BlockTag\n    }\n)\n\nexport type GetBalanceReturnType = bigint\n\n/**\n * @description Returns the balance of an address in wei.\n */\nexport async function getBalance(\n  client: PublicClient,\n  { address, blockNumber, blockTag = 'latest' }: GetBalanceParameters,\n): Promise<GetBalanceReturnType> {\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n\n  const balance = await client.request({\n    method: 'eth_getBalance',\n    params: [address, blockNumberHex || blockTag],\n  })\n  return BigInt(balance)\n}\n","import type { PublicClient, WalletClient } from '../../clients'\nimport { BlockNotFoundError } from '../../errors'\nimport type { BlockTag, Chain, Hash, RpcBlock } from '../../types'\nimport type { BlockFormatter, FormattedBlock } from '../../utils'\nimport { format, formatBlock, numberToHex } from '../../utils'\n\nexport type GetBlockParameters = {\n  /** Whether or not to include transaction data in the response. */\n  includeTransactions?: boolean\n} & (\n  | {\n      /** Hash of the block. */\n      blockHash?: Hash\n      blockNumber?: never\n      blockTag?: never\n    }\n  | {\n      blockHash?: never\n      /** The block number. */\n      blockNumber?: bigint\n      blockTag?: never\n    }\n  | {\n      blockHash?: never\n      blockNumber?: never\n      /** The block tag. Defaults to 'latest'. */\n      blockTag?: BlockTag\n    }\n)\n\nexport type GetBlockReturnType<TChain extends Chain = Chain> = FormattedBlock<\n  BlockFormatter<TChain>\n>\n\nexport async function getBlock<TChain extends Chain>(\n  client: PublicClient<any, TChain> | WalletClient,\n  {\n    blockHash,\n    blockNumber,\n    blockTag = 'latest',\n    includeTransactions = false,\n  }: GetBlockParameters = {},\n): Promise<GetBlockReturnType<TChain>> {\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n\n  let block: RpcBlock | null = null\n  if (blockHash) {\n    block = await client.request({\n      method: 'eth_getBlockByHash',\n      params: [blockHash, includeTransactions],\n    })\n  } else {\n    block = await client.request({\n      method: 'eth_getBlockByNumber',\n      params: [blockNumberHex || blockTag, includeTransactions],\n    })\n  }\n\n  if (!block) throw new BlockNotFoundError({ blockHash, blockNumber })\n\n  return format(block, {\n    formatter: client.chain?.formatters?.block || formatBlock,\n  })\n}\n","import type { PublicClient } from '../../clients'\nimport { getCache, withCache } from '../../utils/promise'\n\nexport type GetBlockNumberParameters = {\n  /** The maximum age (in ms) of the cached value. */\n  maxAge?: number\n}\n\nexport type GetBlockNumberReturnType = bigint\n\nconst cacheKey = (id: string) => `blockNumber.${id}`\n\nexport function getBlockNumberCache(id: string) {\n  return getCache(cacheKey(id))\n}\n\n/**\n * @description Returns the number of the most recent block seen.\n */\nexport async function getBlockNumber(\n  client: PublicClient<any, any, any>,\n  { maxAge = client.pollingInterval }: GetBlockNumberParameters = {},\n): Promise<GetBlockNumberReturnType> {\n  const blockNumberHex = await withCache(\n    () =>\n      client.request({\n        method: 'eth_blockNumber',\n      }),\n    { cacheKey: cacheKey(client.uid), maxAge },\n  )\n  return BigInt(blockNumberHex)\n}\n","import type { PublicClient } from '../../clients'\nimport type { BlockTag, Chain, Hash, Quantity } from '../../types'\nimport { hexToNumber, numberToHex } from '../../utils'\n\nexport type GetBlockTransactionCountParameters =\n  | {\n      /** Hash of the block. */\n      blockHash?: Hash\n      blockNumber?: never\n      blockTag?: never\n    }\n  | {\n      blockHash?: never\n      /** The block number. */\n      blockNumber?: bigint\n      blockTag?: never\n    }\n  | {\n      blockHash?: never\n      blockNumber?: never\n      /** The block tag. Defaults to 'latest'. */\n      blockTag?: BlockTag\n    }\n\nexport type GetBlockTransactionCountReturnType = number\n\nexport async function getBlockTransactionCount<TChain extends Chain>(\n  client: PublicClient<any, TChain>,\n  {\n    blockHash,\n    blockNumber,\n    blockTag = 'latest',\n  }: GetBlockTransactionCountParameters = {},\n): Promise<GetBlockTransactionCountReturnType> {\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n\n  let count: Quantity | null = null\n  if (blockHash) {\n    count = await client.request({\n      method: 'eth_getBlockTransactionCountByHash',\n      params: [blockHash],\n    })\n  } else {\n    count = await client.request({\n      method: 'eth_getBlockTransactionCountByNumber',\n      params: [blockNumberHex || blockTag],\n    })\n  }\n\n  return hexToNumber(count)\n}\n","import { PublicClient } from '../../clients'\nimport { Address, BlockTag, Hex } from '../../types'\nimport { numberToHex } from '../../utils'\n\nexport type GetBytecodeParameters = {\n  address: Address\n} & (\n  | {\n      blockNumber?: never\n      blockTag?: BlockTag\n    }\n  | {\n      blockNumber?: bigint\n      blockTag?: never\n    }\n)\n\nexport type GetBytecodeReturnType = Hex | undefined\n\nexport async function getBytecode(\n  client: PublicClient,\n  { address, blockNumber, blockTag = 'latest' }: GetBytecodeParameters,\n): Promise<GetBytecodeReturnType> {\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n  const hex = await client.request({\n    method: 'eth_getCode',\n    params: [address, blockNumberHex || blockTag],\n  })\n  if (hex === '0x') return undefined\n  return hex\n}\n","import type { PublicClient, WalletClient } from '../../clients'\nimport { hexToNumber } from '../../utils'\n\nexport type GetChainIdReturnType = number\n\nexport async function getChainId(\n  client: PublicClient | WalletClient,\n): Promise<GetChainIdReturnType> {\n  const chainIdHex = await client.request({ method: 'eth_chainId' })\n  return hexToNumber(chainIdHex)\n}\n","import type { PublicClient } from '../../clients'\nimport type { BlockTag, FeeHistory } from '../../types'\n\nimport { numberToHex } from '../../utils'\nimport { formatFeeHistory } from '../../utils/formatters'\n\nexport type GetFeeHistoryParameters = {\n  blockCount: number\n  rewardPercentiles: number[]\n} & (\n  | {\n      blockNumber?: never\n      blockTag?: BlockTag\n    }\n  | {\n      blockNumber?: bigint\n      blockTag?: never\n    }\n)\nexport type GetFeeHistoryReturnType = FeeHistory\n\n/**\n * @description Returns a collection of historical gas information.\n */\nexport async function getFeeHistory(\n  client: PublicClient,\n  {\n    blockCount,\n    blockNumber,\n    blockTag = 'latest',\n    rewardPercentiles,\n  }: GetFeeHistoryParameters,\n): Promise<GetFeeHistoryReturnType> {\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n  const feeHistory = await client.request({\n    method: 'eth_feeHistory',\n    params: [\n      numberToHex(blockCount),\n      blockNumberHex || blockTag,\n      rewardPercentiles,\n    ],\n  })\n  return formatFeeHistory(feeHistory)\n}\n","import { Abi, AbiEvent } from 'abitype'\nimport type { PublicClient } from '../../clients'\nimport type {\n  Filter,\n  FilterType,\n  Hash,\n  Log,\n  MaybeAbiEventName,\n} from '../../types'\nimport { decodeEventLog } from '../../utils'\n\nimport { formatLog } from '../../utils/formatters/log'\n\nexport type GetFilterChangesParameters<\n  TFilterType extends FilterType = FilterType,\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbi extends Abi | readonly unknown[] = [TAbiEvent],\n  TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = {\n  filter: Filter<TFilterType, TAbi, TEventName, any>\n}\n\nexport type GetFilterChangesReturnType<\n  TFilterType extends FilterType = FilterType,\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbi extends Abi | readonly unknown[] = [TAbiEvent],\n  TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = TFilterType extends 'event'\n  ? Log<bigint, number, TAbiEvent, TAbi, TEventName>[]\n  : Hash[]\n\nexport async function getFilterChanges<\n  TFilterType extends FilterType,\n  TAbiEvent extends AbiEvent | undefined,\n  TAbi extends Abi | readonly unknown[],\n  TEventName extends string | undefined,\n>(\n  client: PublicClient,\n  {\n    filter,\n  }: GetFilterChangesParameters<TFilterType, TAbiEvent, TAbi, TEventName>,\n) {\n  const logs = await client.request({\n    method: 'eth_getFilterChanges',\n    params: [filter.id],\n  })\n  return logs.map((log) => {\n    if (typeof log === 'string') return log\n    const { eventName, args } =\n      'abi' in filter && filter.abi\n        ? decodeEventLog({\n            abi: filter.abi,\n            data: log.data,\n            topics: log.topics as any,\n          })\n        : { eventName: undefined, args: undefined }\n    return formatLog(log, { args, eventName })\n  }) as GetFilterChangesReturnType<TFilterType, TAbiEvent, TAbi, TEventName>\n}\n","import type { Abi, AbiEvent } from 'abitype'\nimport type { PublicClient } from '../../clients'\nimport type { Filter, Log, MaybeAbiEventName } from '../../types'\nimport { decodeEventLog } from '../../utils'\n\nimport { formatLog } from '../../utils/formatters/log'\n\nexport type GetFilterLogsParameters<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbi extends Abi | readonly unknown[] = [TAbiEvent],\n  TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = {\n  filter: Filter<'event', TAbi, TEventName, any>\n}\nexport type GetFilterLogsReturnType<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbi extends Abi | readonly unknown[] = [TAbiEvent],\n  TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = Log<bigint, number, TAbiEvent, TAbi, TEventName>[]\n\nexport async function getFilterLogs<\n  TAbiEvent extends AbiEvent | undefined,\n  TAbi extends Abi | readonly unknown[],\n  TEventName extends string | undefined,\n>(\n  client: PublicClient,\n  { filter }: GetFilterLogsParameters<TAbiEvent, TAbi, TEventName>,\n): Promise<GetFilterLogsReturnType<TAbiEvent, TAbi, TEventName>> {\n  const logs = await client.request({\n    method: 'eth_getFilterLogs',\n    params: [filter.id],\n  })\n  return logs.map((log) => {\n    const { eventName, args } =\n      'abi' in filter && filter.abi\n        ? decodeEventLog({\n            abi: filter.abi,\n            data: log.data,\n            topics: log.topics as any,\n          })\n        : { eventName: undefined, args: undefined }\n    return formatLog(log, { args, eventName })\n  }) as unknown as GetFilterLogsReturnType<TAbiEvent, TAbi, TEventName>\n}\n","import type { PublicClient, WalletClient } from '../../clients'\n\nexport type GetGasPriceReturnType = bigint\n\n/**\n * @description Returns the current price of gas (in wei).\n */\nexport async function getGasPrice(\n  client: PublicClient | WalletClient,\n): Promise<GetGasPriceReturnType> {\n  const gasPrice = await client.request({\n    method: 'eth_gasPrice',\n  })\n  return BigInt(gasPrice)\n}\n","import { AbiEvent } from 'abitype'\nimport type { PublicClient } from '../../clients'\nimport type {\n  Log,\n  RpcLog,\n  Address,\n  BlockNumber,\n  BlockTag,\n  Hash,\n  LogTopic,\n  MaybeExtractEventArgsFromAbi,\n  MaybeAbiEventName,\n} from '../../types'\nimport type { EncodeEventTopicsParameters } from '../../utils'\nimport { decodeEventLog, encodeEventTopics, numberToHex } from '../../utils'\nimport { formatLog } from '../../utils/formatters/log'\n\nexport type GetLogsParameters<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = {\n  /** Address or list of addresses from which logs originated */\n  address?: Address | Address[]\n} & (\n  | {\n      event: TAbiEvent\n      args?: MaybeExtractEventArgsFromAbi<[TAbiEvent], TEventName>\n    }\n  | {\n      event?: never\n      args?: never\n    }\n) &\n  (\n    | {\n        /** Block number or tag after which to include logs */\n        fromBlock?: BlockNumber<bigint> | BlockTag\n        /** Block number or tag before which to include logs */\n        toBlock?: BlockNumber<bigint> | BlockTag\n        blockHash?: never\n      }\n    | {\n        fromBlock?: never\n        toBlock?: never\n        /** Hash of block to include logs from */\n        blockHash?: Hash\n      }\n  )\n\nexport type GetLogsReturnType<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = Log<bigint, number, TAbiEvent, [TAbiEvent], TEventName>[]\n\n/**\n * @description Returns a collection of event logs.\n */\nexport async function getLogs<TAbiEvent extends AbiEvent | undefined>(\n  client: PublicClient,\n  {\n    address,\n    blockHash,\n    fromBlock,\n    toBlock,\n    event,\n    args,\n  }: GetLogsParameters<TAbiEvent> = {},\n): Promise<GetLogsReturnType<TAbiEvent>> {\n  let topics: LogTopic[] = []\n  if (event)\n    topics = encodeEventTopics({\n      abi: [event],\n      eventName: event.name,\n      args,\n    } as EncodeEventTopicsParameters)\n\n  let logs: RpcLog[]\n  if (blockHash) {\n    logs = await client.request({\n      method: 'eth_getLogs',\n      params: [{ address, topics, blockHash }],\n    })\n  } else {\n    logs = await client.request({\n      method: 'eth_getLogs',\n      params: [\n        {\n          address,\n          topics,\n          fromBlock:\n            typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n          toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n        },\n      ],\n    })\n  }\n  return logs.map((log) => {\n    const { eventName, args } = event\n      ? decodeEventLog({\n          abi: [event],\n          data: log.data,\n          topics: log.topics as any,\n        })\n      : { eventName: undefined, args: undefined }\n    return formatLog(log, { args, eventName })\n  }) as unknown as GetLogsReturnType<TAbiEvent>\n}\n","import { PublicClient } from '../../clients'\nimport { Address, BlockTag, Hex } from '../../types'\nimport { numberToHex } from '../../utils'\n\nexport type GetStorageAtParameters = {\n  address: Address\n  slot: Hex\n} & (\n  | {\n      blockNumber?: never\n      blockTag?: BlockTag\n    }\n  | {\n      blockNumber?: bigint\n      blockTag?: never\n    }\n)\n\nexport type GetStorageAtReturnType = Hex | undefined\n\nexport async function getStorageAt(\n  client: PublicClient,\n  { address, blockNumber, blockTag = 'latest', slot }: GetStorageAtParameters,\n): Promise<GetStorageAtReturnType> {\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n  const data = await client.request({\n    method: 'eth_getStorageAt',\n    params: [address, slot, blockNumberHex || blockTag],\n  })\n  return data\n}\n","import type { PublicClient } from '../../clients'\nimport { TransactionNotFoundError } from '../../errors'\nimport type { BlockTag, Chain, Hash, RpcTransaction } from '../../types'\nimport { format, numberToHex } from '../../utils'\nimport type {\n  FormattedTransaction,\n  TransactionFormatter,\n} from '../../utils/formatters/transaction'\nimport { formatTransaction } from '../../utils/formatters/transaction'\n\nexport type GetTransactionParameters =\n  | {\n      /** The block hash */\n      blockHash: Hash\n      blockNumber?: never\n      blockTag?: never\n      hash?: never\n      /** The index of the transaction on the block. */\n      index: number\n    }\n  | {\n      blockHash?: never\n      /** The block number */\n      blockNumber: bigint\n      blockTag?: never\n      hash?: never\n      /** The index of the transaction on the block. */\n      index: number\n    }\n  | {\n      blockHash?: never\n      blockNumber?: never\n      /** The block tag. */\n      blockTag: BlockTag\n      hash?: never\n      /** The index of the transaction on the block. */\n      index: number\n    }\n  | {\n      blockHash?: never\n      blockNumber?: never\n      blockTag?: never\n      /** The hash of the transaction. */\n      hash: Hash\n      index?: number\n    }\n\nexport type GetTransactionReturnType<TChain extends Chain = Chain> =\n  FormattedTransaction<TransactionFormatter<TChain>>\n\n/** @description Returns information about a transaction given a hash or block identifier. */\nexport async function getTransaction<TChain extends Chain>(\n  client: PublicClient<any, TChain>,\n  {\n    blockHash,\n    blockNumber,\n    blockTag = 'latest',\n    hash,\n    index,\n  }: GetTransactionParameters,\n): Promise<GetTransactionReturnType<TChain>> {\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n\n  let transaction: RpcTransaction | null = null\n  if (hash) {\n    transaction = await client.request({\n      method: 'eth_getTransactionByHash',\n      params: [hash],\n    })\n  } else if (blockHash) {\n    transaction = await client.request({\n      method: 'eth_getTransactionByBlockHashAndIndex',\n      params: [blockHash, numberToHex(index)],\n    })\n  } else if (blockNumberHex || blockTag) {\n    transaction = await client.request({\n      method: 'eth_getTransactionByBlockNumberAndIndex',\n      params: [blockNumberHex || blockTag, numberToHex(index)],\n    })\n  }\n\n  if (!transaction)\n    throw new TransactionNotFoundError({\n      blockHash,\n      blockNumber,\n      blockTag,\n      hash,\n      index,\n    })\n\n  return format(transaction, {\n    formatter: client.chain?.formatters?.transaction || formatTransaction,\n  })\n}\n","import type { PublicClient } from '../../clients'\nimport type { Chain, Hash } from '../../types'\nimport type {\n  FormattedTransactionReceipt,\n  TransactionReceiptFormatter,\n} from '../../utils'\nimport { getBlockNumber } from './getBlockNumber'\nimport { getTransaction } from './getTransaction'\n\nexport type GetTransactionConfirmationsParameters<\n  TChain extends Chain = Chain,\n> =\n  | {\n      /** The transaction hash. */\n      hash: Hash\n      transactionReceipt?: never\n    }\n  | {\n      hash?: never\n      /** The transaction receipt. */\n      transactionReceipt: FormattedTransactionReceipt<\n        TransactionReceiptFormatter<TChain>\n      >\n    }\n\nexport type GetTransactionConfirmationsReturnType = bigint\n\nexport async function getTransactionConfirmations<TChain extends Chain>(\n  client: PublicClient<any, TChain>,\n  { hash, transactionReceipt }: GetTransactionConfirmationsParameters<TChain>,\n): Promise<GetTransactionConfirmationsReturnType> {\n  const [blockNumber, transaction] = await Promise.all([\n    getBlockNumber(client),\n    hash ? getTransaction(client, { hash }) : undefined,\n  ])\n  const transactionBlockNumber =\n    transactionReceipt?.blockNumber || transaction?.blockNumber\n  if (!transactionBlockNumber) return 0n\n  return blockNumber - transactionBlockNumber! + 1n\n}\n","import type { PublicClient, WalletClient } from '../../clients'\nimport type { Address, BlockTag } from '../../types'\nimport { hexToNumber, numberToHex } from '../../utils'\n\nexport type GetTransactionCountParameters = {\n  /** The account address. */\n  address: Address\n} & (\n  | {\n      /** The block number. */\n      blockNumber?: bigint\n      blockTag?: never\n    }\n  | {\n      blockNumber?: never\n      /** The block tag. Defaults to 'latest'. */\n      blockTag?: BlockTag\n    }\n)\nexport type GetTransactionCountReturnType = number\n\n/**\n * @description Returns the number of transactions an account has broadcast / sent.\n */\nexport async function getTransactionCount(\n  client: PublicClient | WalletClient,\n  { address, blockTag = 'latest', blockNumber }: GetTransactionCountParameters,\n): Promise<GetTransactionCountReturnType> {\n  const count = await client.request({\n    method: 'eth_getTransactionCount',\n    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag],\n  })\n  return hexToNumber(count)\n}\n","import type { PublicClient } from '../../clients'\nimport { TransactionReceiptNotFoundError } from '../../errors'\nimport type { Chain, Hash } from '../../types'\nimport { format } from '../../utils'\nimport type {\n  FormattedTransactionReceipt,\n  TransactionReceiptFormatter,\n} from '../../utils/formatters/transactionReceipt'\nimport { formatTransactionReceipt } from '../../utils/formatters/transactionReceipt'\n\nexport type GetTransactionReceiptParameters = {\n  /** The hash of the transaction. */\n  hash: Hash\n}\n\nexport type GetTransactionReceiptReturnType<TChain extends Chain = Chain> =\n  FormattedTransactionReceipt<TransactionReceiptFormatter<TChain>>\n\nexport async function getTransactionReceipt<TChain extends Chain>(\n  client: PublicClient<any, TChain>,\n  { hash }: GetTransactionReceiptParameters,\n) {\n  const receipt = await client.request({\n    method: 'eth_getTransactionReceipt',\n    params: [hash],\n  })\n\n  if (!receipt) throw new TransactionReceiptNotFoundError({ hash })\n\n  return format(receipt, {\n    formatter:\n      client.chain?.formatters?.transactionReceipt || formatTransactionReceipt,\n  }) as GetTransactionReceiptReturnType<TChain>\n}\n","import { Abi } from 'abitype'\n\nimport type { PublicClient } from '../../clients'\nimport { BaseError } from '../../errors'\nimport type { ContractConfig, ExtractResultFromAbi } from '../../types'\nimport {\n  EncodeFunctionDataParameters,\n  decodeFunctionResult,\n  encodeFunctionData,\n  getContractError,\n  DecodeFunctionResultParameters,\n} from '../../utils'\nimport { call, CallParameters } from './call'\n\nexport type ReadContractParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = string,\n> = Pick<CallParameters, 'blockNumber' | 'blockTag'> &\n  ContractConfig<TAbi, TFunctionName, 'view' | 'pure'>\n\nexport type ReadContractReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = string,\n> = ExtractResultFromAbi<TAbi, TFunctionName>\n\nexport async function readContract<\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n>(\n  client: PublicClient,\n  {\n    abi,\n    address,\n    args,\n    functionName,\n    ...callRequest\n  }: ReadContractParameters<TAbi, TFunctionName>,\n): Promise<ReadContractReturnType<TAbi, TFunctionName>> {\n  const calldata = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as unknown as EncodeFunctionDataParameters<TAbi, TFunctionName>)\n  try {\n    const { data } = await call(client, {\n      data: calldata,\n      to: address,\n      ...callRequest,\n    } as unknown as CallParameters)\n    return decodeFunctionResult({\n      abi,\n      args,\n      functionName,\n      data: data || '0x',\n    } as DecodeFunctionResultParameters<TAbi, TFunctionName>)\n  } catch (err) {\n    throw getContractError(err as BaseError, {\n      abi: abi as Abi,\n      address,\n      args,\n      docsPath: '/docs/contract/readContract',\n      functionName,\n    })\n  }\n}\n","import { PublicClient } from '../../clients'\nimport { multicall3Abi } from '../../constants'\nimport {\n  AbiDecodingZeroDataError,\n  BaseError,\n  RawContractError,\n} from '../../errors'\nimport { Address, ContractConfig, Hex, MulticallContracts } from '../../types'\nimport { MulticallResults } from '../../types/multicall'\nimport {\n  EncodeFunctionDataParameters,\n  decodeFunctionResult,\n  encodeFunctionData,\n  getContractError,\n} from '../../utils'\nimport { CallParameters } from './call'\nimport { readContract } from './readContract'\n\nexport type MulticallParameters<\n  TContracts extends ContractConfig[] = ContractConfig[],\n  TAllowFailure extends boolean = true,\n> = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n  allowFailure?: TAllowFailure\n  contracts: readonly [...MulticallContracts<TContracts>]\n  multicallAddress: Address\n}\n\nexport type MulticallReturnType<\n  TContracts extends ContractConfig[] = ContractConfig[],\n  TAllowFailure extends boolean = true,\n> = MulticallResults<TContracts, TAllowFailure>\n\nexport async function multicall<\n  TContracts extends ContractConfig[],\n  TAllowFailure extends boolean = true,\n>(\n  client: PublicClient,\n  args: MulticallParameters<TContracts, TAllowFailure>,\n): Promise<MulticallReturnType<TContracts, TAllowFailure>> {\n  const {\n    allowFailure = true,\n    blockNumber,\n    blockTag,\n    contracts,\n    multicallAddress,\n  } = args\n\n  const calls = contracts.map(({ abi, address, args, functionName }) => {\n    try {\n      const callData = encodeFunctionData({\n        abi,\n        args,\n        functionName,\n      } as unknown as EncodeFunctionDataParameters)\n      return {\n        allowFailure: true,\n        callData,\n        target: address,\n      }\n    } catch (err) {\n      const error = getContractError(err as BaseError, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName,\n      })\n      if (!allowFailure) throw error\n      return {\n        allowFailure: true,\n        callData: '0x' as Hex,\n        target: address,\n      }\n    }\n  })\n  const results = await readContract(client, {\n    abi: multicall3Abi,\n    address: multicallAddress,\n    args: [calls],\n    blockNumber,\n    blockTag,\n    functionName: 'aggregate3',\n  })\n  return results.map(({ returnData, success }, i) => {\n    const { callData } = calls[i]\n    const { abi, address, functionName, args } = contracts[i]\n    try {\n      if (callData === '0x') throw new AbiDecodingZeroDataError()\n      if (!success) throw new RawContractError({ data: returnData })\n      const result = decodeFunctionResult({\n        abi,\n        data: returnData,\n        functionName: functionName,\n      })\n      return { result, status: 'success' }\n    } catch (err) {\n      const error = getContractError(err as BaseError, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName,\n      })\n      if (!allowFailure) throw error\n      return { error, result: undefined, status: 'failure' }\n    }\n  }) as MulticallResults<TContracts, TAllowFailure>\n}\n","import type { PublicClient } from '../../clients'\nimport type { Filter } from '../../types'\n\nexport type UninstallFilterParameters = {\n  filter: Filter<any>\n}\nexport type UninstallFilterReturnType = boolean\n\nexport async function uninstallFilter(\n  client: PublicClient,\n  { filter }: UninstallFilterParameters,\n): Promise<UninstallFilterReturnType> {\n  return client.request({\n    method: 'eth_uninstallFilter',\n    params: [filter.id],\n  })\n}\n","import type { MaybePromise } from '../types/utils'\n\ntype Callback = ((...args: any[]) => any) | undefined\ntype Callbacks = Record<string, Callback>\n\nexport const listenersCache = new Map<\n  string,\n  { id: number; fns: Callbacks }[]\n>()\nexport const cleanupCache = new Map<string, () => void>()\n\ntype EmitFunction<TCallbacks extends Callbacks> = (\n  emit: TCallbacks,\n) => MaybePromise<void | (() => void)>\n\nlet callbackCount = 0\n\n/**\n * @description Sets up an observer for a given function. If another function\n * is set up under the same observer id, the function will only be called once\n * for both instances of the observer.\n */\nexport function observe<TCallbacks extends Callbacks>(\n  observerId: string,\n  callbacks: TCallbacks,\n  fn: EmitFunction<TCallbacks>,\n) {\n  const callbackId = ++callbackCount\n\n  const getListeners = () => listenersCache.get(observerId) || []\n\n  const unsubscribe = () => {\n    const listeners = getListeners()\n    listenersCache.set(\n      observerId,\n      listeners.filter((cb: any) => cb.id !== callbackId),\n    )\n  }\n\n  const unwatch = () => {\n    const cleanup = cleanupCache.get(observerId)\n    if (getListeners().length === 1 && cleanup) cleanup()\n    unsubscribe()\n  }\n\n  const listeners = getListeners()\n  listenersCache.set(observerId, [\n    ...listeners,\n    { id: callbackId, fns: callbacks },\n  ])\n\n  if (listeners && listeners.length > 0) return unwatch\n\n  let emit: TCallbacks = {} as TCallbacks\n  for (const key in callbacks) {\n    emit[key] = ((\n      ...args: Parameters<NonNullable<TCallbacks[keyof TCallbacks]>>\n    ) => {\n      const listeners = getListeners()\n      if (listeners.length === 0) return\n      listeners.forEach((listener) => listener.fns[key]?.(...args))\n    }) as TCallbacks[Extract<keyof TCallbacks, string>]\n  }\n\n  const cleanup = fn(emit)\n  if (typeof cleanup === 'function') cleanupCache.set(observerId, cleanup)\n\n  return unwatch\n}\n","import type { PublicClient } from '../../clients'\nimport {\n  TransactionNotFoundError,\n  TransactionReceiptNotFoundError,\n  WaitForTransactionReceiptTimeoutError,\n} from '../../errors'\nimport type { Chain, Hash, Transaction } from '../../types'\nimport { observe } from '../../utils/observe'\nimport { getBlock, watchBlockNumber } from '../public'\n\nimport type { GetTransactionReturnType } from './getTransaction'\nimport { getTransaction } from './getTransaction'\nimport type { GetTransactionReceiptReturnType } from './getTransactionReceipt'\nimport { getTransactionReceipt } from './getTransactionReceipt'\n\nexport type ReplacementReason = 'cancelled' | 'replaced' | 'repriced'\nexport type ReplacementReturnType<TChain extends Chain = Chain> = {\n  reason: ReplacementReason\n  replacedTransaction: Transaction\n  transaction: Transaction\n  transactionReceipt: GetTransactionReceiptReturnType<TChain>\n}\n\nexport type WaitForTransactionReceiptReturnType<TChain extends Chain = Chain> =\n  GetTransactionReceiptReturnType<TChain>\n\nexport type WaitForTransactionReceiptParameters<TChain extends Chain = Chain> =\n  {\n    /** The number of confirmations (blocks that have passed) to wait before resolving. */\n    confirmations?: number\n    /** The hash of the transaction. */\n    hash: Hash\n    onReplaced?: (response: ReplacementReturnType<TChain>) => void\n    /** Polling frequency (in ms). Defaults to the client's pollingInterval config. */\n    pollingInterval?: number\n    /** Optional timeout (in milliseconds) to wait before stopping polling. */\n    timeout?: number\n  }\n\nexport async function waitForTransactionReceipt<TChain extends Chain>(\n  client: PublicClient<any, TChain>,\n  {\n    confirmations = 1,\n    hash,\n    onReplaced,\n    pollingInterval = client.pollingInterval,\n    timeout,\n  }: WaitForTransactionReceiptParameters<TChain>,\n): Promise<WaitForTransactionReceiptReturnType<TChain>> {\n  const observerId = JSON.stringify([\n    'waitForTransactionReceipt',\n    client.uid,\n    hash,\n  ])\n\n  let transaction: GetTransactionReturnType<TChain> | undefined\n  let replacedTransaction: GetTransactionReturnType<TChain> | undefined\n  let receipt: GetTransactionReceiptReturnType<TChain>\n\n  return new Promise((resolve, reject) => {\n    if (timeout)\n      setTimeout(\n        () => reject(new WaitForTransactionReceiptTimeoutError({ hash })),\n        timeout,\n      )\n\n    const _unobserve = observe(\n      observerId,\n      { onReplaced, resolve, reject },\n      (emit) => {\n        const unwatch = watchBlockNumber(client, {\n          emitMissed: true,\n          emitOnBegin: true,\n          pollingInterval,\n          async onBlockNumber(blockNumber) {\n            const done = async (fn: () => void) => {\n              unwatch()\n              fn()\n              _unobserve()\n            }\n\n            try {\n              // If we already have a valid receipt, let's check if we have enough\n              // confirmations. If we do, then we can resolve.\n              if (receipt) {\n                if (blockNumber - receipt.blockNumber + 1n < confirmations)\n                  return\n\n                done(() => emit.resolve(receipt))\n                return\n              }\n\n              // Get the transaction to check if it's been replaced.\n              transaction = await getTransaction(client, { hash })\n\n              // Get the receipt to check if it's been processed.\n              receipt = await getTransactionReceipt(client, { hash })\n\n              // Check if we have enough confirmations. If not, continue polling.\n              if (blockNumber - receipt.blockNumber + 1n < confirmations) return\n\n              done(() => emit.resolve(receipt))\n            } catch (err) {\n              // If the receipt is not found, the transaction will be pending.\n              // We need to check if it has potentially been replaced.\n              if (\n                transaction &&\n                (err instanceof TransactionNotFoundError ||\n                  err instanceof TransactionReceiptNotFoundError)\n              ) {\n                replacedTransaction = transaction\n\n                // Let's retrieve the transactions from the current block.\n                const block = await getBlock(client, {\n                  blockNumber,\n                  includeTransactions: true,\n                })\n\n                const replacementTransaction = (\n                  block.transactions as Transaction[]\n                ).find(\n                  ({ from, nonce }) =>\n                    from === replacedTransaction!.from &&\n                    nonce === replacedTransaction!.nonce,\n                )\n\n                // If we couldn't find a replacement transaction, continue polling.\n                if (!replacementTransaction) return\n\n                // If we found a replacement transaction, return it's receipt.\n                receipt = await getTransactionReceipt(client, {\n                  hash: replacementTransaction.hash,\n                })\n\n                // Check if we have enough confirmations. If not, continue polling.\n                if (blockNumber - receipt.blockNumber + 1n < confirmations)\n                  return\n\n                let reason: ReplacementReason = 'replaced'\n                if (\n                  replacementTransaction.to === replacedTransaction.to &&\n                  replacementTransaction.value === replacedTransaction.value\n                ) {\n                  reason = 'repriced'\n                } else if (\n                  replacementTransaction.from === replacementTransaction.to &&\n                  replacementTransaction.value === 0n\n                ) {\n                  reason = 'cancelled'\n                }\n\n                done(() => {\n                  emit.onReplaced?.({\n                    reason,\n                    replacedTransaction: replacedTransaction!,\n                    transaction: replacementTransaction,\n                    transactionReceipt: receipt,\n                  })\n                  emit.resolve(receipt)\n                })\n              } else {\n                done(() => emit.reject(err))\n              }\n            }\n          },\n        })\n        return unwatch\n      },\n    )\n  })\n}\n","import { wait } from './wait'\n\ntype PollOptions<TData> = {\n  // Whether or not to emit when the polling starts.\n  emitOnBegin?: boolean\n  // The initial wait time (in ms) before polling.\n  initialWaitTime?: (data: TData | void) => Promise<number>\n  // The interval (in ms).\n  interval: number\n}\n\n/**\n * @description Polls a function at a specified interval.\n */\nexport function poll<TData>(\n  fn: ({ unpoll }: { unpoll: () => void }) => Promise<TData | void>,\n  { emitOnBegin, initialWaitTime, interval }: PollOptions<TData>,\n) {\n  let active = true\n\n  const unwatch = () => (active = false)\n\n  const watch = async () => {\n    let data: TData | void\n    if (emitOnBegin) data = await fn({ unpoll: unwatch })\n\n    const initialWait = (await initialWaitTime?.(data)) ?? interval\n    await wait(initialWait)\n\n    const poll = async () => {\n      if (!active) return\n      await fn({ unpoll: unwatch })\n      await wait(interval)\n      poll()\n    }\n\n    poll()\n  }\n  watch()\n\n  return unwatch\n}\n","import type { PublicClient } from '../../clients'\nimport { observe } from '../../utils/observe'\nimport { poll } from '../../utils/poll'\nimport type { GetBlockNumberReturnType } from './getBlockNumber'\nimport { getBlockNumber } from './getBlockNumber'\n\nexport type OnBlockNumberParameter = GetBlockNumberReturnType\nexport type OnBlockNumberFn = (\n  blockNumber: OnBlockNumberParameter,\n  prevBlockNumber: OnBlockNumberParameter | undefined,\n) => void\n\nexport type WatchBlockNumberParameters = {\n  /** Whether or not to emit the missed block numbers to the callback. */\n  emitMissed?: boolean\n  /** Whether or not to emit the latest block number to the callback when the subscription opens. */\n  emitOnBegin?: boolean\n  /** The callback to call when a new block number is received. */\n  onBlockNumber: OnBlockNumberFn\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: (error: Error) => void\n  /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */\n  pollingInterval?: number\n}\n\n/** @description Watches and returns incoming block numbers. */\nexport function watchBlockNumber(\n  client: PublicClient<any, any, any>,\n  {\n    emitOnBegin = false,\n    emitMissed = false,\n    onBlockNumber,\n    onError,\n    pollingInterval = client.pollingInterval,\n  }: WatchBlockNumberParameters,\n) {\n  const observerId = JSON.stringify([\n    'watchBlockNumber',\n    client.uid,\n    emitOnBegin,\n    emitMissed,\n    pollingInterval,\n  ])\n\n  let prevBlockNumber: GetBlockNumberReturnType | undefined\n\n  return observe(observerId, { onBlockNumber, onError }, (emit) =>\n    poll(\n      async () => {\n        try {\n          const blockNumber = await getBlockNumber(client, { maxAge: 0 })\n\n          if (prevBlockNumber) {\n            // If the current block number is the same as the previous,\n            // we can skip.\n            if (blockNumber === prevBlockNumber) return\n\n            // If we have missed out on some previous blocks, and the\n            // `emitMissed` flag is truthy, let's emit those blocks.\n            if (blockNumber - prevBlockNumber > 1 && emitMissed) {\n              for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {\n                emit.onBlockNumber(i, prevBlockNumber)\n                prevBlockNumber = i\n              }\n            }\n          }\n          prevBlockNumber = blockNumber\n          emit.onBlockNumber(blockNumber, prevBlockNumber)\n        } catch (err) {\n          emit.onError?.(err as Error)\n        }\n      },\n      {\n        emitOnBegin,\n        interval: pollingInterval,\n      },\n    ),\n  )\n}\n","import type { PublicClient } from '../../clients'\nimport type { BlockTag, Chain } from '../../types'\nimport { observe } from '../../utils/observe'\nimport { poll } from '../../utils/poll'\nimport type { GetBlockReturnType } from './getBlock'\nimport { getBlock } from './getBlock'\n\nexport type OnBlockParameter<\n  TChain extends Chain = Chain,\n  TIncludeTransactions = false,\n> = Omit<\n  GetBlockReturnType<TChain>,\n  TIncludeTransactions extends false ? 'transactions' : ''\n>\nexport type OnBlock<\n  TChain extends Chain = Chain,\n  TIncludeTransactions = false,\n> = (\n  block: OnBlockParameter<TChain, TIncludeTransactions>,\n  prevBlock: OnBlockParameter<TChain, TIncludeTransactions> | undefined,\n) => void\n\nexport type WatchBlocksParameters<TChain extends Chain = Chain> = {\n  /** The block tag. Defaults to \"latest\". */\n  blockTag?: BlockTag\n  /** Whether or not to emit the missed blocks to the callback. */\n  emitMissed?: boolean\n  /** Whether or not to emit the block to the callback when the subscription opens. */\n  emitOnBegin?: boolean\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: (error: Error) => void\n  /** Polling frequency (in ms). Defaults to the client's pollingInterval config. */\n  pollingInterval?: number\n} & (\n  | {\n      /** Whether or not to include transaction data in the response. */\n      includeTransactions: true\n      /** The callback to call when a new block is received. */\n      onBlock: OnBlock<TChain, true>\n    }\n  | {\n      /** Whether or not to include transaction data in the response. */\n      includeTransactions?: false\n      /** The callback to call when a new block is received. */\n      onBlock: OnBlock<TChain>\n    }\n)\n\n/** @description Watches and returns information for incoming blocks. */\nexport function watchBlocks<\n  TChain extends Chain,\n  TWatchBlocksParameters extends WatchBlocksParameters<TChain>,\n>(\n  client: PublicClient<any, TChain>,\n  {\n    blockTag = 'latest',\n    emitMissed = false,\n    emitOnBegin = false,\n    onBlock,\n    onError,\n    includeTransactions = false,\n    pollingInterval = client.pollingInterval,\n  }: TWatchBlocksParameters,\n) {\n  const observerId = JSON.stringify([\n    'watchBlocks',\n    client.uid,\n    emitMissed,\n    emitOnBegin,\n    includeTransactions,\n    pollingInterval,\n  ])\n\n  let prevBlock: GetBlockReturnType<TChain> | undefined\n\n  return observe(observerId, { onBlock, onError }, (emit) =>\n    poll(\n      async () => {\n        try {\n          const block = await getBlock(client, {\n            blockTag,\n            includeTransactions,\n          })\n          if (block.number && prevBlock?.number) {\n            // If the current block number is the same as the previous,\n            // we can skip.\n            if (block.number === prevBlock.number) return\n\n            // If we have missed out on some previous blocks, and the\n            // `emitMissed` flag is truthy, let's emit those blocks.\n            if (block.number - prevBlock.number > 1 && emitMissed) {\n              for (let i = prevBlock?.number + 1n; i < block.number; i++) {\n                const block = await getBlock(client, {\n                  blockNumber: i,\n                  includeTransactions,\n                })\n                emit.onBlock(block, prevBlock)\n                prevBlock = block\n              }\n            }\n          }\n          emit.onBlock(block, prevBlock)\n          prevBlock = block\n        } catch (err) {\n          emit.onError?.(err as Error)\n        }\n      },\n      {\n        emitOnBegin,\n        interval: pollingInterval,\n      },\n    ),\n  )\n}\n","import { Abi, ExtractAbiEvent, Narrow } from 'abitype'\nimport type { PublicClient } from '../../clients'\nimport type {\n  Address,\n  ExtractEventArgsFromAbi,\n  ExtractEventNameFromAbi,\n  Filter,\n  Log,\n} from '../../types'\nimport type { GetAbiItemParameters } from '../../utils'\nimport { getAbiItem } from '../../utils'\nimport { observe } from '../../utils/observe'\nimport { poll } from '../../utils/poll'\nimport {\n  createContractEventFilter,\n  CreateContractEventFilterParameters,\n} from './createContractEventFilter'\nimport { getBlockNumber } from './getBlockNumber'\nimport { getFilterChanges } from './getFilterChanges'\nimport { getLogs, GetLogsParameters } from './getLogs'\nimport { uninstallFilter } from './uninstallFilter'\n\nexport type OnLogsParameter<\n  TAbi extends Abi | readonly unknown[] = readonly unknown[],\n  TEventName extends string = string,\n> = TAbi extends Abi\n  ? Log<bigint, number, ExtractAbiEvent<TAbi, TEventName>>[]\n  : Log[]\nexport type OnLogsFn<\n  TAbi extends Abi | readonly unknown[] = readonly unknown[],\n  TEventName extends string = string,\n> = (logs: OnLogsParameter<TAbi, TEventName>) => void\n\nexport type WatchContractEventParameters<\n  TAbi extends Abi | readonly unknown[] = readonly unknown[],\n  TEventName extends string = string,\n> = {\n  /** The address of the contract. */\n  address?: Address | Address[]\n  /** Contract ABI. */\n  abi: Narrow<TAbi>\n  args?: ExtractEventArgsFromAbi<TAbi, TEventName>\n  /** Whether or not the event logs should be batched on each invocation. */\n  batch?: boolean\n  /** Contract event. */\n  eventName?: ExtractEventNameFromAbi<TAbi, TEventName>\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: (error: Error) => void\n  /** The callback to call when new event logs are received. */\n  onLogs: OnLogsFn<TAbi, TEventName>\n  /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */\n  pollingInterval?: number\n}\n\nexport function watchContractEvent<\n  TAbi extends Abi | readonly unknown[],\n  TEventName extends string,\n>(\n  client: PublicClient,\n  {\n    abi,\n    address,\n    args,\n    batch = true,\n    eventName,\n    onError,\n    onLogs,\n    pollingInterval = client.pollingInterval,\n  }: WatchContractEventParameters<TAbi, TEventName>,\n) {\n  const observerId = JSON.stringify([\n    'watchContractEvent',\n    address,\n    args,\n    batch,\n    client.uid,\n    eventName,\n    pollingInterval,\n  ])\n\n  return observe(observerId, { onLogs, onError }, (emit) => {\n    let currentBlockNumber: bigint\n    let filter: Filter<'event', TAbi, TEventName> | undefined\n    let initialized = false\n\n    const unwatch = poll(\n      async () => {\n        if (!initialized) {\n          try {\n            filter = (await createContractEventFilter(client, {\n              abi,\n              address,\n              args,\n              eventName,\n            } as unknown as CreateContractEventFilterParameters)) as Filter<\n              'event',\n              TAbi,\n              TEventName\n            >\n          } catch {}\n          initialized = true\n          return\n        }\n\n        try {\n          let logs: Log[]\n          if (filter) {\n            logs = await getFilterChanges(client, { filter })\n          } else {\n            // If the filter doesn't exist, we will fall back to use `getLogs`.\n            // The fall back exists because some RPC Providers do not support filters.\n\n            // Fetch the block number to use for `getLogs`.\n            const blockNumber = await getBlockNumber(client)\n\n            // If the block number has changed, we will need to fetch the logs.\n            // If the block number doesn't exist, we are yet to reach the first poll interval,\n            // so do not emit any logs.\n            if (currentBlockNumber && currentBlockNumber !== blockNumber) {\n              logs = await getLogs(client, {\n                address,\n                args,\n                fromBlock: blockNumber,\n                toBlock: blockNumber,\n                event: getAbiItem({\n                  abi,\n                  name: eventName,\n                } as unknown as GetAbiItemParameters),\n              } as unknown as GetLogsParameters)\n            } else {\n              logs = []\n            }\n            currentBlockNumber = blockNumber\n          }\n\n          if (logs.length === 0) return\n          if (batch) emit.onLogs(logs as any)\n          else logs.forEach((log) => emit.onLogs([log] as any))\n        } catch (err) {\n          emit.onError?.(err as Error)\n        }\n      },\n      {\n        emitOnBegin: true,\n        interval: pollingInterval,\n      },\n    )\n\n    return async () => {\n      if (filter) await uninstallFilter(client, { filter })\n      unwatch()\n    }\n  })\n}\n","import { AbiEvent } from 'abitype'\nimport type { PublicClient } from '../../clients'\nimport type {\n  Address,\n  Filter,\n  Log,\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types'\nimport { observe } from '../../utils/observe'\nimport { poll } from '../../utils/poll'\nimport {\n  createEventFilter,\n  CreateEventFilterParameters,\n} from './createEventFilter'\nimport { getBlockNumber } from './getBlockNumber'\nimport { getFilterChanges } from './getFilterChanges'\nimport { getLogs } from './getLogs'\nimport { uninstallFilter } from './uninstallFilter'\n\nexport type OnLogsParameter<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = Log<bigint, number, TAbiEvent, [TAbiEvent], TEventName>[]\nexport type OnLogsFn<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = (logs: OnLogsParameter<TAbiEvent, TEventName>) => void\n\nexport type WatchEventParameters<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = {\n  /** The address of the contract. */\n  address?: Address | Address[]\n  /** Whether or not the event logs should be batched on each invocation. */\n  batch?: boolean\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: (error: Error) => void\n  /** The callback to call when new event logs are received. */\n  onLogs: OnLogsFn<TAbiEvent, TEventName>\n  /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */\n  pollingInterval?: number\n} & (\n  | {\n      event: TAbiEvent\n      args?: MaybeExtractEventArgsFromAbi<[TAbiEvent], TEventName>\n    }\n  | {\n      event?: never\n      args?: never\n    }\n)\n\nexport function watchEvent<\n  TAbiEvent extends AbiEvent | undefined,\n  TEventName extends string | undefined,\n>(\n  client: PublicClient,\n  {\n    address,\n    args,\n    batch = true,\n    event,\n    onError,\n    onLogs,\n    pollingInterval = client.pollingInterval,\n  }: WatchEventParameters<TAbiEvent>,\n) {\n  const observerId = JSON.stringify([\n    'watchEvent',\n    address,\n    args,\n    batch,\n    client.uid,\n    event,\n    pollingInterval,\n  ])\n\n  return observe(observerId, { onLogs, onError }, (emit) => {\n    let currentBlockNumber: bigint\n    let filter: Filter<'event', [TAbiEvent], TEventName, any>\n    let initialized = false\n\n    const unwatch = poll(\n      async () => {\n        if (!initialized) {\n          try {\n            filter = (await createEventFilter(client, {\n              address,\n              args,\n              event: event!,\n            } as unknown as CreateEventFilterParameters)) as unknown as Filter<\n              'event',\n              [TAbiEvent],\n              TEventName\n            >\n          } catch {}\n          initialized = true\n          return\n        }\n\n        try {\n          let logs: Log[]\n          if (filter) {\n            logs = await getFilterChanges(client, { filter })\n          } else {\n            // If the filter doesn't exist, we will fall back to use `getLogs`.\n            // The fall back exists because some RPC Providers do not support filters.\n\n            // Fetch the block number to use for `getLogs`.\n            const blockNumber = await getBlockNumber(client)\n\n            // If the block number has changed, we will need to fetch the logs.\n            // If the block number doesn't exist, we are yet to reach the first poll interval,\n            // so do not emit any logs.\n            if (currentBlockNumber && currentBlockNumber !== blockNumber) {\n              logs = await getLogs(client, {\n                address,\n                args,\n                fromBlock: blockNumber,\n                toBlock: blockNumber,\n                event: event!,\n              })\n            } else {\n              logs = []\n            }\n            currentBlockNumber = blockNumber\n          }\n\n          if (logs.length === 0) return\n          if (batch) emit.onLogs(logs as any)\n          else logs.forEach((log) => emit.onLogs([log] as any))\n        } catch (err) {\n          emit.onError?.(err as Error)\n        }\n      },\n      {\n        emitOnBegin: true,\n        interval: pollingInterval,\n      },\n    )\n\n    return async () => {\n      if (filter) await uninstallFilter(client, { filter })\n      unwatch()\n    }\n  })\n}\n","import type { PublicClient } from '../../clients'\nimport type { Filter, Hash } from '../../types'\nimport { observe } from '../../utils/observe'\nimport { poll } from '../../utils/poll'\nimport { createPendingTransactionFilter } from './createPendingTransactionFilter'\nimport { getFilterChanges } from './getFilterChanges'\nimport { uninstallFilter } from './uninstallFilter'\n\nexport type OnTransactionsParameter = Hash[]\nexport type OnTransactionsFn = (transactions: OnTransactionsParameter) => void\n\nexport type WatchPendingTransactionsParameters = {\n  /** Whether or not the transaction hashes should be batched on each invocation. */\n  batch?: boolean\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: (error: Error) => void\n  /** The callback to call when new transactions are received. */\n  onTransactions: OnTransactionsFn\n  /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */\n  pollingInterval?: number\n}\n\nexport function watchPendingTransactions(\n  client: PublicClient,\n  {\n    batch = true,\n    onError,\n    onTransactions,\n    pollingInterval = client.pollingInterval,\n  }: WatchPendingTransactionsParameters,\n) {\n  const observerId = JSON.stringify([\n    'watchPendingTransactions',\n    client.uid,\n    batch,\n    pollingInterval,\n  ])\n\n  return observe(observerId, { onTransactions, onError }, (emit) => {\n    let filter: Filter<'transaction'>\n\n    const unwatch = poll(\n      async () => {\n        try {\n          if (!filter) {\n            try {\n              filter = await createPendingTransactionFilter(client)\n              return\n            } catch (err) {\n              unwatch()\n              throw err\n            }\n          }\n\n          const hashes = await getFilterChanges(client, { filter })\n          if (hashes.length === 0) return\n          if (batch) emit.onTransactions(hashes)\n          else hashes.forEach((hash) => emit.onTransactions([hash]))\n        } catch (err) {\n          emit.onError?.(err as Error)\n        }\n      },\n      {\n        emitOnBegin: true,\n        interval: pollingInterval,\n      },\n    )\n\n    return async () => {\n      if (filter) await uninstallFilter(client, { filter })\n      unwatch()\n    }\n  })\n}\n","import type { TestClient } from '../../clients'\nimport type { Hash } from '../../types'\n\nexport type DropTransactionParameters = {\n  /** The hash of the transaction to drop. */\n  hash: Hash\n}\n\nexport async function dropTransaction(\n  client: TestClient,\n  { hash }: DropTransactionParameters,\n) {\n  return await client.request({\n    method: `${client.mode}_dropTransaction`,\n    params: [hash],\n  })\n}\n","import type { TestClient } from '../../clients'\n\nexport type GetAutomineReturnType = boolean\n\nexport async function getAutomine(\n  client: TestClient,\n): Promise<GetAutomineReturnType> {\n  return await client.request({\n    method: `${client.mode}_getAutomine`,\n  })\n}\n","import { Address } from 'abitype'\nimport type { TestClient } from '../../clients'\nimport { RpcTransaction } from '../../types'\n\nexport type GetTxpoolContentReturnType = {\n  pending: Record<Address, Record<string, RpcTransaction>>\n  queued: Record<Address, Record<string, RpcTransaction>>\n}\n\nexport async function getTxpoolContent(\n  client: TestClient,\n): Promise<GetTxpoolContentReturnType> {\n  return await client.request({\n    method: 'txpool_content',\n  })\n}\n","import type { TestClient } from '../../clients'\nimport { hexToNumber } from '../../utils'\n\nexport type GetTxpoolStatusReturnType = {\n  pending: number\n  queued: number\n}\n\nexport async function getTxpoolStatus(\n  client: TestClient,\n): Promise<GetTxpoolStatusReturnType> {\n  const { pending, queued } = await client.request({\n    method: 'txpool_status',\n  })\n  return {\n    pending: hexToNumber(pending),\n    queued: hexToNumber(queued),\n  }\n}\n","import type { TestClient } from '../../clients'\nimport type { Address } from '../../types'\n\nexport type ImpersonateAccountParameters = {\n  /** The account to impersonate. */\n  address: Address\n}\n\nexport async function impersonateAccount(\n  client: TestClient,\n  { address }: ImpersonateAccountParameters,\n) {\n  return await client.request({\n    method: `${client.mode}_impersonateAccount`,\n    params: [address],\n  })\n}\n","import type { TestClient } from '../../clients'\nimport { numberToHex } from '../../utils'\n\nexport type IncreaseTimeParameters = {\n  /** The amount of seconds to jump forward in time. */\n  seconds: number\n}\n\nexport async function increaseTime(\n  client: TestClient,\n  { seconds }: IncreaseTimeParameters,\n) {\n  return await client.request({\n    method: 'evm_increaseTime',\n    params: [numberToHex(seconds)],\n  })\n}\n","import type { TestClient } from '../../clients'\nimport { Address } from '../../types'\n\nexport type InspectTxpoolReturnType = {\n  pending: Record<Address, Record<string, string>>\n  queued: Record<Address, Record<string, string>>\n}\n\nexport async function inspectTxpool(\n  client: TestClient,\n): Promise<InspectTxpoolReturnType> {\n  return await client.request({\n    method: 'txpool_inspect',\n  })\n}\n","import type { TestClient } from '../../clients'\nimport { numberToHex } from '../../utils'\n\nexport type MineParameters = {\n  /** Number of blocks to mine. */\n  blocks: number\n  /** Interval between each block in seconds. */\n  interval?: number\n}\n\nexport async function mine(\n  client: TestClient,\n  { blocks, interval }: MineParameters,\n) {\n  return await client.request({\n    method: `${client.mode}_mine`,\n    params: [numberToHex(blocks), numberToHex(interval || 0)],\n  })\n}\n","import type { TestClient } from '../../clients'\n\nexport async function removeBlockTimestampInterval(client: TestClient) {\n  return await client.request({\n    method: `${client.mode}_removeBlockTimestampInterval`,\n  })\n}\n","import type { TestClient } from '../../clients'\n\nexport type ResetParameters = {\n  /** The block number to reset from. */\n  blockNumber?: bigint\n  /** The JSON RPC URL. */\n  jsonRpcUrl?: string\n}\n\nexport async function reset(\n  client: TestClient,\n  { blockNumber, jsonRpcUrl }: ResetParameters = {},\n) {\n  return await client.request({\n    method: `${client.mode}_reset`,\n    params: [{ forking: { blockNumber: Number(blockNumber), jsonRpcUrl } }],\n  })\n}\n","import type { TestClient } from '../../clients'\nimport type { Quantity } from '../../types'\n\nexport type RevertParameters = {\n  /** The snapshot ID to revert to. */\n  id: Quantity\n}\n\nexport async function revert(client: TestClient, { id }: RevertParameters) {\n  return await client.request({\n    method: 'evm_revert',\n    params: [id],\n  })\n}\n","import type { TestClient } from '../../clients'\nimport type { Hash, TransactionRequest } from '../../types'\nimport { formatTransactionRequest } from '../../utils'\n\nexport type SendUnsignedTransactionParameters = TransactionRequest\n\nexport type SendUnsignedTransactionReturnType = Hash\n\nexport async function sendUnsignedTransaction(\n  client: TestClient,\n  request: SendUnsignedTransactionParameters,\n): Promise<SendUnsignedTransactionReturnType> {\n  const request_ = formatTransactionRequest(request)\n  const hash = await client.request({\n    method: 'eth_sendUnsignedTransaction',\n    params: [request_],\n  })\n  return hash\n}\n","import type { TestClient } from '../../clients'\n\nexport async function setAutomine(client: TestClient, enabled: boolean) {\n  return await client.request({\n    method: 'evm_setAutomine',\n    params: [enabled],\n  })\n}\n","import type { TestClient } from '../../clients'\nimport type { Address } from '../../types'\nimport { numberToHex } from '../../utils'\n\nexport type SetBalanceParameters = {\n  /** The account address. */\n  address: Address\n  /** Amount (in wei) to set */\n  value: bigint\n}\n\nexport async function setBalance(\n  client: TestClient,\n  { address, value }: SetBalanceParameters,\n) {\n  return await client.request({\n    method: `${client.mode}_setBalance`,\n    params: [address, numberToHex(value)],\n  })\n}\n","import type { TestClient } from '../../clients'\nimport { numberToHex } from '../../utils'\n\nexport type SetBlockGasLimitParameters = {\n  /** Gas limit (in wei). */\n  gasLimit: bigint\n}\n\nexport async function setBlockGasLimit(\n  client: TestClient,\n  { gasLimit }: SetBlockGasLimitParameters,\n) {\n  return await client.request({\n    method: 'evm_setBlockGasLimit',\n    params: [numberToHex(gasLimit)],\n  })\n}\n","import type { TestClient } from '../../clients'\n\nexport type SetBlockTimestampIntervalParameters = {\n  /** The interval (in seconds). */\n  interval: number\n}\n\nexport async function setBlockTimestampInterval(\n  client: TestClient,\n  { interval }: SetBlockTimestampIntervalParameters,\n) {\n  return await client.request({\n    method: `${client.mode}_setBlockTimestampInterval`,\n    params: [interval],\n  })\n}\n","import type { TestClient } from '../../clients'\nimport type { Address, Hex } from '../../types'\n\nexport type SetCodeParameters = {\n  /** The account address. */\n  address: Address\n  /** The bytecode to set */\n  bytecode: Hex\n}\n\nexport async function setCode(\n  client: TestClient,\n  { address, bytecode }: SetCodeParameters,\n) {\n  return await client.request({\n    method: `${client.mode}_setCode`,\n    params: [address, bytecode],\n  })\n}\n","import type { TestClient } from '../../clients'\nimport type { Address } from '../../types'\n\nexport type SetCoinbaseParameters = {\n  /** The coinbase address. */\n  address: Address\n}\n\nexport async function setCoinbase(\n  client: TestClient,\n  { address }: SetCoinbaseParameters,\n) {\n  return await client.request({\n    method: `${client.mode}_setCoinbase`,\n    params: [address],\n  })\n}\n","import type { TestClient } from '../../clients'\n\nexport type SetIntervalMiningParameters = {\n  /** The mining interval. */\n  interval: number\n}\n\nexport async function setIntervalMining(\n  client: TestClient,\n  { interval }: SetIntervalMiningParameters,\n) {\n  return await client.request({\n    method: 'evm_setIntervalMining',\n    params: [interval],\n  })\n}\n","import type { TestClient } from '../../clients'\n\nexport async function setLoggingEnabled(client: TestClient, enabled: boolean) {\n  return await client.request({\n    method: `${client.mode}_setLoggingEnabled`,\n    params: [enabled],\n  })\n}\n","import type { TestClient } from '../../clients'\nimport { numberToHex } from '../../utils'\n\nexport type SetMinGasPriceParameters = {\n  /** The gas price. */\n  gasPrice: bigint\n}\n\nexport async function setMinGasPrice(\n  client: TestClient,\n  { gasPrice }: SetMinGasPriceParameters,\n) {\n  return await client.request({\n    method: `${client.mode}_setMinGasPrice`,\n    params: [numberToHex(gasPrice)],\n  })\n}\n","import type { TestClient } from '../../clients'\nimport { numberToHex } from '../../utils'\n\nexport type SetNextBlockBaseFeePerGasParameters = {\n  /** Base fee per gas (in wei). */\n  baseFeePerGas: bigint\n}\n\nexport async function setNextBlockBaseFeePerGas(\n  client: TestClient,\n  { baseFeePerGas }: SetNextBlockBaseFeePerGasParameters,\n) {\n  return await client.request({\n    method: `${client.mode}_setNextBlockBaseFeePerGas`,\n    params: [numberToHex(baseFeePerGas)],\n  })\n}\n","import type { TestClient } from '../../clients'\nimport { numberToHex } from '../../utils'\n\nexport type SetNextBlockTimestampParameters = {\n  /** The timestamp (in seconds). */\n  timestamp: bigint\n}\n\nexport async function setNextBlockTimestamp(\n  client: TestClient,\n  { timestamp }: SetNextBlockTimestampParameters,\n) {\n  return await client.request({\n    method: 'evm_setNextBlockTimestamp',\n    params: [numberToHex(timestamp)],\n  })\n}\n","import type { TestClient } from '../../clients'\nimport type { Address } from '../../types'\nimport { numberToHex } from '../../utils'\n\nexport type SetNonceParameters = {\n  /** The account address. */\n  address: Address\n  /** The nonce to set. */\n  nonce: number\n}\n\nexport async function setNonce(\n  client: TestClient,\n  { address, nonce }: SetNonceParameters,\n) {\n  return await client.request({\n    method: `${client.mode}_setNonce`,\n    params: [address, numberToHex(nonce)],\n  })\n}\n","import type { TestClient } from '../../clients'\n\nexport async function setRpcUrl(client: TestClient, jsonRpcUrl: string) {\n  return await client.request({\n    method: `${client.mode}_setRpcUrl`,\n    params: [jsonRpcUrl],\n  })\n}\n","import type { TestClient } from '../../clients'\nimport type { Address, Hash, Hex } from '../../types'\nimport { numberToHex } from '../../utils'\n\nexport type SetStorageAtParameters = {\n  /** The account address. */\n  address: Address\n  /** The storage slot (index). Can either be a number or hash value. */\n  index: number | Hash\n  /** The value to store as a 32 byte hex string. */\n  value: Hex\n}\n\nexport async function setStorageAt(\n  client: TestClient,\n  { address, index, value }: SetStorageAtParameters,\n) {\n  return await client.request({\n    method: `${client.mode}_setStorageAt`,\n    params: [\n      address,\n      typeof index === 'number' ? numberToHex(index) : index,\n      value,\n    ],\n  })\n}\n","import type { TestClient } from '../../clients'\n\nexport async function snapshot(client: TestClient) {\n  return await client.request({\n    method: 'evm_snapshot',\n  })\n}\n","import type { TestClient } from '../../clients'\nimport type { Address } from '../../types'\n\nexport type StopImpersonatingAccountParameters = {\n  /** The account to impersonate. */\n  address: Address\n}\n\nexport async function stopImpersonatingAccount(\n  client: TestClient,\n  { address }: StopImpersonatingAccountParameters,\n) {\n  return await client.request({\n    method: `${client.mode}_stopImpersonatingAccount`,\n    params: [address],\n  })\n}\n","import type { WalletClient } from '../../clients'\nimport type { Chain } from '../../types'\nimport { numberToHex } from '../../utils'\n\nexport type AddChainParameters = {\n  chain: Chain\n}\n\nexport async function addChain(\n  client: WalletClient,\n  { chain }: AddChainParameters,\n) {\n  const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain\n  await client.request({\n    method: 'wallet_addEthereumChain',\n    params: [\n      {\n        chainId: numberToHex(id),\n        chainName: name,\n        nativeCurrency,\n        rpcUrls: rpcUrls.default.http,\n        blockExplorerUrls: blockExplorers\n          ? Object.values(blockExplorers).map(({ url }) => url)\n          : undefined,\n      },\n    ],\n  })\n}\n","import { Abi, Narrow } from 'abitype'\nimport { WalletClient } from '../../clients'\n\nimport { Chain, ExtractConstructorArgsFromAbi, Hex } from '../../types'\nimport { encodeDeployData } from '../../utils'\nimport {\n  sendTransaction,\n  SendTransactionParameters,\n  SendTransactionReturnType,\n} from '../wallet'\n\nexport type DeployContractParameters<\n  TChain extends Chain = Chain,\n  TAbi extends Abi | readonly unknown[] = Abi,\n> = Omit<\n  SendTransactionParameters<TChain>,\n  'accessList' | 'to' | 'data' | 'value'\n> & {\n  abi: Narrow<TAbi>\n  bytecode: Hex\n} & ExtractConstructorArgsFromAbi<TAbi>\n\nexport type DeployContractReturnType = SendTransactionReturnType\n\nexport function deployContract<\n  TChain extends Chain,\n  TAbi extends Abi | readonly unknown[],\n>(\n  walletClient: WalletClient,\n  { abi, args, bytecode, ...request }: DeployContractParameters<TChain, TAbi>,\n): Promise<DeployContractReturnType> {\n  const calldata = encodeDeployData({\n    abi,\n    args,\n    bytecode,\n  } as unknown as DeployContractParameters<TChain, TAbi>)\n  return sendTransaction(walletClient, {\n    ...request,\n    data: calldata,\n  } as unknown as SendTransactionParameters<TChain>)\n}\n","import { Address } from 'abitype'\nimport type { WalletClient } from '../../clients'\nimport { checksumAddress } from '../../utils/address'\n\nexport type GetAddressesReturnType = Address[]\n\nexport async function getAddresses(\n  client: WalletClient,\n): Promise<GetAddressesReturnType> {\n  const addresses = await client.request({ method: 'eth_accounts' })\n  return addresses.map((address) => checksumAddress(address))\n}\n","import type { WalletClient } from '../../clients'\nimport type { WalletPermission } from '../../types/eip1193'\n\nexport type GetPermissionsReturnType = WalletPermission[]\n\nexport async function getPermissions(client: WalletClient) {\n  const permissions = await client.request({ method: 'wallet_getPermissions' })\n  return permissions\n}\n","import { Address } from 'abitype'\nimport type { WalletClient } from '../../clients'\nimport { getAddress } from '../../utils'\n\nexport type RequestAddressesReturnType = Address[]\n\nexport async function requestAddresses(\n  client: WalletClient,\n): Promise<RequestAddressesReturnType> {\n  const addresses = await client.request({ method: 'eth_requestAccounts' })\n  return addresses.map((address) => getAddress(address))\n}\n","import type { WalletClient } from '../../clients'\nimport type { WalletPermission } from '../../types/eip1193'\n\nexport type RequestPermissionsParameters = {\n  eth_accounts: Record<string, any>\n} & {\n  [key: string]: Record<string, any>\n}\nexport type RequestPermissionsReturnType = WalletPermission[]\n\nexport async function requestPermissions(\n  client: WalletClient,\n  permissions: RequestPermissionsParameters,\n) {\n  return client.request({\n    method: 'wallet_requestPermissions',\n    params: [permissions],\n  })\n}\n","import { prepareRequest } from '../../utils'\nimport type { WalletClient } from '../../clients'\nimport { BaseError, ChainMismatchError } from '../../errors'\nimport type {\n  Chain,\n  Formatter,\n  Hash,\n  MergeIntersectionProperties,\n  TransactionRequest,\n} from '../../types'\nimport { Account } from '../../types/account'\nimport {\n  Formatted,\n  TransactionRequestFormatter,\n  assertRequest,\n  extract,\n  format,\n  formatTransactionRequest,\n  getTransactionError,\n} from '../../utils'\nimport { getChainId } from '../public'\n\nexport type FormattedTransactionRequest<\n  TFormatter extends Formatter | undefined = Formatter,\n> = MergeIntersectionProperties<\n  Omit<Formatted<TFormatter, TransactionRequest, true>, 'from'>,\n  TransactionRequest\n>\n\nexport type SendTransactionParameters<TChain extends Chain = Chain> =\n  FormattedTransactionRequest<TransactionRequestFormatter<TChain>> & {\n    account: Account\n  } & (\n      | {\n          assertChain?: false\n          chain?: TChain\n        }\n      | {\n          assertChain: true\n          chain: TChain\n        }\n    )\n\nexport type SendTransactionReturnType = Hash\n\nexport async function sendTransaction<TChain extends Chain>(\n  client: WalletClient,\n  args: SendTransactionParameters<TChain>,\n): Promise<SendTransactionReturnType> {\n  const {\n    account,\n    chain,\n    accessList,\n    assertChain = true,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    ...rest\n  } = args\n  try {\n    assertRequest(args)\n\n    const currentChainId = await getChainId(client)\n    if (assertChain && chain && currentChainId !== chain?.id)\n      throw new ChainMismatchError({ chain, currentChainId })\n\n    if (account.type === 'local') {\n      const chainId = chain?.id ?? currentChainId\n\n      // Prepare the request for signing (assign appropriate fees, etc.)\n      const request = await prepareRequest(client, {\n        account,\n        accessList,\n        chain,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        to,\n        value,\n        ...rest,\n      })\n\n      const signedRequest = (await account.signTransaction({\n        chainId,\n        ...request,\n      })) as Hash\n      return await client.request({\n        method: 'eth_sendRawTransaction',\n        params: [signedRequest],\n      })\n    }\n\n    const formatter = chain?.formatters?.transactionRequest\n    const request = format(\n      {\n        accessList,\n        data,\n        from: account.address,\n        gas,\n        gasPrice,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        to,\n        value,\n        // Pick out extra data that might exist on the chain's transaction request type.\n        ...extract(rest, { formatter }),\n      } as TransactionRequest,\n      {\n        formatter: formatter || formatTransactionRequest,\n      },\n    )\n    return await client.request({\n      method: 'eth_sendTransaction',\n      params: [request],\n    })\n  } catch (err) {\n    throw getTransactionError(err as BaseError, args)\n  }\n}\n","import type { WalletClient } from '../../clients'\nimport type { Account, Hex } from '../../types'\nimport { toHex } from '../../utils'\n\nexport type SignMessageParameters = {\n  account: Account\n  data: string\n}\n\nexport type SignMessageReturnType = Hex\n\nexport async function signMessage(\n  client: WalletClient,\n  { account, data }: SignMessageParameters,\n): Promise<SignMessageReturnType> {\n  if (account.type === 'local') return account.signMessage(data)\n  return client.request({\n    method: 'personal_sign',\n    params: [toHex(data), account.address],\n  })\n}\n","import type { WalletClient } from '../../clients'\nimport { Chain } from '../../types'\nimport { numberToHex } from '../../utils'\n\nexport type SwitchChainParameters = { id: Chain['id'] }\n\nexport async function switchChain(\n  client: WalletClient,\n  { id }: SwitchChainParameters,\n) {\n  await client.request({\n    method: 'wallet_switchEthereumChain',\n    params: [\n      {\n        chainId: numberToHex(id),\n      },\n    ],\n  })\n}\n","import type { WalletClient } from '../../clients'\nimport type { WatchAssetParams } from '../../types/eip1193'\n\nexport type WatchAssetParameters = WatchAssetParams\nexport type WatchAssetReturnType = boolean\n\nexport async function watchAsset(\n  client: WalletClient,\n  params: WatchAssetParameters,\n): Promise<WatchAssetReturnType> {\n  const added = await client.request({\n    method: 'wallet_watchAsset',\n    params: [params],\n  })\n  return added\n}\n","import { Abi } from 'abitype'\n\nimport type { WalletClient } from '../../clients'\nimport type { Chain, ContractConfig, GetValue } from '../../types'\nimport { EncodeFunctionDataParameters, encodeFunctionData } from '../../utils'\nimport {\n  sendTransaction,\n  SendTransactionParameters,\n  SendTransactionReturnType,\n} from './sendTransaction'\n\nexport type WriteContractParameters<\n  TChain extends Chain = Chain,\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = string,\n> = Omit<SendTransactionParameters<TChain>, 'to' | 'data' | 'value'> & {\n  value?: GetValue<\n    TAbi,\n    TFunctionName,\n    SendTransactionParameters<TChain>['value']\n  >\n} & ContractConfig<TAbi, TFunctionName, 'payable' | 'nonpayable'>\n\nexport type WriteContractReturnType = SendTransactionReturnType\n\nexport async function writeContract<\n  TChain extends Chain,\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n>(\n  client: WalletClient,\n  {\n    abi,\n    address,\n    args,\n    functionName,\n    ...request\n  }: WriteContractParameters<TChain, TAbi, TFunctionName>,\n): Promise<WriteContractReturnType> {\n  const data = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as unknown as EncodeFunctionDataParameters<TAbi, TFunctionName>)\n  const hash = await sendTransaction(client, {\n    data,\n    to: address,\n    ...request,\n  } as unknown as SendTransactionParameters<TChain>)\n  return hash\n}\n","export function parseUnits(value: `${number}`, decimals: number) {\n  let [integer, fraction = '0'] = value.split('.')\n\n  const negative = integer.startsWith('-')\n  if (negative) integer = integer.slice(1)\n\n  // trim leading zeros.\n  fraction = fraction.replace(/(0+)$/, '')\n\n  // round off if the fraction is larger than the number of decimals.\n  if (decimals === 0) {\n    integer = `${Math.round(Number(`${integer}.${fraction}`))}`\n    fraction = ''\n  } else if (fraction.length > decimals) {\n    const [before, after] = [\n      fraction.slice(0, decimals),\n      fraction.slice(decimals),\n    ]\n    fraction = `${\n      /^0+$/.test(before) ? before.slice(0, before.length - 1) : ''\n    }${Math.round(Number(`${before}.${after}`))}`\n  } else {\n    fraction = fraction.padEnd(decimals, '0')\n  }\n\n  return BigInt(`${negative ? '-' : ''}${integer}${fraction}`)\n}\n","import { gweiUnits } from '../../constants'\nimport { parseUnits } from './parseUnits'\n\nexport function parseGwei(ether: `${number}`, unit: 'wei' = 'wei') {\n  return parseUnits(ether, gweiUnits[unit])\n}\n","import {\n  estimateGas,\n  getBlock,\n  getGasPrice,\n  getTransactionCount,\n  SendTransactionParameters,\n} from '../../actions'\nimport { PublicClient, WalletClient } from '../../clients'\nimport { BaseError } from '../../errors'\nimport { Address } from '../../types'\nimport { parseGwei } from '../unit/parseGwei'\nimport { assertRequest } from './assertRequest'\n\nexport type PrepareRequestParameters<\n  TParameters extends SendTransactionParameters = SendTransactionParameters,\n> = TParameters\n\nexport type PrepareRequestReturnType<\n  TParameters extends SendTransactionParameters = SendTransactionParameters,\n> = TParameters & {\n  from: Address\n  gas: SendTransactionParameters['gas']\n  gasPrice?: SendTransactionParameters['gasPrice']\n  maxFeePerGas?: SendTransactionParameters['maxFeePerGas']\n  maxPriorityFeePerGas?: SendTransactionParameters['maxPriorityFeePerGas']\n  nonce: SendTransactionParameters['nonce']\n}\n\nexport const defaultTip = parseGwei('1.5')\n\nexport async function prepareRequest<\n  TParameters extends SendTransactionParameters,\n>(\n  client: WalletClient<any, any> | PublicClient<any, any>,\n  args: PrepareRequestParameters<TParameters>,\n): Promise<PrepareRequestReturnType<TParameters>> {\n  const { account, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce } =\n    args\n\n  const block = await getBlock(client, { blockTag: 'latest' })\n\n  const request = { ...args, from: account.address }\n\n  if (typeof nonce === 'undefined')\n    request.nonce = await getTransactionCount(client, {\n      address: account.address,\n      blockTag: 'pending',\n    })\n\n  if (block.baseFeePerGas) {\n    if (typeof gasPrice !== 'undefined')\n      throw new BaseError('Chain does not support legacy `gasPrice`.')\n\n    // EIP-1559 fees\n    if (typeof maxFeePerGas === 'undefined') {\n      // Set a buffer of 1.2x on top of the base fee to account for fluctuations.\n      request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? defaultTip\n      request.maxFeePerGas =\n        (block.baseFeePerGas * 120n) / 100n + request.maxPriorityFeePerGas\n    } else {\n      if (\n        typeof maxPriorityFeePerGas === 'undefined' &&\n        maxFeePerGas < defaultTip\n      )\n        throw new BaseError(\n          '`maxFeePerGas` cannot be less than the default `maxPriorityFeePerGas` (1.5 gwei).',\n        )\n      request.maxFeePerGas = maxFeePerGas\n      request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? defaultTip\n    }\n  } else {\n    if (\n      typeof maxFeePerGas !== 'undefined' ||\n      typeof maxPriorityFeePerGas !== 'undefined'\n    )\n      throw new BaseError('Chain does not support EIP-1559 fees.')\n\n    // Legacy fees\n    if (typeof gasPrice === 'undefined')\n      // Set a buffer of 1.2x on top of the base fee to account for fluctuations.\n      request.gasPrice = ((await getGasPrice(client)) * 120n) / 100n\n  }\n\n  if (typeof gas === 'undefined')\n    request.gas = await estimateGas(client, {\n      ...request,\n      account: { address: account.address, type: 'json-rpc' },\n    })\n\n  assertRequest(request)\n\n  return request as PrepareRequestReturnType<TParameters>\n}\n","export function formatUnits(value: bigint, decimals: number) {\n  let display = value.toString()\n\n  const negative = display.startsWith('-')\n  if (negative) display = display.slice(1)\n\n  display = display.padStart(decimals, '0')\n\n  let [integer, fraction] = [\n    display.slice(0, display.length - decimals),\n    display.slice(display.length - decimals),\n  ]\n  fraction = fraction.replace(/(0+)$/, '')\n  return `${negative ? '-' : ''}${integer || '0'}${\n    fraction ? `.${fraction}` : ''\n  }`\n}\n","import { etherUnits } from '../../constants'\nimport { formatUnits } from './formatUnits'\n\nexport function formatEther(wei: bigint, unit: 'wei' | 'gwei' = 'wei') {\n  return formatUnits(wei, etherUnits[unit])\n}\n","import { gweiUnits } from '../../constants'\nimport { formatUnits } from './formatUnits'\n\nexport function formatGwei(wei: bigint, unit: 'wei' = 'wei') {\n  return formatUnits(wei, gweiUnits[unit])\n}\n","import { etherUnits } from '../../constants'\nimport { parseUnits } from './parseUnits'\n\nexport function parseEther(ether: `${number}`, unit: 'wei' | 'gwei' = 'wei') {\n  return parseUnits(ether, etherUnits[unit])\n}\n"],"mappings":"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","names":["docsPath","docsPath","size","docsPath","hash","docsPath","size","docsPath","docsPath","size","size","size","parse","format","length","lengthOfLength","hash","getContractAddress","length","length","consumed","value","size","docsPath","docsPath","docsPath","size","cacheKey","format","docsPath","docsPath","docsPath","docsPath","value","response","webSocket","id","format","id","id","id","id","format","format","id","args","hash","format","hash","hash","format","args","listeners","cleanup","hash","poll","block","hash","hash","id","hash","id","request","format","id","hash"]}